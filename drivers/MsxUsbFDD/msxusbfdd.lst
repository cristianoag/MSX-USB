0001   0000             ; MSXUSB USB FDD BIOS
0002   0000             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003   0000             ; This version is adapted to work with the latest version of the MSXUSB project
0004   0000             ;
0005   0000             ; This is the main file. Assemble with:
0006   0000             ; sjasm msxusbfdd.asm USBFDD.rom
0007   0000             ;
0008   0000             ; See config.asm for customization options
0009   0000             
0010   0000             CALL_IX:   equ 7FD0h
0011   0000             CALL_BANK: equ CALL_IX+2
0012   0000             
0013   0000                 include "constants.asm"
0001+  0000             CGTABL: equ 0004h ;Address of font definition in BIOS ROM
0002+  0000             
0003+  0000             VDP_DW: equ 0007h
0004+  0000             WRTVRM: equ 004Dh
0005+  0000             SETWRT: equ 0053h
0006+  0000             INITXT: equ 006Ch
0007+  0000             INIT32: equ 006Fh
0008+  0000             CHGET:  equ 009Fh
0009+  0000             CHPUT:  equ 00A2h
0010+  0000             BREAKX: equ 00B7h
0011+  0000             CLS:    equ 00C3h
0012+  0000             POSIT:  equ 00C6h
0013+  0000             ERAFNK: equ 00CCh
0014+  0000             DSPFNK: equ 00CFh
0015+  0000             KILBUF: equ 0156h
0016+  0000             
0017+  0000             CHRGTR: equ 4666h
0018+  0000             FRMEVL: equ 4C64h
0019+  0000             FRMQNT: equ 542Fh
0020+  0000             FRESTR: equ 67D0h
0021+  0000             
0022+  0000             LINL40: equ 0F3AEh
0023+  0000             LINL32: equ 0F3AFh
0024+  0000             LINLEN: equ 0F3B0h
0025+  0000             CRTCNT: equ 0F3B1h
0026+  0000             TXTCGP: equ 0F3B7h ;Address of pattern generator table in VRAM
0027+  0000             CLIKSW: equ 0F3DBh
0028+  0000             CSRX:   equ 0F3DDH
0029+  0000             CNSDFG: equ 0F3DEh
0030+  0000             PUTPNT: equ 0F3F8h
0031+  0000             GETPNT: equ 0F3FAh
0032+  0000             STREND: equ 0F6C6h ;End of memory used by BASIC
0033+  0000             ;NLONLY: equ 0F87Ch
0034+  0000             OLDKEY: equ 0FBDAh
0035+  0000             NEWKEY: equ 0FBE5h
0036+  0000             CAPST:  equ	0FCABh
0037+  0000             KANAST: equ 0FCACh
0038+  0000             ;FLBMEM: equ 0FCAEh
0039+  0000             SCRMOD: equ 0FCAFh
0040+  0000             ;VALTYP: equ 0F663h
0041+  0000             
0042+  0000             ;Keyboard matrix:
0043+  0000             ;       bit 7  bit 6   bit 5   bit 4   bit 3   bit 2   bit 1   bit 0
0044+  0000             ;row 6  F3     F2      F1      CODE    CAPS    GRAPH	CTRL   SHIFT
0045+  0000             ;row 7  RET    SELECT  BS      STOP    TAB     ESC      F5     F4
0046+  0000             ;row 8  Right  Down    Up      Left    DEL     INS      HOME   SPACE
0047+  0000             ;row 9  NUM4   NUM3    NUM2    NUM1    NUM0    NUM/     NUM+   NUM*
0048+  0000             ;row 10 NUM.   NUM,    NUM-    NUM9    NUM8    NUM7     NUM6   NUM5
0014   0000                 include "config.asm"
0001+  0000             ; MSXUSB USB FDD BIOS
0002+  0000             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003+  0000             ; This version is adapted to work with the latest version of the MSXUSB project
0004+  0000             ;
0005+  0000             ; This is the customization options file.
0006+  0000             ; Flags are enabled with value 1 or disabled with value 0.
0007+  0000             
0008+  0000             
0009+  0000             ; -----------------------------------------------------------------------------
0010+  0000             ; Behavior configuration flags
0011+  0000             ; -----------------------------------------------------------------------------
0012+  0000             
0013+  0000             ;Invert the behavior of the CTRL flag, so that
0014+  0000             ;the second "ghost" drive exists only if CTRL is pressed at boot time
0015+  0000             ;(this won't apply to the internal disk drive or other MSX-DOS kernels)
0016+  0000             INVERT_CTRL_KEY: equ 0
0017+  0000             
0018+  0000             ;When this flag is disabled, pressing SHIFT at boot time will disable
0019+  0000             ;all other MSX-DOS ROMs but not this one.
0020+  0000             ;When enabled, all other MSX-DOS ROMs will be disabled except if
0021+  0000             ;GRAPH is pressed at boot time.
0022+  0000             DISABLE_OTHERS_BY_DEFAULT: equ 0
0023+  0000             
0024+  0000             ;Use the alternative set of Z80 ports for accessing the CH376,
0025+  0000             ;if you want to use two Rookie Drives in the same computer
0026+  0000             ;one of them must use the normal ports and the other one
0027+  0000             ;must use the alternative ports
0028+  0000             USE_ALTERNATIVE_PORTS: equ 0
0029+  0000             
0030+  0000             ;Implement the "panic button":
0031+  0000             ;pressing CAPS+ESC will abort the current USB operation
0032+  0000             ;and reset the device
0033+  0000             IMPLEMENT_PANIC_BUTTON: equ 1
0034+  0000             
0035+  0000             ; -----------------------------------------------------------------------------
0036+  0000             ; Debugging switches
0037+  0000             ; You shouldn't enable these unless you are, well, debugging
0038+  0000             ; -----------------------------------------------------------------------------
0039+  0000             
0040+  0000             ;Enable this if you are Konamiman and you are using NestorMSX with
0041+  0000             ;the almigthy Arduino board that Xavirompe sent you 
0042+  0000             USING_ARDUINO_BOARD: equ 0
0043+  0000             
0044+  0000             ;Enable to debug DSKIO calls: whenever DSKIO is called, text mode is enabled,
0045+  0000             ;the input parameters are printed, and system stops waiting for a key press
0046+  0000             DEBUG_DSKIO: equ 0
0047+  0000             
0048+  0000             ;Enable to wait for a key press after displaying the device information
0049+  0000             ;at boot time
0050+  0000             WAIT_KEY_ON_INIT: equ 0
0051+  0000             
0052+  0000             ;Enable to simulate a fake storage device connected to a USB port
0053+  0000             USE_FAKE_STORAGE_DEVICE: equ 0
0054+  0000             
0055+  0000             
0056+  0000             ; -----------------------------------------------------------------------------
0057+  0000             ; ROM configuration
0058+  0000             ; -----------------------------------------------------------------------------
0059+  0000             
0060+  0000             ;The address to switch the ROM bank in the DOS2 mapper implemented by Rookie Drive
0061+  0000             ;crisag - changing the bank switch address to 5000h (KonamiSCC mapper support for MSXUSB)
0062+  0000             ;ROM_BANK_SWITCH: equ 6000h
0063+  0000             ROM_BANK_SWITCH: equ 5000h
0064+  0000             
0065+  0000             ;Enable this if you are adapting this BIOS for hardware other than Rookie Drive
0066+  0000             ;and that hardware uses ASCII8 for ROM mapping.
0067+  0000             ;If you use any ROM mapper other than ASCII8 or DOS2 you will need to change
0068+  0000             ;the code, search usages of ROM_BANK_SWITCH for that.
0069+  0000             USE_ASCII8_ROM_MAPPER: equ 0
0070+  0000             
0071+  0000             ;The ROM banks where all the code lives.
0072+  0000             ;You will need to change this only if you plan to somehow integrate this
0073+  0000             ;BIOS into a bigger ROM.
0074+  0000             ;Note that these refer to 16K banks, even in the case of using the ASCII8 mapper.
0075+  0000             ROM_BANK_0: equ 0
0076+  0000             ROM_BANK_1: equ 1
0015   0000                 include "usb_errors.asm"
0001+  0000             ; MSXUSB USB FDD BIOS
0002+  0000             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003+  0000             ; This version is adapted to work with the latest version of the MSXUSB project
0004+  0000             ;
0005+  0000             ; USB error codes, these are the ones returned by the
0006+  0000             ; USB routines that are documented as "Output: USB Error code"
0007+  0000             
0008+  0000             
0009+  0000             USB_ERR_OK: equ 0
0010+  0000             USB_ERR_NAK: equ 1
0011+  0000             USB_ERR_STALL: equ 2
0012+  0000             USB_ERR_TIMEOUT: equ 3
0013+  0000             USB_ERR_DATA_ERROR: equ 4
0014+  0000             USB_ERR_NO_DEVICE: equ 5
0015+  0000             USB_ERR_PANIC_BUTTON_PRESSED: equ 6
0016+  0000             USB_ERR_UNEXPECTED_STATUS_FROM_HOST: equ 7
0017+  0000             
0018+  0000             USB_ERR_MAX: equ 7
0019+  0000             
0020+  0000             USB_FILERR_MIN: equ 41h
0021+  0000             
0022+  0000             USB_ERR_OPEN_DIR: equ 41h
0023+  0000             USB_ERR_MISS_FILE: equ 42h
0024+  0000             
0025+  0000             USB_FILERR_MAX: equ 0B4h
0016   0000             
0017   0000             
0018   0000                 ;--- ROM bank 0:
0019   0000                 ;    - MSX-DOS 1 kernel
0020   0000                 ;    - Entry points for MSX-DOS driver functions located in bank 1
0021   0000                 ;    - CALL commands
0022   0000                 ;    - Choice string for FORMAT
0023   0000                 ;    - Default DPB for use by the kernel
0024   0000             
0025   0000                 org 4000h
0026   4000             
0027   4000                 include "bank0/kernel.asm"
0001+  4000             ; MSXUSB USB FDD BIOS
0002+  4000             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003+  4000             ; This version is adapted to work with the latest version of the MSXUSB project
0004+  4000             ;
0005+  4000             ; This is the original MSX-DOS 1 kernel with some patches
0006+  4000             ; to allow for custom SHIFT and CTRL keys behavior,
0007+  4000             ; the patching code is located at the end of the file.
0008+  4000             
0009+  4000             
0010+  4000             ; DOS1.MAC
0011+  4000             
0012+  4000             ; DOS 1.x kernel
0013+  4000             
0014+  4000             ; Source re-created by Z80DIS 2.2
0015+  4000             ; Z80DIS was written by Kenneth Gielow, Palo Alto, CA
0016+  4000             
0017+  4000             ; Code Copyrighted by ASCII and maybe others
0018+  4000             ; Source comments by Arjen Zeilemaker
0019+  4000             
0020+  4000             ; Sourcecode supplied for STUDY ONLY
0021+  4000             ; Recreation NOT permitted without authorisation of the copyrightholders
0022+  4000             
0023+  4000             
0024+  4000             	;ORG	04000H
0025+  4000             
0026+  4000             
0027+  4000             ; symbols which must be defined by the diskdriver
0028+  4000             
0029+  4000             ;	EXTRN	INIHRD
0030+  4000             ;	EXTRN	DRIVES
0031+  4000             ;	EXTRN	INIENV
0032+  4000             ;	EXTRN	DSKIO
0033+  4000             ;	EXTRN	DSKCHG
0034+  4000             ;	EXTRN	GETDPB
0035+  4000             ;	EXTRN	CHOICE
0036+  4000             ;	EXTRN	DSKFMT
0037+  4000             ;	EXTRN	DSKSTP
0038+  4000             ;	EXTRN	OEMSTA
0039+  4000             ;	EXTRN	MYSIZE
0040+  4000             ;	EXTRN	SECLEN
0041+  4000             ;	EXTRN	DEFDPB
0042+  4000             
0043+  4000             ; symbols of routines which can be used by the diskdriver
0044+  4000             
0045+  4000             ;	PUBLIC	PROMPT
0046+  4000             ;	PUBLIC	SETINT
0047+  4000             ;	PUBLIC	PRVINT
0048+  4000             ;	PUBLIC	GETSLT
0049+  4000             ;	PUBLIC	GETWRK
0050+  4000             ;	PUBLIC	DIV16
0051+  4000             ;	PUBLIC	ENASLT
0052+  4000             ;	PUBLIC	XFER
0053+  4000             
0054+  4000             
0055+  4000             WBOOT	equ	00000H
0056+  4000             RDSLT	equ	0000CH
0057+  4000             WRSLT	equ	00014H
0058+  4000             CALSLT	equ	0001CH
0059+  4000             ENASLT	equ	00024H
0060+  4000             IDBYT0	equ	0002BH
0061+  4000             CALLF	equ	00030H
0062+  4000             M0034	equ	00034H
0063+  4000             KEYINT	equ	00038H
0064+  4000             LDIRMV	equ	00059H
0065+  4000             LDIRVM	equ	0005CH
0066+  4000             CHSNS	equ	0009CH
0067+  4000             ;CHGET	equ	0009FH
0068+  4000             ;CHPUT	equ	000A2H
0069+  4000             LPTOUT	equ	000A5H
0070+  4000             ;BREAKX	equ	000B7H
0071+  4000             CKCNTC	equ	000BDH
0072+  4000             ;ERAFNK	equ	000CCH
0073+  4000             TOTEXT	equ	000D2H
0074+  4000             SNSMAT	equ	00141H
0075+  4000             PHYDIO	equ	00144H
0076+  4000             ;KILBUF	equ	00156H
0077+  4000             CALBAS	equ	00159H
0078+  4000             
0079+  4000             X003B	equ	0003BH			; helper routine in DOS memoryspace: save and change secundairy slotregister
0080+  4000             X0046	equ	00046H			; helper routine in DOS memoryspace: restore secundairy slotregister (RDSLT/WRSLT)
0081+  4000             X004B	equ	0004BH			; helper routine in DOS memoryspace: restore secundairy slotregister (CALSLT/CALLF)
0082+  4000             
0083+  4000             XF1C9	equ	0F1C9H			; output string (BDOS 9), also start of fixed diskvars
0084+  4000             XF1D9	equ	0F1D9H			; XFER, transfer to DOS memory
0085+  4000             XF1E2	equ	0F1E2H			; WBOOT, warm boot DOS system
0086+  4000             XF1E8	equ	0F1E8H			; start handler in DOS memory
0087+  4000             XF1F4	equ	0F1F4H			; validate FCB filename
0088+  4000             YF1F7	equ	0F1F7H			; reserved devicenames
0089+  4000             YF20B	equ	0F20BH			; 'direntry' for devices
0090+  4000             YF22B	equ	0F22BH			; days in month table
0091+  4000             YF237	equ	0F237H			; BDOS console output columnpos
0092+  4000             YF238	equ	0F238H			; console columnpos at start of lineinput
0093+  4000             YF239	equ	0F239H			; lineinput insert flag
0094+  4000             YF23A	equ	0F23AH			; lineinput secret message flag
0095+  4000             YF23B	equ	0F23BH			; console output to printer flag
0096+  4000             YF23C	equ	0F23CH			; directory buffer changed flag
0097+  4000             YF23D	equ	0F23DH			; transferaddress
0098+  4000             YF23F	equ	0F23FH			; sectornumber in data buffer
0099+  4000             YF241	equ	0F241H			; driveid of sector in data buffer
0100+  4000             YF242	equ	0F242H			; data buffer changed flag
0101+  4000             YF243	equ	0F243H			; DPB pointer current operation
0102+  4000             YF245	equ	0F245H			; sectornumber (offset) in directory buffer
0103+  4000             YF246	equ	0F246H			; driveid of sector in directory buffer
0104+  4000             YF247	equ	0F247H			; default driveid
0105+  4000             YF248	equ	0F248H			; current day (1..31)
0106+  4000             YF249	equ	0F249H			; current month (1..12)
0107+  4000             YF24A	equ	0F24AH			; current year (offset to 1980)
0108+  4000             YF24C	equ	0F24CH			; current days since 1-1-1980
0109+  4000             YF24E	equ	0F24EH			; current day of week (0=sunday)
0110+  4000             
0111+  4000             XF24F	equ	0F24FH			; prompt for disk hook
0112+  4000             XF252	equ	0F252H			; get fat entry content hook
0113+  4000             XF255	equ	0F255H			; check if devicename hook
0114+  4000             XF258	equ	0F258H			; try next direntry hook
0115+  4000             XF25B	equ	0F25BH			; get next direntry hook
0116+  4000             XF25E	equ	0F25EH			; next direntry hook
0117+  4000             XF261	equ	0F261H			; validate FCB drive and filename hook
0118+  4000             XF264	equ	0F264H			; fcb open hook
0119+  4000             XF267	equ	0F267H			; get latest FAT hook
0120+  4000             XF26A	equ	0F26AH			; get pointer to DPB of current drive hook
0121+  4000             XF26D	equ	0F26DH			; write FAT hook
0122+  4000             XF270	equ	0F270H			; read sector hook
0123+  4000             XF273	equ	0F273H			; diskerror hook
0124+  4000             XF276	equ	0F276H			; write dirsector hook
0125+  4000             XF279	equ	0F279H			; write sector hook
0126+  4000             XF27C	equ	0F27CH			; multiply hook
0127+  4000             XF27F	equ	0F27FH			; divide hook
0128+  4000             XF282	equ	0F282H			; get absolute cluster hook
0129+  4000             XF285	equ	0F285H			; get next absolute cluster hook
0130+  4000             XF288	equ	0F288H			; partical sector read hook
0131+  4000             XF28B	equ	0F28BH			; partical sector write hook
0132+  4000             XF28E	equ	0F28EH			; start read recordoperation from disk hook
0133+  4000             XF291	equ	0F291H			; finish read recordoperation from disk hook
0134+  4000             XF294	equ	0F294H			; end read recordoperation from disk hook
0135+  4000             XF297	equ	0F297H			; record operation error at start hook
0136+  4000             XF29A	equ	0F29AH			; start write recordoperation to disk hook
0137+  4000             XF29D	equ	0F29DH			; finish write recordoperation to disk hook
0138+  4000             XF2A0	equ	0F2A0H			; calculate sequencial sectors hook
0139+  4000             XF2A3	equ	0F2A3H			; get sectornumber of cluster hook
0140+  4000             XF2A6	equ	0F2A6H			; allocate FAT chain hook
0141+  4000             XF2A9	equ	0F2A9H			; release FAT chain hook
0142+  4000             XF2AC	equ	0F2ACH			; lineinput headloop hook
0143+  4000             XF2AF	equ	0F2AFH			; console output hook
0144+  4000             XF2B2	equ	0F2B2H			; get time and date for direntry hook
0145+  4000             XF2B5	equ	0F2B5H			; setup days in februari hook
0146+  4000             
0147+  4000             YF2B8	equ	0F2B8H			; current direntry number
0148+  4000             YF2B9	equ	0F2B9H			; filename1
0149+  4000             YF2C4	equ	0F2C4H			; original DR byte FCB
0150+  4000             YF2C5	equ	0F2C5H			; filename2 (rename)
0151+  4000             YF2D0	equ	0F2D0H			; temporary save for F2B9 and F2C4 (rename)
0152+  4000             YF2DC	equ	0F2DCH			; flag ignore fileattributes
0153+  4000             YF2DD	equ	0F2DDH			; current relative sector in cluster
0154+  4000             YF2DE	equ	0F2DEH			; result of recordoperation
0155+  4000             YF2DF	equ	0F2DFH			; flag increase current relative sector in cluster (0 means not)
0156+  4000             YF2E0	equ	0F2E0H			; flag flake read (0 means real read)
0157+  4000             YF2E1	equ	0F2E1H			; current driveid
0158+  4000             YF2E2	equ	0F2E2H			; transferaddress for recordoperation
0159+  4000             YF2E4	equ	0F2E4H			; start record (32 bit) for recordoperation
0160+  4000             YF2E8	equ	0F2E8H			; number of records for recordoperation
0161+  4000             YF2EA	equ	0F2EAH			; current relative cluster of file
0162+  4000             YF2EC	equ	0F2ECH			; current cluster of file
0163+  4000             YF2EE	equ	0F2EEH			; start relative sector for recordoperation
0164+  4000             YF2F0	equ	0F2F0H			; relative cluster after fileend for write recordoperation
0165+  4000             YF2F2	equ	0F2F2H			; start offset in sector for recordoperation
0166+  4000             YF2F4	equ	0F2F4H			; start fileposition (32 bit) for recordoperation
0167+  4000             YF2F8	equ	0F2F8H			; partical sector transfer at start
0168+  4000             YF2FA	equ	0F2FAH			; partical sector transfer at end
0169+  4000             YF2FC	equ	0F2FCH			; number of complete sectors to transfer
0170+  4000             YF2FE	equ	0F2FEH			; first free direntry (0FFH if none found)
0171+  4000             YF2FF	equ	0F2FFH			; flag diskoperation (0 if read, 1 if write)
0172+  4000             YF300	equ	0F300H			; pointer to remaining lineinput from CON read record operation
0173+  4000             YF302	equ	0F302H			; temporary store for maximium cluster
0174+  4000             					; looks like F304-F305 are unused!
0175+  4000             YF306	equ	0F306H			; flag CP/M compatible BDOS call (0 means no CP/M, HL has value, <>0 means CP/M, HL is compatible filled)
0176+  4000             YF307	equ	0F307H			; saved pointer to FCB search first, used for search next
0177+  4000             YF309	equ	0F309H			; saved pointer to DPB search first, used for search next
0178+  4000             YF30B	equ	0F30BH			; saved current direntry number search first/next (FFh means invalid)
0179+  4000             YF30C	equ	0F30CH			; original EX byte FCB
0180+  4000             RAWFLG	equ	0F30DH			; read after write (verify) flag
0181+  4000             YF30E	equ	0F30EH			; date format (0 japanese, 1 european, 2 american)
0182+  4000             YF30F	equ	0F30FH			; double byte header char table
0183+  4000             					; looks like F313-F322 are unused
0184+  4000             DOSVER: equ 0F313H          ; 0 for DOS 1, <>0 for DOS 2
0185+  4000             YF323	equ	0F323H			; diskerror handler pointer
0186+  4000             YF325	equ	0F325H			; abort handler pointer
0187+  4000             XF327	equ	0F327H			; AUX input hook (MSXHOOK style), default returns CTRL-Z in register A
0188+  4000             XF32C	equ	0F32CH			; AUX output hook (MSXHOOK style), default does nothing
0189+  4000             XF331	equ	0F331H			; BDOS hook (MSXHOOK style)
0190+  4000             YF336	equ	0F336H			; flag saved input available (0 = none available)
0191+  4000             YF337	equ	0F337H			; save input
0192+  4000             YF338	equ	0F338H			; use clockchip flag
0193+  4000             YF339	equ	0F339H			; saved stackpointer format routine
0194+  4000             YF33B	equ	0F33BH			; days since 1-1-1980, used when no clockchip
0195+  4000             YF33D	equ	0F33DH			; recordsize GET/PUT recordoperations
0196+  4000             YF33F	equ	0F33FH			; at systeminit: CTRL key flag, later: saved driveid driveroperation (0=A:)
0197+  4000             YF340	equ	0F340H			; flag kernel cold boot (0 = cold, <>0 = warm)
0198+  4000             RAMAD0	equ	0F341H			; slotid DOS ram page 0
0199+  4000             RAMAD1	equ	0F342H			; slotid DOS ram page 1
0200+  4000             RAMAD2	equ	0F343H			; slotid DOS ram page 2
0201+  4000             RAMAD3	equ	0F344H			; slotid DOS ram page 3
0202+  4000             YF345	equ	0F345H			; maximum number of diskbasic FCB's
0203+  4000             YF346	equ	0F346H			; flag MSXDOS has been running (0 = no MSXDOS yet)
0204+  4000             YF347	equ	0F347H			; number of drives in disksystem
0205+  4000             YF348	equ	0F348H			; slotid disksytem rom
0206+  4000             YF349	equ	0F349H			; disksystem bottom (lowest address used by the disksystem)
0207+  4000             YF34B	equ	0F34BH			; msxdos system bottom
0208+  4000             SECBUF equ	0F34DH			; pointer to sectorbuffer, can be used by the diskdriver
0209+  4000             YF34F	equ	0F34FH			; pointer to datasectorbuffer
0210+  4000             YF351	equ	0F351H			; pointer to directorysectorbuffer
0211+  4000             YF353	equ	0F353H			; pointer to the diskbasic FCB's
0212+  4000             YF355	equ	0F355H			; DPB table for 8 drives
0213+  4000             XF365	equ	0F365H			; routine read primary slotregister
0214+  4000             XF368	equ	0F368H			; routine enable disksystem rom on page 1
0215+  4000             XF36B	equ	0F36BH			; routine enable dos ram on page 1
0216+  4000             XFER	equ	0F36EH			; routine transfer to/from dos ram
0217+  4000             XF371	equ	0F371H			; auxiliary input routine
0218+  4000             XF374	equ	0F374H			; auxiliary output routine
0219+  4000             XF377	equ	0F377H			; routine diskbasic BLOAD
0220+  4000             XF37A	equ	0F37AH			; routine diskbasic BSAVE
0221+  4000             XF37D	equ	0F37DH			; BDOS entry point
0222+  4000             
0223+  4000             RDPRIM	equ	0F380H
0224+  4000             WRPRIM	equ	0F385H
0225+  4000             CLPRIM	equ	0F38CH
0226+  4000             CLPRM1	equ	0F398H
0227+  4000             ;LINLEN	equ	0F3B0H
0228+  4000             ;CNSDFG	equ	0F3DEH
0229+  4000             LPTPOS	equ	0F415H
0230+  4000             PRTFLG	equ	0F416H
0231+  4000             CURLIN	equ	0F41CH
0232+  4000             KBUF	equ	0F41FH
0233+  4000             BUF	equ	0F55EH
0234+  4000             TTYPOS	equ	0F661H
0235+  4000             VALTYP	equ	0F663H
0236+  4000             MEMSIZ	equ	0F672H
0237+  4000             STKTOP	equ	0F674H
0238+  4000             TXTTAB	equ	0F676H
0239+  4000             TEMPPT	equ	0F678H
0240+  4000             TEMPST	equ	0F67AH
0241+  4000             DSCTMP	equ	0F698H
0242+  4000             FRETOP	equ	0F69BH
0243+  4000             AUTLIN	equ	0F6ABH
0244+  4000             SAVSTK	equ	0F6B1H
0245+  4000             VARTAB	equ	0F6C2H
0246+  4000             ;STREND	equ	0F6C6H
0247+  4000             DAC	equ	0F7F6H
0248+  4000             ARG	equ	0F847H
0249+  4000             MAXFIL	equ	0F85FH
0250+  4000             FILTAB	equ	0F860H
0251+  4000             NULBUF	equ	0F862H
0252+  4000             PTRFIL	equ	0F864H
0253+  4000             FILNAM	equ	0F866H
0254+  4000             NLONLY	equ	0F87CH
0255+  4000             SAVEND	equ	0F87DH
0256+  4000             HOKVLD	equ	0FB20H
0257+  4000             YFB21	equ	0FB21H			; diskdriver table
0258+  4000             YFB29	equ	0FB29H			; diskdriver interrupt table
0259+  4000             BOTTOM	equ	0FC48H
0260+  4000             HIMEM	equ	0FC4AH
0261+  4000             FLBMEM	equ	0FCAEH
0262+  4000             RUNBNF	equ	0FCBEH
0263+  4000             SAVENT	equ	0FCBFH
0264+  4000             EXPTBL	equ	0FCC1H
0265+  4000             SLTTBL	equ	0FCC5H
0266+  4000             SLTATR	equ	0FCC9H
0267+  4000             SLTWRK	equ	0FD09H
0268+  4000             PROCNM	equ	0FD89H
0269+  4000             DEVICE	equ	0FD99H
0270+  4000             
0271+  4000             H.TIMI	equ	0FD9FH
0272+  4000             H.DSKO	equ	0FDEFH
0273+  4000             H.NAME	equ	0FDF9H
0274+  4000             H.KILL	equ	0FDFEH
0275+  4000             H.COPY	equ	0FE08H
0276+  4000             H.DSKF	equ	0FE12H
0277+  4000             H.DSKI	equ	0FE17H
0278+  4000             H.LSET	equ	0FE21H
0279+  4000             H.RSET	equ	0FE26H
0280+  4000             H.FIEL	equ	0FE2BH
0281+  4000             H.MKI	equ	0FE30H
0282+  4000             H.MKS	equ	0FE35H
0283+  4000             H.MKD	equ	0FE3AH
0284+  4000             H.CVI	equ	0FE3FH
0285+  4000             H.CVS	equ	0FE44H
0286+  4000             H.CVD	equ	0FE49H
0287+  4000             H.GETP	equ	0FE4EH
0288+  4000             H.NOFO	equ	0FE58H
0289+  4000             H.NULO	equ	0FE5DH
0290+  4000             H.NTFL	equ	0FE62H
0291+  4000             H.BINS	equ	0FE71H
0292+  4000             H.BINL	equ	0FE76H
0293+  4000             H.FILE	equ	0FE7BH
0294+  4000             H.DGET	equ	0FE80H
0295+  4000             H.FILO	equ	0FE85H
0296+  4000             H.INDS	equ	0FE8AH
0297+  4000             H.LOC	equ	0FE99H
0298+  4000             H.LOF	equ	0FE9EH
0299+  4000             H.EOF	equ	0FEA3H
0300+  4000             H.BAKU	equ	0FEADH
0301+  4000             H.PARD	equ	0FEB2H
0302+  4000             H.NODE	equ	0FEB7H
0303+  4000             H.POSD	equ	0FEBCH
0304+  4000             H.RUNC	equ	0FECBH
0305+  4000             H.CLEA	equ	0FED0H
0306+  4000             H.LOPD	equ	0FED5H
0307+  4000             H.STKE	equ	0FEDAH
0308+  4000             H.ERRP	equ	0FEFDH
0309+  4000             H.PHYD	equ	0FFA7H
0310+  4000             H.FORM	equ	0FFACH
0311+  4000             EXTBIO	equ	0FFCAH
0312+  4000             DISINT	equ	0FFCFH
0313+  4000             ENAINT	equ	0FFD4H
0314+  4000             
0315+  4000             YFFFF	equ	0FFFFH
0316+  4000             
0317+  4000             
0318+  4000             YC000	equ	0C000H		; bootsector transferaddress
0319+  4000             YCONBF	equ	KBUF+186	; KBUF is reused for read CON device records, size 127+2
0320+  4000             YCONTP	equ	KBUF+58		; KBUF is reused for temporary buffer buffered input, size 128
0321+  4000             
0322+  4000             
0323+  4000             ; Basic routines
0324+  4000             
0325+  4000             M268C	equ	0268CH		; dbl subtract
0326+  4000             M269A	equ	0269AH		; dbl add
0327+  4000             M289F	equ	0289FH		; dbl divide
0328+  4000             M2EF3	equ	02EF3H		; copy variable content
0329+  4000             M2F08	equ	02F08H		; copy variable content to DAC
0330+  4000             M2F10	equ	02F10H		; copy variable content from DAC
0331+  4000             M2F99	equ	02F99H		; integer to DAC
0332+  4000             M3042	equ	03042H		; convert DAC from sgn to dbl
0333+  4000             M30D1	equ	030D1H		; dbl to integer
0334+  4000             M325C	equ	0325CH		; sgn multiply
0335+  4000             M3FD6	equ	03FD6H		; empty string
0336+  4000             M406F	equ	0406FH		; BASIC error
0337+  4000             M409B	equ	0409BH		; restart BASIC
0338+  4000             M4173	equ	04173H		; execute statement
0339+  4000             M4253	equ	04253H		; recalculate linepointers
0340+  4000             M4601	equ	04601H		; execution loop
0341+  4000             M4666	equ	04666H		; CHRGTR
0342+  4000             M46FF	equ	046FFH		; convert to SNG
0343+  4000             M4756	equ	04756H		; evaluate word operand and check for 0-32767 range
0344+  4000             M4AFF	equ	04AFFH		; output back to screen
0345+  4000             M4C5F	equ	04C5FH		; evaluate =expression
0346+  4000             M4C64	equ	04C64H		; evaluate expression
0347+  4000             M517A	equ	0517AH		; convert DAC to other type
0348+  4000             M521B	equ	0521BH		; evaluate next byte operand
0349+  4000             M521C	equ	0521CH		; evaluate byte operand
0350+  4000             M521F	equ	0521FH		; convert to byte
0351+  4000             M542F	equ	0542FH		; evaluate address operand
0352+  4000             M5432	equ	05432H		; convert address to integer
0353+  4000             M54F7	equ	054F7H		; convert pointers to linenumbers
0354+  4000             M5597	equ	05597H		; GETYPR
0355+  4000             M5EA4	equ	05EA4H		; get address of variable
0356+  4000             M6627	equ	06627H		; allocate temp string
0357+  4000             M668E	equ	0668EH		; allocate stringspace
0358+  4000             M67D0	equ	067D0H		; free temporary string
0359+  4000             M6A0E	equ	06A0EH		; evaluate filespecification
0360+  4000             M6A6D	equ	06A6DH		; get i/o channel pointer
0361+  4000             M6AFA	equ	06AFAH		; open i/o channel
0362+  4000             M6B24	equ	06B24H		; close i/o channel
0363+  4000             M6C1C	equ	06C1CH		; close all i/o channels
0364+  4000             M6E41	equ	06E41H		; resume character putback routine
0365+  4000             M6E92	equ	06E92H		; start of BSAVE routine
0366+  4000             M6EC6	equ	06EC6H		; start of BLOAD routine
0367+  4000             M6EF4	equ	06EF4H		; finish BLOAD
0368+  4000             M6F0B	equ	06F0BH		; evaluate address operand (BLOAD/SAVE)
0369+  4000             M6F1D	equ	06F1DH		; skip strong cassette devicecheck
0370+  4000             M7323	equ	07323H		; newline to OUTDO if not at start of line
0371+  4000             M7328	equ	07328H		; newline to OUTDO
0372+  4000             M739A	equ	0739AH		; quit loading & start (headloop/executing)
0373+  4000             M7D17	equ	07D17H		; continue start of MSX-BASIC without executing BASIC programs in ROM
0374+  4000             M7D2F	equ	07D2FH		; address initialize BASIC screen
0375+  4000             M7D31	equ	07D31H		; BASIC initscreen (without INITXT & CNSDFG)
0376+  4000             M7E14	equ	07E14H		; start MSX-BASIC program in ROM
0377+  4000             
0378+  4000             RETRTN	equ	WRPRIM+6	; address with a RET instruction, allways available
0379+  4000             
0380+  4000             
0381+  4000             ; FCB structure
0382+  4000             
0383+  4000             ; off	name	cp/m function		msx function
0384+  4000             
0385+  4000             ; +0	DR	drive			drive
0386+  4000             ; +1,8	F1-F8	filename		filename
0387+  4000             ; +9,3	T1-T3	filetype		filetype
0388+  4000             ; +12	EX	extent			extent
0389+  4000             ; +13	S1	reserved		fileattribute
0390+  4000             ; +14	S2	reserved		extent high byte / recordsize low byte (block)
0391+  4000             ; +15	RC	record count in extent	record count in extent / recordsize high byte (block)
0392+  4000             ; +16	AL	allocation		Filesize
0393+  4000             ; +20	AL	allocation		Date
0394+  4000             ; +22	AL	allocation		Time
0395+  4000             ; +24	AL	allocation		Devicecode
0396+  4000             ; +25	AL	allocation		Directoryentry Number
0397+  4000             ; +26	AL	allocation		Start Cluster
0398+  4000             ; +28	AL	allocation		Current Cluster
0399+  4000             ; +30	AL	allocation		Current Relative Cluster
0400+  4000             ; +32	CR	record in extent	record in extent
0401+  4000             ; +33,3	R0-R2	random access record	random access record
0402+  4000             ; +36	R3	not used		random access record when recordsize <64
0403+  4000             
0404+  4000             
0405+  4000             
0406+  4000 41 42       	defb	"AB"
0407+  4002 6F 57       	defw	A576F
0408+  4004 76 65       	defw	A6576
0409+  4006 00 00       	defw	0
0410+  4008 00 00       	defw	0
0411+  400A 00          	defs	6
0412+  4010             
0413+  4010             ; diskdriver entries
0414+  4010             
0415+  4010 C3 8C 74    T4010:	jp	DSKIO			; DSKIO entrypoint
0416+  4013 C3 97 74    T4013:	jp	DSKCHG			; DSKCHG entrypoint
0417+  4016 C3 A2 74    T4016:	jp	GETDPB			; GETDPB entrypoint
0418+  4019 C3 AD 74    T4019:	jp	CHOICE			; CHOICE entrypoint
0419+  401C C3 B8 74    T401C:	jp	DSKFMT			; DSKFMT entrypoint
0420+  401F C9          T401F:	ret                 ; DSKSTP entrypoint
0421+  4020 C9                  ret
0422+  4021 C9                  ret
0423+  4022             
0424+  4022             ; kernel entries
0425+  4022             
0426+  4022 C3 3A 5B    A4022:	jp	A5B3A			; start DiskBasic entrypoint
0427+  4025 37          A4025:	scf				; format disk entrypoint (workarea must be supplied)
0428+  4026 C3 B1 60    	jp	A60B1
0429+  4029 C3 0D 62    A4029:	jp	A620D			; stop all disks entry point
0430+  402C             
0431+  402C             ; Unused code ??
0432+  402C             
0433+  402C 00          	nop
0434+  402D             
0435+  402D             GETSLT:
0436+  402D C3 B3 5F    A402D:	jp	A5FB3			; get slotid entrypoint
0437+  4030             
0438+  4030             ;	Subroutine	get MSX-DOS system bottom
0439+  4030             ;	Inputs		-
0440+  4030             ;	Outputs		HL = lowest address used by the base MSX-DOS system
0441+  4030             
0442+  4030 2A 4B F3    A4030:	ld	hl,(YF34B)
0443+  4033 C9          	ret
0444+  4034             
0445+  4034             ;	Subroutine	check if keyboardinput available
0446+  4034             ;	Inputs		-
0447+  4034             ;	Outputs		Zx set if no input, Zx reset if input, A = input
0448+  4034             
0449+  4034 DD E5       A4034:	push	ix
0450+  4036 DD 21 B7 00 	ld	ix,BREAKX
0451+  403A CD AB 40    	call	A40AB			; BREAKX BIOS call
0452+  403D DD E1       	pop	ix			; CTRL-STOP pressed ?
0453+  403F 30 0A       	jr	nc,A404B		; nope,
0454+  4041 3E 03       	ld	a,003H
0455+  4043 32 36 F3    	ld	(YF336),a		; saved input available
0456+  4046 32 37 F3    	ld	(YF337),a		; CTRL-C
0457+  4049 A7          	and	a			; flag NZ
0458+  404A C9          	ret
0459+  404B             
0460+  404B 3A 36 F3    A404B:	ld	a,(YF336)
0461+  404E A7          	and	a			; saved input available ?
0462+  404F 3A 37 F3    	ld	a,(YF337)
0463+  4052 C0          	ret	nz			; yep, return it (flag NZ)
0464+  4053 DD E5       	push	ix
0465+  4055 DD 21 9C 00 	ld	ix,CHSNS
0466+  4059 CD AB 40    	call	A40AB			; CHSNS BIOS call
0467+  405C DD E1       	pop	ix			; any chars in the keyboard buffer ?
0468+  405E C8          	ret	z			; nope, quit (flag Z)
0469+  405F 3E FF       	ld	a,0FFH
0470+  4061 32 36 F3    	ld	(YF336),a		; flag saved input available
0471+  4064 DD E5       	push	ix
0472+  4066 DD 21 9F 00 	ld	ix,CHGET
0473+  406A CD AB 40    	call	A40AB			; CHGET BIOS call
0474+  406D DD E1       	pop	ix			; get char from keyboard buffer
0475+  406F 32 37 F3    	ld	(YF337),a		; save char
0476+  4072 C5          	push	bc
0477+  4073 06 00       	ld	b,000H
0478+  4075 04          	inc	b
0479+  4076 C1          	pop	bc			; flag NZ
0480+  4077 C9          	ret
0481+  4078             
0482+  4078             ;	Subroutine	get keyboardinput
0483+  4078             ;	Inputs		-
0484+  4078             ;	Outputs		A = input
0485+  4078             
0486+  4078 E5          A4078:	push	hl
0487+  4079 21 36 F3    	ld	hl,YF336
0488+  407C AF          	xor	a
0489+  407D BE          	cp	(hl)			; saved input available ?
0490+  407E 77          	ld	(hl),a			; not anymore!
0491+  407F 23          	inc	hl
0492+  4080 7E          	ld	a,(hl)
0493+  4081 E1          	pop	hl
0494+  4082 C0          	ret	nz			; yep, return it
0495+  4083 DD E5       	push	ix
0496+  4085 DD 21 9F 00 	ld	ix,CHGET
0497+  4089 CD AB 40    	call	A40AB			; CHGET BIOS call
0498+  408C DD E1       	pop	ix			; get char
0499+  408E C9          	ret
0500+  408F             
0501+  408F             ;	Subroutine	output to screen
0502+  408F             ;	Inputs		A = output
0503+  408F             ;	Outputs		-
0504+  408F             
0505+  408F DD E5       A408F:	push	ix
0506+  4091 DD 21 A2 00 	ld	ix,CHPUT
0507+  4095 CD AB 40    	call	A40AB			; CHPUT BIOS call
0508+  4098 DD E1       	pop	ix
0509+  409A C9          	ret
0510+  409B             
0511+  409B             ;	Subroutine	output to printer
0512+  409B             ;	Inputs		A = output
0513+  409B             ;	Outputs		-
0514+  409B             
0515+  409B DD E5       A409B:	push	ix
0516+  409D DD 21 A5 00 	ld	ix,LPTOUT
0517+  40A1 CD AB 40    	call	A40AB			; LPTOUT BIOS call
0518+  40A4 DD E1       	pop	ix
0519+  40A6 C9          	ret
0520+  40A7             
0521+  40A7             ;	Subroutine	BDOS 00 (system reset)
0522+  40A7             ;	Inputs		
0523+  40A7             ;	Outputs		________________________
0524+  40A7             
0525+  40A7             
0526+  40A7 DD 21 9B 40 A40A7:	ld	ix,M409B		; restart BASIC
0527+  40AB             
0528+  40AB             ;	Subroutine	MSX-BIOS call
0529+  40AB             ;	Inputs		IX = bios call, others depends on the bios call
0530+  40AB             ;	Outputs		depends on the bios call
0531+  40AB             
0532+  40AB FD E5       A40AB:	push	iy
0533+  40AD FD 2A C0 FC 	ld	iy,(EXPTBL-1+0)
0534+  40B1 CD 1C 00    	call	CALSLT
0535+  40B4 FB          	ei
0536+  40B5 FD E1       	pop	iy
0537+  40B7 C9          	ret
0538+  40B8             
0539+  40B8             ;	Subroutine	check for and initialize clockchip
0540+  40B8             ;	Inputs		-
0541+  40B8             ;	Outputs		-
0542+  40B8             
0543+  40B8 3E 0D       A40B8:	ld	a,13
0544+  40BA D3 B4       	out	(0B4H),a
0545+  40BC 3E 0A       	ld	a,00AH
0546+  40BE D3 B5       	out	(0B5H),a		; alarm off, clock running, bank 2
0547+  40C0 AF          	xor	a
0548+  40C1 D3 B4       	out	(0B4H),a		; pos 0
0549+  40C3 06 0F       	ld	b,00FH
0550+  40C5 DB B5       A40C5:	in	a,(0B5H)		; read data
0551+  40C7 E6 0F       	and	00FH
0552+  40C9 A8          	xor	b
0553+  40CA D3 B5       	out	(0B5H),a		; change it and write back
0554+  40CC 4F          	ld	c,a
0555+  40CD 00          	nop				; wait or patched code ??
0556+  40CE DB B5       	in	a,(0B5H)
0557+  40D0 E6 0F       	and	00FH
0558+  40D2 B9          	cp	c			; correctly readback ?
0559+  40D3 C0          	ret	nz			; nope, no clockchip!
0560+  40D4 A8          	xor	b
0561+  40D5 D3 B5       	out	(0B5H),a		; restore orginal data
0562+  40D7 10 EC       	djnz	A40C5			; try all values
0563+  40D9 3E FF       	ld	a,0FFH
0564+  40DB 32 38 F3    	ld	(YF338),a		; flag use clockchip
0565+  40DE 3E 0D       	ld	a,13
0566+  40E0 D3 B4       	out	(0B4H),a
0567+  40E2 3E 09       	ld	a,009H
0568+  40E4 D3 B5       	out	(0B5H),a		; alarm off, clock running, bank 1
0569+  40E6 3E 0A       	ld	a,10
0570+  40E8 D3 B4       	out	(0B4H),a		; pos 10
0571+  40EA 3E 01       	ld	a,1
0572+  40EC D3 B5       	out	(0B5H),a		; 24 hour system
0573+  40EE 3E 0D       	ld	a,13
0574+  40F0 D3 B4       	out	(0B4H),a
0575+  40F2 AF          	xor	a
0576+  40F3 D3 B5       	out	(0B5H),a		; alarm off, clock paused, bank 0
0577+  40F5 01 00 0D    	ld	bc,00D00H
0578+  40F8 79          A40F8:	ld	a,c
0579+  40F9 D3 B4       	out	(0B4H),a
0580+  40FB DB B5       	in	a,(0B5H)
0581+  40FD F5          	push	af
0582+  40FE 0C          	inc	c
0583+  40FF 10 F7       	djnz	A40F8			; save time registers
0584+  4101 3E 0E       	ld	a,14
0585+  4103 D3 B4       	out	(0B4H),a
0586+  4105 AF          	xor	a
0587+  4106 D3 B5       	out	(0B5H),a		; clear testbits
0588+  4108 06 0D       	ld	b,00DH
0589+  410A 0D          A410A:	dec	c
0590+  410B 79          	ld	a,c
0591+  410C D3 B4       	out	(0B4H),a
0592+  410E F1          	pop	af
0593+  410F D3 B5       	out	(0B5H),a
0594+  4111 10 F7       	djnz	A410A			; restore time registers
0595+  4113 18 39       	jr	A414E			; put clock in running mode
0596+  4115             
0597+  4115             ;	Subroutine	store date
0598+  4115             ;	Inputs		
0599+  4115             ;	Outputs		-
0600+  4115             
0601+  4115 22 3B F3    A4115:	ld	(YF33B),hl
0602+  4118 3A 38 F3    	ld	a,(YF338)
0603+  411B A7          	and	a			; use clockchip ?
0604+  411C C8          	ret	z			; no, quit
0605+  411D 3A 4A F2    	ld	a,(YF24A)
0606+  4120 47          	ld	b,a
0607+  4121 3A 49 F2    	ld	a,(YF249)
0608+  4124 4F          	ld	c,a
0609+  4125 3A 48 F2    	ld	a,(YF248)
0610+  4128 57          	ld	d,a			; current day
0611+  4129 1E 07       	ld	e,007H			; nibble 7 (date)
0612+  412B CD 59 41    	call	A4159			; pause clock, select bank 0
0613+  412E 18 12       	jr	A4142
0614+  4130             
0615+  4130             ;	Subroutine	store time
0616+  4130             ;	Inputs		
0617+  4130             ;	Outputs		-
0618+  4130             
0619+  4130 3A 38 F3    A4130:	ld	a,(YF338)
0620+  4133 A7          	and	a			; use clockchip ?
0621+  4134 C8          	ret	z			; no, quit
0622+  4135 1E 00       	ld	e,000H			; nibble 0 (time)
0623+  4137 CD 59 41    	call	A4159			; pause clock, select bank 0
0624+  413A 3E 0F       	ld	a,00FH
0625+  413C D3 B4       	out	(0B4H),a
0626+  413E 3E 02       	ld	a,002H
0627+  4140 D3 B5       	out	(0B5H),a		; time reset
0628+  4142 62          A4142:	ld	h,d
0629+  4143 CD 60 41    	call	A4160			; write clockchip byte
0630+  4146 61          	ld	h,c
0631+  4147 CD 60 41    	call	A4160			; write clockchip byte
0632+  414A 60          	ld	h,b
0633+  414B CD 60 41    	call	A4160			; write clockchip byte
0634+  414E             
0635+  414E             ;	Subroutine	put clockchip in running mode
0636+  414E             ;	Inputs		-
0637+  414E             ;	Outputs		-
0638+  414E             
0639+  414E 3E 0D       A414E:	ld	a,13
0640+  4150 D3 B4       	out	(0B4H),a
0641+  4152 DB B5       	in	a,(0B5H)
0642+  4154 F6 08       	or	008H
0643+  4156 D3 B5       A4156:	out	(0B5H),a
0644+  4158 C9          	ret
0645+  4159             
0646+  4159             ;	Subroutine	pause clockchip and select bank 0
0647+  4159             ;	Inputs		-
0648+  4159             ;	Outputs		-
0649+  4159             
0650+  4159 CD 4E 41    A4159:	call	A414E			; clock in running mode
0651+  415C E6 04       	and	004H
0652+  415E 18 F6       	jr	A4156			; clock paused, select bank 0
0653+  4160             
0654+  4160             ;	Subroutine	write byte to clockchip
0655+  4160             ;	Inputs		H = data, E = nibblenumber
0656+  4160             ;	Outputs		E = updated nibblenumber (+2)
0657+  4160             
0658+  4160 AF          A4160:	xor	a
0659+  4161 2E 08       	ld	l,8
0660+  4163 CB 04       A4163:	rlc	h
0661+  4165 8F          	adc	a,a
0662+  4166 27          	daa
0663+  4167 2D          	dec	l
0664+  4168 20 F9       	jr	nz,A4163		; convert to BCD
0665+  416A CD 71 41    	call	A4171
0666+  416D 0F          	rrca
0667+  416E 0F          	rrca
0668+  416F 0F          	rrca
0669+  4170 0F          	rrca
0670+  4171 F5          A4171:	push	af
0671+  4172 7B          	ld	a,e
0672+  4173 1C          	inc	e
0673+  4174 D3 B4       	out	(0B4H),a
0674+  4176 F1          	pop	af
0675+  4177 18 DD       	jr	A4156
0676+  4179             
0677+  4179             ;	Subroutine	get date and time
0678+  4179             ;	Inputs		
0679+  4179             ;	Outputs		Cx set if from clockchip,
0680+  4179             
0681+  4179 3A 38 F3    A4179:	ld	a,(YF338)
0682+  417C A7          	and	a			; use clockchip ?
0683+  417D 47          	ld	b,a
0684+  417E 4F          	ld	c,a
0685+  417F 57          	ld	d,a
0686+  4180 5F          	ld	e,a			; 00:00:00
0687+  4181 2A 3B F3    	ld	hl,(YF33B)		; days since 1-1-1980
0688+  4184 C8          	ret	z			; no clockchip, quit
0689+  4185 CD 59 41    	call	A4159			; clock paused, select bank 0
0690+  4188 1E 0D       	ld	e,12+1
0691+  418A CD AD 41    	call	A41AD			; read byte from clockchip
0692+  418D CD 23 55    	call	A5523			; setup days in februari
0693+  4190 CD AD 41    	call	A41AD			; read byte from clockchip
0694+  4193 32 49 F2    	ld	(YF249),a		; current month
0695+  4196 CD AD 41    	call	A41AD			; read byte from clockchip
0696+  4199 32 48 F2    	ld	(YF248),a		; current day
0697+  419C 1D          	dec	e			; nibble 5
0698+  419D CD AD 41    	call	A41AD			; read byte from clockchip
0699+  41A0 47          	ld	b,a
0700+  41A1 CD AD 41    	call	A41AD			; read byte from clockchip
0701+  41A4 4F          	ld	c,a
0702+  41A5 CD AD 41    	call	A41AD			; read byte from clockchip
0703+  41A8 CD 4E 41    	call	A414E			; clock in running mode
0704+  41AB 37          	scf
0705+  41AC C9          	ret
0706+  41AD             
0707+  41AD             ;	Subroutine	read byte from clockchip
0708+  41AD             ;	Inputs		E = nibblenumber+1
0709+  41AD             ;	Outputs		E = updated nibblenumber (-2), A = data
0710+  41AD             
0711+  41AD AF          A41AD:	xor	a
0712+  41AE CD B5 41    	call	A41B5
0713+  41B1 87          	add	a,a
0714+  41B2 87          	add	a,a
0715+  41B3 82          	add	a,d
0716+  41B4 87          	add	a,a
0717+  41B5 57          A41B5:	ld	d,a
0718+  41B6 1D          	dec	e
0719+  41B7 7B          	ld	a,e
0720+  41B8 D3 B4       	out	(0B4H),a
0721+  41BA DB B5       	in	a,(0B5H)
0722+  41BC E6 0F       	and	00FH
0723+  41BE 82          	add	a,d
0724+  41BF 57          	ld	d,a
0725+  41C0 C9          	ret
0726+  41C1             
0727+  41C1             ; Identification string (not used)
0728+  41C1             
0729+  41C1             U41C1:	defb	" MSX-DOS ver. 2.2 Copyright 1984 by Microsoft "
0729+  41C1 204D53582D444F53207665722E20322E3220436F707972696768742031393834
0729+  41E1 206279204D6963726F736F667420
0730+  41EF             
0731+  41EF             ;	Subroutine	BDOS 0C (return version number)
0732+  41EF             ;	Inputs		
0733+  41EF             ;	Outputs		________________________
0734+  41EF             
0735+  41EF             
0736+  41EF 06 00       A41EF:	ld	b,000H			; machinetype 8080, plain CP/M
0737+  41F1 3E 22       	ld	a,022H			; CP/M version 2.2
0738+  41F3 C9          	ret
0739+  41F4             
0740+  41F4             ;	Subroutine	get FAT entry content
0741+  41F4             ;	Inputs		HL = clusternumber, IX = pointer to DPB
0742+  41F4             ;	Outputs		HL = clusterentry content, Zx set if entry is free, DE = pointer to FAT buffer
0743+  41F4             
0744+  41F4 DD 5E 13    A41F4:	ld	e,(ix+19)
0745+  41F7 DD 56 14    	ld	d,(ix+20)		; pointer to FAT buffer of drive
0746+  41FA CD 52 F2    A41FA:	call	XF252
0747+  41FD D5          	push	de
0748+  41FE 5D          	ld	e,l
0749+  41FF 54          	ld	d,h
0750+  4200 CB 3C       	srl	h
0751+  4202 CB 1D       	rr	l
0752+  4204 1F          	rra
0753+  4205 19          	add	hl,de
0754+  4206 D1          	pop	de
0755+  4207 19          	add	hl,de
0756+  4208 17          	rla
0757+  4209 7E          	ld	a,(hl)
0758+  420A 23          	inc	hl
0759+  420B 66          	ld	h,(hl)
0760+  420C 30 0C       	jr	nc,A421A
0761+  420E CB 3C       	srl	h
0762+  4210 1F          	rra
0763+  4211 CB 3C       	srl	h
0764+  4213 1F          	rra
0765+  4214 CB 3C       	srl	h
0766+  4216 1F          	rra
0767+  4217 CB 3C       	srl	h
0768+  4219 1F          	rra
0769+  421A 6F          A421A:	ld	l,a
0770+  421B 7C          	ld	a,h
0771+  421C E6 0F       	and	00FH
0772+  421E 67          	ld	h,a
0773+  421F B5          	or	l
0774+  4220 C9          	ret
0775+  4221             
0776+  4221             ;	Subroutine	set FAT entry content
0777+  4221             ;	Inputs		HL = clusternumber, DE = pointer to FAT buffer, BC = clusterentry content
0778+  4221             ;	Outputs		-
0779+  4221             
0780+  4221 D5          A4221:	push	de
0781+  4222 5D          	ld	e,l
0782+  4223 54          	ld	d,h
0783+  4224 CB 3C       	srl	h
0784+  4226 CB 1D       	rr	l
0785+  4228 1F          	rra
0786+  4229 19          	add	hl,de
0787+  422A D1          	pop	de
0788+  422B 19          	add	hl,de
0789+  422C 17          	rla
0790+  422D 30 18       	jr	nc,A4247
0791+  422F CB 21       	sla	c
0792+  4231 CB 10       	rl	b
0793+  4233 CB 21       	sla	c
0794+  4235 CB 10       	rl	b
0795+  4237 CB 21       	sla	c
0796+  4239 CB 10       	rl	b
0797+  423B CB 21       	sla	c
0798+  423D CB 10       	rl	b
0799+  423F 7E          	ld	a,(hl)
0800+  4240 E6 0F       	and	00FH
0801+  4242 B1          	or	c
0802+  4243 77          	ld	(hl),a
0803+  4244 23          	inc	hl
0804+  4245 70          	ld	(hl),b
0805+  4246 C9          	ret
0806+  4247             
0807+  4247 71          A4247:	ld	(hl),c
0808+  4248 23          	inc	hl
0809+  4249 7E          	ld	a,(hl)
0810+  424A E6 F0       	and	0F0H
0811+  424C B0          	or	b
0812+  424D 77          	ld	(hl),a
0813+  424E C9          	ret
0814+  424F             
0815+  424F             ;	Subroutine	compare with filename1
0816+  424F             ;	Inputs		HL = pointer to buffer, B = size
0817+  424F             ;	Outputs		Zx set if equal
0818+  424F             
0819+  424F 11 B9 F2    A424F:	ld	de,YF2B9
0820+  4252             
0821+  4252             ;	Subroutine	compare
0822+  4252             ;	Inputs		DE = pointer to buffer1, HL = pointer to buffer2, B = size
0823+  4252             ;	Outputs		Zx set if equal
0824+  4252             
0825+  4252 1A          A4252:	ld	a,(de)
0826+  4253 BE          	cp	(hl)
0827+  4254 23          	inc	hl
0828+  4255 13          	inc	de
0829+  4256 C0          	ret	nz
0830+  4257 10 F9       	djnz	A4252
0831+  4259 C9          	ret
0832+  425A             
0833+  425A             ;	Subroutine	check if devicename
0834+  425A             ;	Inputs		
0835+  425A             ;	Outputs		________________________
0836+  425A             
0837+  425A CD 55 F2    A425A:	call	XF255
0838+  425D 21 F7 F1    	ld	hl,YF1F7		; table with devicenames
0839+  4260 0E 05       	ld	c,5			; 5 devices
0840+  4262 06 04       A4262:	ld	b,4			; only check 4 bytes (because devicenames are only 4 chars long)
0841+  4264 CD 4F 42    	call	A424F			; compare with filename1
0842+  4267 20 2F       	jr	nz,A4298		; not this device, try the next
0843+  4269 06 04       	ld	b,4
0844+  426B 1A          A426B:	ld	a,(de)
0845+  426C 13          	inc	de
0846+  426D FE 20       	cp	" "
0847+  426F 20 32       	jr	nz,A42A3		; last 4 bytes of filename not spaces, not a device
0848+  4271 10 F8       	djnz	A426B
0849+  4273 79          	ld	a,c
0850+  4274 ED 44       	neg
0851+  4276 32 16 F2    	ld	(YF20B+11),a		; devicecode
0852+  4279 21 B9 F2    	ld	hl,YF2B9
0853+  427C 11 0B F2    	ld	de,YF20B
0854+  427F 01 04 00    	ld	bc,4
0855+  4282 ED B0       	ldir				; copy of devicename
0856+  4284 CD 96 54    	call	A5496			; get time and date (dirformat)
0857+  4287 ED 43 23 F2 	ld	(YF20B+24),bc
0858+  428B ED 53 21 F2 	ld	(YF20B+22),de
0859+  428F 21 0B F2    	ld	hl,YF20B
0860+  4292 E5          	push	hl
0861+  4293 FD E1       	pop	iy
0862+  4295 F6 01       	or	001H			; Cx reset, Zx reset
0863+  4297 C9          	ret
0864+  4298             
0865+  4298 05          A4298:	dec	b
0866+  4299 7D          	ld	a,l
0867+  429A 80          	add	a,b
0868+  429B 6F          	ld	l,a
0869+  429C 7C          	ld	a,h
0870+  429D CE 00       	adc	a,000H
0871+  429F 67          	ld	h,a
0872+  42A0 0D          	dec	c
0873+  42A1 20 BF       	jr	nz,A4262
0874+  42A3             					; Zx set
0875+  42A3 37          A42A3:	scf
0876+  42A4 C9          	ret
0877+  42A5             
0878+  42A5             ;	Subroutine	validate FCB, clear S2 and find direntry
0879+  42A5             ;	Inputs		
0880+  42A5             ;	Outputs		________________________
0881+  42A5             
0882+  42A5             
0883+  42A5 D5          A42A5:	push	de
0884+  42A6 21 0E 00    	ld	hl,14
0885+  42A9 19          	add	hl,de
0886+  42AA 36 00       	ld	(hl),0			; FCB S2 (extent high byte)
0887+  42AC CD B1 42    	call	A42B1			; validate FCB drive and filename and find direntry
0888+  42AF D1          	pop	de
0889+  42B0 C9          	ret
0890+  42B1             
0891+  42B1 CD 0E 44    A42B1:	call	A440E			; validate FCB drive and filename
0892+  42B4 D8          	ret	c			; invalid, quit
0893+  42B5             
0894+  42B5             ;	Subroutine	find first directoryentry
0895+  42B5             ;	Inputs		
0896+  42B5             ;	Outputs		________________________
0897+  42B5             
0898+  42B5             
0899+  42B5 CD 5A 42    A42B5:	call	A425A			; check if devicename
0900+  42B8 D0          	ret	nc			; yep, quit with pointer to fake device direntry
0901+  42B9 CD D3 44    	call	A44D3			; reset direntry search and get latest FAT
0902+  42BC             
0903+  42BC             ;	Subroutine	find next directoryentry
0904+  42BC             ;	Inputs		
0905+  42BC             ;	Outputs		________________________
0906+  42BC             
0907+  42BC CD 58 F2    A42BC:	call	XF258
0908+  42BF CD 0E 43    	call	A430E			; get next direntry
0909+  42C2 D8          	ret	c			; no more, quit
0910+  42C3 7E          A42C3:	ld	a,(hl)
0911+  42C4 B7          	or	a
0912+  42C5 28 35       	jr	z,A42FC			; unused entry,
0913+  42C7 FE E5       	cp	0E5H
0914+  42C9 28 31       	jr	z,A42FC			; deleted entry,
0915+  42CB E5          	push	hl
0916+  42CC 06 0B       	ld	b,11
0917+  42CE 11 B9 F2    	ld	de,YF2B9
0918+  42D1 CD 52 42    A42D1:	call	A4252			; compare with fcb filename
0919+  42D4 28 06       	jr	z,A42DC			; equal, found!
0920+  42D6 FE 3F       	cp	"?"
0921+  42D8 20 1B       	jr	nz,A42F5		; on difference no wildcard, try next
0922+  42DA 10 F5       	djnz	A42D1			; wildcard pos ignored, check rest
0923+  42DC E1          A42DC:	pop	hl
0924+  42DD E5          	push	hl
0925+  42DE FD E1       	pop	iy
0926+  42E0 3A C4 F2    	ld	a,(YF2C4)
0927+  42E3 EE 80       	xor	080H
0928+  42E5 CB 7F       	bit	7,a
0929+  42E7 C8          	ret	z			; orginal FCB DR byte had b7 set, ignore direntryattribute
0930+  42E8 FD 7E 0B    	ld	a,(iy+11)
0931+  42EB E6 1E       	and	01EH
0932+  42ED C8          	ret	z			; files with archive or read-only bit set are ok, quit
0933+  42EE 3A DC F2    	ld	a,(YF2DC)
0934+  42F1 B7          	or	a			; include special fileattribute flag set ?
0935+  42F2 C0          	ret	nz			; yep, every direntry is ok, quit
0936+  42F3 18 01       	jr	A42F6
0937+  42F5             
0938+  42F5 E1          A42F5:	pop	hl
0939+  42F6 CD 48 43    A42F6:	call	A4348			; get next direntry (while searching)
0940+  42F9 30 C8       	jr	nc,A42C3		; ok, check it
0941+  42FB C9          	ret
0942+  42FC             
0943+  42FC 3A FE F2    A42FC:	ld	a,(YF2FE)
0944+  42FF 3C          	inc	a			; already found a free direntry ?
0945+  4300 20 06       	jr	nz,A4308
0946+  4302 3A B8 F2    	ld	a,(YF2B8)
0947+  4305 32 FE F2    	ld	(YF2FE),a		; nope, register it
0948+  4308 7E          A4308:	ld	a,(hl)
0949+  4309 B7          	or	a			; unused direntry ?
0950+  430A 20 EA       	jr	nz,A42F6		; nope, the search goes on!
0951+  430C 37          	scf
0952+  430D C9          	ret
0953+  430E             
0954+  430E             ;	Subroutine	get next direntry (at start of search)
0955+  430E             ;	Inputs		
0956+  430E             ;	Outputs		________________________
0957+  430E             
0958+  430E 3A B8 F2    A430E:	ld	a,(YF2B8)
0959+  4311 3C          	inc	a
0960+  4312 DD BE 0B    	cp	(ix+11)			; last direntry ?
0961+  4315 30 50       	jr	nc,A4367		; yep, update directory of disk when needed and quit
0962+  4317             
0963+  4317             ;	Subroutine	get direntry
0964+  4317             ;	Inputs		
0965+  4317             ;	Outputs		________________________
0966+  4317             
0967+  4317 CD 5B F2    A4317:	call	XF25B
0968+  431A 32 B8 F2    	ld	(YF2B8),a
0969+  431D 4F          	ld	c,a
0970+  431E DD A6 04    	and	(ix+4)			; dirmask
0971+  4321 6F          	ld	l,a
0972+  4322 26 00       	ld	h,0
0973+  4324 29          	add	hl,hl
0974+  4325 29          	add	hl,hl
0975+  4326 29          	add	hl,hl
0976+  4327 29          	add	hl,hl
0977+  4328 29          	add	hl,hl
0978+  4329 ED 5B 51 F3 	ld	de,(YF351)		; dirsector buffer
0979+  432D 19          	add	hl,de
0980+  432E DD 46 05    	ld	b,(ix+5)		; dirshift
0981+  4331 CB 39       A4331:	srl	c
0982+  4333 10 FC       	djnz	A4331
0983+  4335 3A 45 F2    	ld	a,(YF245)
0984+  4338 B9          	cp	c			; same as dirsector currently in buffer ?
0985+  4339 20 07       	jr	nz,A4342		; nope, go get it
0986+  433B 3A 46 F2    	ld	a,(YF246)
0987+  433E DD BE 00    	cp	(ix+0)		; same driveid as dirsector buffer owner ?
0988+  4341 C8          	ret	z			; yep, do nothing
0989+  4342 E5          A4342:	push	hl
0990+  4343 CD A4 46    	call	A46A4			; read dirsector
0991+  4346 E1          	pop	hl
0992+  4347 C9          	ret
0993+  4348             
0994+  4348             ;	Subroutine	get next direntry (while searching)
0995+  4348             ;	Inputs		
0996+  4348             ;	Outputs		________________________
0997+  4348             
0998+  4348 CD 5E F2    A4348:	call	XF25E
0999+  434B 3A B8 F2    	ld	a,(YF2B8)
1000+  434E 3C          	inc	a
1001+  434F DD BE 0B    	cp	(ix+11)			; last direntry ?
1002+  4352 30 13       	jr	nc,A4367		; yep, update directory of disk when needed and quit
1003+  4354 32 B8 F2    	ld	(YF2B8),a
1004+  4357 11 20 00    	ld	de,00020H
1005+  435A 19          	add	hl,de
1006+  435B DD A6 04    	and	(ix+4)			; dirmask
1007+  435E C0          	ret	nz
1008+  435F 0C          	inc	c
1009+  4360 CD A4 46    	call	A46A4			; read dirsector
1010+  4363 2A 51 F3    	ld	hl,(YF351)		; dirsector buffer
1011+  4366 C9          	ret
1012+  4367             
1013+  4367             ;	Subroutine	at end of directory
1014+  4367             ;	Inputs		
1015+  4367             ;	Outputs		________________________
1016+  4367             
1017+  4367 CD 43 47    A4367:	call	A4743			; flush directory buffer
1018+  436A 37          	scf
1019+  436B C9          	ret
1020+  436C             
1021+  436C             ;	Subroutine	BDOS 13 (delete file)
1022+  436C             ;	Inputs		
1023+  436C             ;	Outputs		________________________
1024+  436C             
1025+  436C CD 0E 44    A436C:	call	A440E			; validate FCB drive and filename
1026+  436F D4 B5 42    	call	nc,A42B5		; valid, find first directoryentry
1027+  4372 3E FF       	ld	a,0FFH
1028+  4374 D8          	ret	c			; invalid or not found, quit with error
1029+  4375 C0          	ret	nz			; device, quit with error
1030+  4376 3E E5       A4376:	ld	a,0E5H
1031+  4378 32 3C F2    	ld	(YF23C),a		; flag directory buffer changed
1032+  437B 77          	ld	(hl),a			; deleted direntry
1033+  437C FD 6E 1A    	ld	l,(iy+26)
1034+  437F FD 66 1B    	ld	h,(iy+27)
1035+  4382 7C          	ld	a,h			; file has start cluster ?
1036+  4383 B5          	or	l
1037+  4384 C4 9B 4F    	call	nz,A4F9B		; yep, release cluster chain
1038+  4387 CD BC 42    	call	A42BC			; find next directoryentry
1039+  438A 30 EA       	jr	nc,A4376		; found, delete next file
1040+  438C CD 03 44    	call	A4403			; update directory of disk (SHOULD BE: CALL A4748)
1041+  438F C3 CF 45    	jp	A45CF			; write FAT buffer (SHOULD BE: JP A45C4, flush FAT buffer)
1042+  4392             
1043+  4392             ;	Subroutine	BDOS 17 (rename file)
1044+  4392             ;	Inputs		
1045+  4392             ;	Outputs		________________________
1046+  4392             
1047+  4392 CD 0E 44    A4392:	call	A440E			; validate FCB drive and filename
1048+  4395 38 74       	jr	c,A440B			; invalid, quit with error
1049+  4397 11 05 00    	ld	de,00005H
1050+  439A 19          	add	hl,de			; to new filename
1051+  439B 11 C5 F2    	ld	de,YF2C5		; new filenamebuffer
1052+  439E CD F4 F1    	call	XF1F4			; validate FCB filename (new filename)
1053+  43A1 D4 B5 42    	call	nc,A42B5		; new filename valid, find first directoryentry
1054+  43A4 38 65       	jr	c,A440B			; invalid or not found, quit with error
1055+  43A6 20 63       	jr	nz,A440B
1056+  43A8 21 B9 F2    	ld	hl,YF2B9
1057+  43AB 11 D0 F2    	ld	de,YF2D0
1058+  43AE 01 0C 00    	ld	bc,11+1
1059+  43B1 ED B0       	ldir				; save filename (search specifier) + orginal DR byte
1060+  43B3 21 C5 F2    A43B3:	ld	hl,YF2C5		; new filename
1061+  43B6 11 B9 F2    	ld	de,YF2B9
1062+  43B9 06 0B       	ld	b,11
1063+  43BB 7E          A43BB:	ld	a,(hl)
1064+  43BC FE 3F       	cp	"?"			; wildcard char ?
1065+  43BE 20 03       	jr	nz,A43C3		; nope, use the char of the new filename
1066+  43C0 FD 7E 00    	ld	a,(iy+0)		; yep, use the char of the orginal filename
1067+  43C3 12          A43C3:	ld	(de),a
1068+  43C4 23          	inc	hl
1069+  43C5 13          	inc	de
1070+  43C6 FD 23       	inc	iy
1071+  43C8 10 F1       	djnz	A43BB
1072+  43CA 3E 80       	ld	a,080H
1073+  43CC 12          	ld	(de),a			; 'orginal DR byte' b7 set (ignore fileattribute)
1074+  43CD CD 5A 42    	call	A425A			; check if devicename
1075+  43D0 30 36       	jr	nc,A4408		; yep, end rename with error
1076+  43D2 3A B8 F2    	ld	a,(YF2B8)
1077+  43D5 F5          	push	af
1078+  43D6 3E FF       	ld	a,0FFH
1079+  43D8 32 B8 F2    	ld	(YF2B8),a		; flag direntry search start at the begin
1080+  43DB CD BC 42    	call	A42BC			; find next directoryentry
1081+  43DE C1          	pop	bc
1082+  43DF 30 27       	jr	nc,A4408		; found, so resulting filename does already exist. end rename with error
1083+  43E1 78          	ld	a,b
1084+  43E2 CD 17 43    	call	A4317			; get direntry which get renamed
1085+  43E5 EB          	ex	de,hl
1086+  43E6 21 B9 F2    	ld	hl,YF2B9
1087+  43E9 01 0B 00    	ld	bc,11
1088+  43EC ED B0       	ldir				; replace filename with new one
1089+  43EE 3E FF       	ld	a,0FFH
1090+  43F0 32 3C F2    	ld	(YF23C),a		; flag directory buffer changed
1091+  43F3 21 D0 F2    	ld	hl,YF2D0
1092+  43F6 11 B9 F2    	ld	de,YF2B9
1093+  43F9 01 0C 00    	ld	bc,11+1
1094+  43FC ED B0       	ldir				; restore filename (search specifier) + orginal DR byte
1095+  43FE CD BC 42    	call	A42BC			; find next directoryentry
1096+  4401 30 B0       	jr	nc,A43B3		; found, rename next file
1097+  4403 CD 43 47    A4403:	call	A4743			; flush directory buffer
1098+  4406 AF          	xor	a			; no error
1099+  4407 C9          	ret
1100+  4408             
1101+  4408 CD 43 47    A4408:	call	A4743			; flush directory buffer
1102+  440B 3E FF       A440B:	ld	a,0FFH			; error
1103+  440D C9          	ret
1104+  440E             
1105+  440E             ;	Subroutine	validate FCB drive and filename
1106+  440E             ;	Inputs		
1107+  440E             ;	Outputs		________________________
1108+  440E             
1109+  440E CD 61 F2    A440E:	call	XF261
1110+  4411 AF          	xor	a
1111+  4412 32 DC F2    	ld	(YF2DC),a		; do not include special fileattributes
1112+  4415 EB          	ex	de,hl
1113+  4416 7E          	ld	a,(hl)
1114+  4417 23          	inc	hl
1115+  4418 32 C4 F2    	ld	(YF2C4),a		; save FCB DR byte
1116+  441B E6 0F       	and	00FH			; only use b3-b0 for drive
1117+  441D CD 27 44    	call	A4427			; validate fcb driveid
1118+  4420 D8          	ret	c
1119+  4421 11 B9 F2    	ld	de,YF2B9
1120+  4424 C3 F4 F1    	jp	XF1F4			; validate FCB filename
1121+  4427             
1122+  4427             ;	Subroutine	Validate driveid (FCB style)
1123+  4427             ;	Inputs		A = driveid
1124+  4427             ;	Outputs		________________________
1125+  4427             
1126+  4427 4F          A4427:	ld	c,a
1127+  4428 3A 47 F3    	ld	a,(YF347)
1128+  442B B9          	cp	c
1129+  442C D8          	ret	c
1130+  442D 79          	ld	a,c
1131+  442E 3D          	dec	a
1132+  442F F2 35 44    	jp	p,A4435
1133+  4432 3A 47 F2    	ld	a,(YF247)		; default driveid
1134+  4435 32 E1 F2    A4435:	ld	(YF2E1),a		; set current driveid
1135+  4438 C9          	ret
1136+  4439             
1137+  4439             ;	Subroutine	get max record and extent
1138+  4439             ;	Inputs		
1139+  4439             ;	Outputs		________________________
1140+  4439             
1141+  4439 FD 7E 1F    A4439:	ld	a,(iy+31)
1142+  443C B7          	or	a
1143+  443D 20 1F       	jr	nz,A445E		; filesize > 16777215, use max value
1144+  443F FD 7E 1C    	ld	a,(iy+28)
1145+  4442 FD 4E 1D    	ld	c,(iy+29)
1146+  4445 FD 46 1E    	ld	b,(iy+30)
1147+  4448 87          	add	a,a
1148+  4449 CB 11       	rl	c
1149+  444B CB 10       	rl	b			; number of records (128 bytes)
1150+  444D 38 0F       	jr	c,A445E			; >65535, use max value
1151+  444F B7          	or	a			; is filesize a multiply of 128 ?
1152+  4450 28 05       	jr	z,A4457
1153+  4452 03          	inc	bc			; nope, increase the recordnumber
1154+  4453 78          	ld	a,b
1155+  4454 B1          	or	c			; does that fit ?
1156+  4455 28 07       	jr	z,A445E			; nope, use max value
1157+  4457 79          A4457:	ld	a,c
1158+  4458 CB B9       	res	7,c			; c = max recordnumber (0-127)
1159+  445A 87          	add	a,a
1160+  445B CB 10       	rl	b			; b = max extent
1161+  445D D0          	ret	nc			; does fit, quit
1162+  445E 01 7F FF    A445E:	ld	bc,0FF7FH		; extent 255, record 127
1163+  4461 C9          	ret
1164+  4462             
1165+  4462             ;	Subroutine	BDOS 0F (open file)
1166+  4462             ;	Inputs		
1167+  4462             ;	Outputs		________________________
1168+  4462             
1169+  4462 CD A5 42    A4462:	call	A42A5			; validate FCB, clear S2 and find direntry
1170+  4465 38 A4       	jr	c,A440B			; error, quit with error
1171+  4467 CD 39 44    	call	A4439			; get max record and extent
1172+  446A 3A 0C F3    	ld	a,(YF30C)		; original FCB EX byte
1173+  446D 04          	inc	b			; ?? correct for large files (filesize > 4177919 where extend is 0FFH)
1174+  446E B8          	cp	b			; is extent of file big enough ?
1175+  446F 30 9A       	jr	nc,A440B		; nope, quit with error
1176+  4471 CD 64 F2    A4471:	call	XF264
1177+  4474 EB          	ex	de,hl
1178+  4475 01 0F 00    	ld	bc,0000FH
1179+  4478 09          	add	hl,bc
1180+  4479 CD 39 44    	call	A4439			; get max record and extent
1181+  447C 3A 0C F3    	ld	a,(YF30C)
1182+  447F B8          	cp	b			; orginal FCB EX byte same as max extent ?
1183+  4480 28 06       	jr	z,A4488			; same, use RC=max recordnumber (means extent is not full)
1184+  4482 0E 80       	ld	c,080H
1185+  4484 38 02       	jr	c,A4488			; smaller, use RC=128 (means extend is full)
1186+  4486 0E 00       	ld	c,000H			; bigger, use RC=0 (means extend is empty)
1187+  4488 71          A4488:	ld	(hl),c			; RC
1188+  4489 23          	inc	hl
1189+  448A EB          	ex	de,hl
1190+  448B 01 1C 00    	ld	bc,0001CH
1191+  448E 09          	add	hl,bc
1192+  448F 0E 04       	ld	c,004H
1193+  4491 ED B0       	ldir				; copy filesize
1194+  4493 01 F8 FF    	ld	bc,0FFF8H
1195+  4496 09          	add	hl,bc
1196+  4497 ED A0       	ldi
1197+  4499 ED A0       	ldi				; creation date
1198+  449B 0E FC       	ld	c,0FCH
1199+  449D 09          	add	hl,bc
1200+  449E ED A0       	ldi
1201+  44A0 ED A0       	ldi				; creation time
1202+  44A2 FD 7E 0B    	ld	a,(iy+11)
1203+  44A5 CB 7F       	bit	7,a
1204+  44A7 20 05       	jr	nz,A44AE		; device,
1205+  44A9 DD 7E 00    	ld	a,(ix+0)		; driveid
1206+  44AC F6 40       	or	040H			; flag diskfile unchanged
1207+  44AE 12          A44AE:	ld	(de),a			; devicecode
1208+  44AF 13          	inc	de
1209+  44B0 3A B8 F2    	ld	a,(YF2B8)
1210+  44B3 12          	ld	(de),a			; direntry number
1211+  44B4 13          	inc	de
1212+  44B5 FD 7E 1A    	ld	a,(iy+26)
1213+  44B8 12          	ld	(de),a
1214+  44B9 13          	inc	de
1215+  44BA 13          	inc	de
1216+  44BB 12          	ld	(de),a
1217+  44BC 1B          	dec	de
1218+  44BD FD 7E 1B    	ld	a,(iy+27)
1219+  44C0 12          	ld	(de),a
1220+  44C1 13          	inc	de
1221+  44C2 13          	inc	de
1222+  44C3 12          	ld	(de),a			; start cluster and last cluster accessed
1223+  44C4 13          	inc	de
1224+  44C5 AF          	xor	a
1225+  44C6 12          	ld	(de),a
1226+  44C7 13          	inc	de
1227+  44C8 12          	ld	(de),a			; last cluster accessed, relative
1228+  44C9 C9          	ret
1229+  44CA             
1230+  44CA             ;	Subroutine	handle DSKCHG error
1231+  44CA             ;	Inputs		
1232+  44CA             ;	Outputs		________________________
1233+  44CA             
1234+  44CA 4F          A44CA:	ld	c,a
1235+  44CB 3A E1 F2    	ld	a,(YF2E1)		; current driveid
1236+  44CE CD 0A 47    	call	A470A			; start diskerror handler
1237+  44D1 18 08       	jr	A44DB			; get latest FAT (try again)
1238+  44D3             
1239+  44D3             ;	Subroutine	reset direntry search and get latest FAT
1240+  44D3             ;	Inputs		
1241+  44D3             ;	Outputs		________________________
1242+  44D3             
1243+  44D3 3E FF       A44D3:	ld	a,0FFH
1244+  44D5 32 B8 F2    	ld	(YF2B8),a		; invalid latest direntry (search from the begin)
1245+  44D8 32 FE F2    	ld	(YF2FE),a		; not found a free direntry
1246+  44DB             
1247+  44DB             ;	Subroutine	get latest FAT
1248+  44DB             ;	Inputs		
1249+  44DB             ;	Outputs		________________________
1250+  44DB             
1251+  44DB CD 67 F2    A44DB:	call	XF267
1252+  44DE CD 53 45    	call	A4555			; get pointer to DPB of current drive
1253+  44E1 3A E1 F2    	ld	a,(YF2E1)		; current driveid
1254+  44E4 DD 4E 01    	ld	c,(ix+1)		; mediadesciptor
1255+  44E7 06 00       	ld	b,0
1256+  44E9 B7          	or	a
1257+  44EA CD 67 60    	call	A6067			; DSKCHG
1258+  44ED 38 DB       	jr	c,A44CA			; error,
1259+  44EF CD 33 45    	call	A4536			; update DPBTBL entry current drive
1260+  44F2 DD 6E 13    	ld	l,(ix+19)
1261+  44F5 DD 66 14    	ld	h,(ix+20)
1262+  44F8 2B          	dec	hl
1263+  44F9 78          	ld	a,b			; DSKCHG status
1264+  44FA B6          	or	(hl)			; combined with the FAT buffer status
1265+  44FB 3A E1 F2    	ld	a,(YF2E1)		; current driveid
1266+  44FE 2A 41 F2    	ld	hl,(YF241)
1267+  4501 FA 0A 45    	jp	m,A450A			; FAT buffer invalid OR diskchange unknown, read the FAT
1268+  4504 C0          	ret	nz			; FAT buffer changed OR disk unchanged, do not read the FAT and quit
1269+  4505 BD          	cp	l			; current drive same as datasector buffer owner ?
1270+  4506 20 0B       	jr	nz,A4516		; nope, read the FAT
1271+  4508 25          	dec	h			; datasector buffer changed ?
1272+  4509 C8          	ret	z			; yep, do not read the FAT and quit
1273+  450A 95          A450A:	sub	l			; current drive same as datasector buffer owner ?
1274+  450B 20 06       	jr	nz,A4516		; nope, leave the datasector buffer alone
1275+  450D 6F          	ld	l,a
1276+  450E 67          	ld	h,a
1277+  450F             
1278+  450F             ; VERSION 1.1 CHANGE
1279+  450F             ; ld (YF23F),hl is removed, because it is not explicit needed
1280+  450F             ; room is used later on to fix the FAT reading bug when one of the other FAT copies is used (when first FAT read generates a error)
1281+  450F             
1282+  450F 2D          	dec	l
1283+  4510 22 41 F2    	ld	(YF241),hl		; invalid datasector buffer
1284+  4513 3E FF       A4516:	ld	a,0FFH
1285+  4515 32 46 F2    	ld	(YF246),a		; invalid dirsector buffer
1286+  4518 CD FA 45    	call	A45FA			; get FAT parameters
1287+  451B 2B          	dec	hl
1288+  451C 36 00       	ld	(hl),0			; FAT buffer unchanged
1289+  451E 23          	inc	hl
1290+  451F F5          A4522:	push	af
1291+  4520 CD D7 46    	call	A46D7			; read FAT sectors
1292+  4523 38 19       	jr	c,A4541			; error, try the next FAT copy
1293+  4525 F1          	pop	af
1294+  4526 46          A4529:	ld	b,(hl)			; mediabyte of FAT sector
1295+  4527 3A E1 F2    	ld	a,(YF2E1)		; current driveid
1296+  452A DD 4E 01    	ld	c,(ix+1)		; mediadescriptor
1297+  452D DD E5       	push	ix
1298+  452F E1          	pop	hl
1299+  4530 CD 6F 60    	call	A606F			; GETDPB
1300+  4533 E5          A4536:	push	hl
1301+  4534 DD E1       	pop	ix
1302+  4536 EB          	ex	de,hl
1303+  4537 CD 61 45    	call	A4563			; get DPBTBL entry of current drive
1304+  453A 73          	ld	(hl),e
1305+  453B 23          	inc	hl
1306+  453C 72          	ld	(hl),d
1307+  453D C9          	ret
1308+  453E             
1309+  453E 7B          A4541:	ld	a,e
1310+  453F 81          	add	a,c
1311+  4540 5F          	ld	e,a
1312+  4541 30 01       	jr	nc,A4547
1313+  4543 14          	inc	d
1314+  4544 F1          A4547:	pop	af			; adjust first FAT sector to the first FAT sector of the next FAT copy
1315+  4545             
1316+  4545             ; VERSION 1.1 BUGFIX
1317+  4545             ; Begin of change
1318+  4545             
1319+  4545 41          	ld	b,c			; restore sectors per FAT (B is destroyed by the DSKIO)
1320+  4546             
1321+  4546             ; End of change
1322+  4546              
1323+  4546 3D          	dec	a
1324+  4547 20 D6       	jr	nz,A4522		; there is a other FAT copy, try that one
1325+  4549 CD FA 45    	call	A45FA			; get FAT parameters (so the first FAT copy is used)
1326+  454C E5          	push	hl
1327+  454D CD C5 46    	call	A46C5			; read FAT sectors with DOS error handling
1328+  4550 E1          	pop	hl
1329+  4551 18 D3       	jr	A4529			; use FAT buffer
1330+  4553             
1331+  4553             ;	Subroutine	get pointer to DPB of current drive
1332+  4553             ;	Inputs		
1333+  4553             ;	Outputs		HL = IX = pointer to DPB
1334+  4553             
1335+  4553 CD 6A F2    A4555:	call	XF26A
1336+  4556 CD 61 45    	call	A4563			; get DPBTBL entry of current drive
1337+  4559 7E          	ld	a,(hl)
1338+  455A 23          	inc	hl
1339+  455B 66          	ld	h,(hl)
1340+  455C 6F          	ld	l,a
1341+  455D E5          	push	hl
1342+  455E DD E1       	pop	ix
1343+  4560 C9          	ret
1344+  4561             
1345+  4561             ;	Subroutine	get DPBTBL entry of current drive
1346+  4561             ;	Inputs		HL = address of pointer
1347+  4561             ;	Outputs		________________________
1348+  4561             
1349+  4561 3A E1 F2    A4563:	ld	a,(YF2E1)		; current driveid
1350+  4564 21 55 F3    	ld	hl,YF355
1351+  4567 87          	add	a,a
1352+  4568 85          	add	a,l
1353+  4569 6F          	ld	l,a
1354+  456A D0          	ret	nc
1355+  456B 24          	inc	h
1356+  456C C9          	ret
1357+  456D             
1358+  456D             ; CHANGED, TO KEEP ROUTINES ALIGNED WITH PREVIOUS VERSION
1359+  456D             
1360+  456D 00          	defs	0456FH-$,0
1361+  456F             
1362+  456F             ;	Subroutine	BDOS 10 (close file)
1363+  456F             ;	Inputs		
1364+  456F             ;	Outputs		________________________
1365+  456F             
1366+  456F D5          A456F:	push	de
1367+  4570 FD E1       	pop	iy
1368+  4572 CD 0E 44    	call	A440E			; validate FCB drive and filename
1369+  4575 3E FF       	ld	a,0FFH
1370+  4577 D8          	ret	c			; invalid, quit with error
1371+  4578 FD 7E 18    	ld	a,(iy+24)
1372+  457B E6 C0       	and	0C0H
1373+  457D 3E 00       	ld	a,0			; ok
1374+  457F C0          	ret	nz			; device OR unchanged diskfile, quit
1375+  4580 3A E1 F2    	ld	a,(YF2E1)		; current driveid
1376+  4583 2A 41 F2    	ld	hl,(YF241)
1377+  4586 BD          	cp	l			; same drive as owner datasector buffer ?
1378+  4587 CC 2D 47    	call	z,A472D			; yep, flush datasector buffer
1379+  458A CD 53 45    	call	A4555			; get pointer to DPB of current drive
1380+  458D FD 7E 19    	ld	a,(iy+25)		; direntrynumber
1381+  4590 CD 17 43    	call	A4317			; get direntry
1382+  4593 06 0B       	ld	b,11
1383+  4595 CD 4F 42    	call	A424F			; compare with filename1
1384+  4598 20 54       	jr	nz,A45EE		; not the same, make FAT buffer unchanged and quit with error
1385+  459A FD E5       	push	iy
1386+  459C D1          	pop	de
1387+  459D 0E 0B       	ld	c,00BH
1388+  459F 09          	add	hl,bc
1389+  45A0 EB          	ex	de,hl
1390+  45A1 0E 16       	ld	c,016H
1391+  45A3 09          	add	hl,bc
1392+  45A4 ED A0       	ldi
1393+  45A6 ED A0       	ldi
1394+  45A8 01 FC FF    	ld	bc,0FFFCH
1395+  45AB 09          	add	hl,bc
1396+  45AC ED A0       	ldi
1397+  45AE ED A0       	ldi
1398+  45B0 01 04 00    	ld	bc,00004H
1399+  45B3 09          	add	hl,bc
1400+  45B4 ED A0       	ldi
1401+  45B6 ED A0       	ldi
1402+  45B8 01 F4 FF    	ld	bc,0FFF4H
1403+  45BB 09          	add	hl,bc
1404+  45BC 01 04 00    	ld	bc,00004H
1405+  45BF ED B0       	ldir
1406+  45C1 CD 48 47    	call	A4748			; update directory of disk
1407+  45C4             
1408+  45C4             ;	Subroutine	flush FAT buffer
1409+  45C4             ;	Inputs		
1410+  45C4             ;	Outputs		________________________
1411+  45C4             
1412+  45C4 DD 6E 13    A45C4:	ld	l,(ix+19)
1413+  45C7 DD 66 14    	ld	h,(ix+20)
1414+  45CA 2B          	dec	hl
1415+  45CB 7E          	ld	a,(hl)
1416+  45CC FE 01       	cp	1			; FAT buffer changed ?
1417+  45CE C0          	ret	nz			; nope, quit (?? return error if FAT buffer invalid)
1418+  45CF             
1419+  45CF             ;	Subroutine	write FAT buffer
1420+  45CF             ;	Inputs		
1421+  45CF             ;	Outputs		________________________
1422+  45CF             
1423+  45CF CD 6D F2    A45CF:	call	XF26D
1424+  45D2 CD FA 45    	call	A45FA			; get FAT parameters
1425+  45D5 2B          	dec	hl
1426+  45D6 36 00       	ld	(hl),0			; FAT buffer unchanged
1427+  45D8 23          	inc	hl
1428+  45D9 F5          A45D9:	push	af
1429+  45DA D5          	push	de
1430+  45DB C5          	push	bc
1431+  45DC E5          	push	hl
1432+  45DD CD 55 47    	call	A4755			; write FAT sectors with DOS error handling
1433+  45E0 E1          	pop	hl
1434+  45E1 C1          	pop	bc
1435+  45E2 D1          	pop	de
1436+  45E3 7B          	ld	a,e
1437+  45E4 80          	add	a,b
1438+  45E5 5F          	ld	e,a
1439+  45E6 30 01       	jr	nc,A45E9
1440+  45E8 14          	inc	d			; to start sector of the next FAT
1441+  45E9 F1          A45E9:	pop	af
1442+  45EA 3D          	dec	a
1443+  45EB 20 EC       	jr	nz,A45D9		; write next FAT
1444+  45ED C9          	ret
1445+  45EE             
1446+  45EE             ;	Subroutine	make FAT buffer unchanged and quit with error
1447+  45EE             ;	Inputs		
1448+  45EE             ;	Outputs		________________________
1449+  45EE             
1450+  45EE DD 6E 13    A45EE:	ld	l,(ix+19)
1451+  45F1 DD 66 14    	ld	h,(ix+20)
1452+  45F4 2B          	dec	hl
1453+  45F5 36 00       	ld	(hl),0			; FAT buffer unchanged
1454+  45F7 3E FF       	ld	a,0FFH			; error
1455+  45F9 C9          	ret
1456+  45FA             
1457+  45FA             ;	Subroutine	get FAT parameters
1458+  45FA             ;	Inputs		IX = pointer to DPB
1459+  45FA             ;	Outputs		A = number of FATs, DE = first FAT sector, B = number sectors per FAT, HL = pointer to FAT buffer
1460+  45FA             
1461+  45FA DD 7E 0A    A45FA:	ld	a,(ix+10)		; number of FATs
1462+  45FD DD 6E 13    	ld	l,(ix+19)
1463+  4600 DD 66 14    	ld	h,(ix+20)		; pointer to FAT buffer
1464+  4603 DD 46 10    	ld	b,(ix+16)		; number of sectors per FAT
1465+  4606 DD 5E 08    	ld	e,(ix+8)
1466+  4609 DD 56 09    	ld	d,(ix+9)		; first FAT sector
1467+  460C C9          	ret
1468+  460D             
1469+  460D             ;	Subroutine	get dir parameters
1470+  460D             ;	Inputs		IX = pointer to DPB, A = relative dirsector, DE = first dirsector
1471+  460D             ;	Outputs		DE = dirsector, B = 1, HL = pointer to dirsector buffer
1472+  460D             
1473+  460D DD 86 11    A460D:	add	a,(ix+17)
1474+  4610 5F          	ld	e,a
1475+  4611 DD 56 12    	ld	d,(ix+18)
1476+  4614 30 01       	jr	nc,A4617
1477+  4616 14          	inc	d			; + first dir sector
1478+  4617 2A 51 F3    A4617:	ld	hl,(YF351)		; dirsector buffer
1479+  461A 06 01       	ld	b,1			; 1 sector
1480+  461C C9          	ret
1481+  461D             
1482+  461D             ;	Subroutine	BDOS 16 (create file)
1483+  461D             ;	Inputs		
1484+  461D             ;	Outputs		________________________
1485+  461D             
1486+  461D D5          A461D:	push	de
1487+  461E CD 0E 44    T461E:	call	A440E			; validate FCB drive and filename
1488+  4621 38 2A       	jr	c,A464D			; invalid, quit with error
1489+  4623 23          	inc	hl
1490+  4624 23          	inc	hl
1491+  4625 36 00       	ld	(hl),0			; clear S2 byte
1492+  4627 21 B9 F2    	ld	hl,YF2B9
1493+  462A 3E 3F       	ld	a,"?"
1494+  462C 01 0B 00    	ld	bc,11
1495+  462F ED B1       	cpir				; wildcard char in filename ?
1496+  4631 28 1A       	jr	z,A464D			; yep, quit with error
1497+  4633 CD B5 42    	call	A42B5			; find first directoryentry
1498+  4636 30 19       	jr	nc,A4651		; found, special actions for existing file/device
1499+  4638 3A FE F2    	ld	a,(YF2FE)
1500+  463B FE FF       	cp	0FFH			; found free direntry ?
1501+  463D 28 0E       	jr	z,A464D			; nope, quit with error (directory is full)
1502+  463F CD 17 43    	call	A4317			; get direntry
1503+  4642 E5          	push	hl
1504+  4643 FD E1       	pop	iy
1505+  4645 18 22       	jr	A4669			; setup direntry
1506+  4647             
1507+  4647 FD CB 0B 7E A4647:	bit	7,(iy+11)
1508+  464B 20 50       	jr	nz,A469D		; device, treat as open file
1509+  464D             					; file with special fileattribute, quit with error
1510+  464D D1          A464D:	pop	de
1511+  464E 3E FF       	ld	a,0FFH
1512+  4650 C9          	ret
1513+  4651             
1514+  4651 20 F4       A4651:	jr	nz,A4647		; device or file with special fileattribute,
1515+  4653 3A 0C F3    	ld	a,(YF30C)		; orginal FCB EX byte
1516+  4656 B7          	or	a
1517+  4657 20 44       	jr	nz,A469D		; is not zero, just open the file
1518+  4659 FD 6E 1A    	ld	l,(iy+26)
1519+  465C FD 66 1B    	ld	h,(iy+27)
1520+  465F 7C          	ld	a,h
1521+  4660 B5          	or	l			; has start cluster ?
1522+  4661 28 06       	jr	z,A4669			; nop,
1523+  4663 CD 9B 4F    	call	A4F9B			; release cluster chain
1524+  4666 CD CF 45    	call	A45CF			; write FAT buffer
1525+  4669 FD E5       A4669:	push	iy
1526+  466B D1          	pop	de
1527+  466C 21 B9 F2    	ld	hl,YF2B9
1528+  466F 01 0B 00    	ld	bc,11
1529+  4672 ED B0       	ldir				; copy filename in FCB to direntry
1530+  4674 7E          	ld	a,(hl)
1531+  4675 17          	rla
1532+  4676 3E 00       	ld	a,000H
1533+  4678 30 02       	jr	nc,A467C		; b7 DR byte reset, ordinary file
1534+  467A 3E 06       	ld	a,006H			; b7 DR byte set, hidden system file
1535+  467C 12          A467C:	ld	(de),a
1536+  467D 13          	inc	de
1537+  467E EB          	ex	de,hl
1538+  467F 06 0A       	ld	b,10
1539+  4681 AF          	xor	a
1540+  4682 77          A4682:	ld	(hl),a
1541+  4683 23          	inc	hl
1542+  4684 10 FC       	djnz	A4682			; clear unused bytes direntry
1543+  4686 E5          	push	hl
1544+  4687 CD 96 54    	call	A5496			; get time and date (dirformat)
1545+  468A E1          	pop	hl
1546+  468B 73          	ld	(hl),e
1547+  468C 23          	inc	hl
1548+  468D 72          	ld	(hl),d
1549+  468E 23          	inc	hl
1550+  468F 71          	ld	(hl),c
1551+  4690 23          	inc	hl
1552+  4691 70          	ld	(hl),b
1553+  4692 23          	inc	hl			; fill in time and date in direntry
1554+  4693 AF          	xor	a
1555+  4694 06 06       	ld	b,2+4
1556+  4696 77          A4696:	ld	(hl),a
1557+  4697 23          	inc	hl
1558+  4698 10 FC       	djnz	A4696			; fill in no first cluster, filesize 0 in direntry
1559+  469A CD 48 47    	call	A4748			; update directory of disk
1560+  469D             
1561+  469D FD E5       A469D:	push	iy
1562+  469F E1          	pop	hl
1563+  46A0 D1          	pop	de
1564+  46A1 C3 71 44    	jp	A4471			; continue with open file
1565+  46A4             
1566+  46A4             ;	Subroutine	read dirsector
1567+  46A4             ;	Inputs		C = relative dir sector
1568+  46A4             ;	Outputs		________________________
1569+  46A4             
1570+  46A4 C5          A46A4:	push	bc
1571+  46A5 CD 43 47    	call	A4743			; flush directory buffer
1572+  46A8 C1          	pop	bc
1573+  46A9 DD 46 00    	ld	b,(ix+0)		; driveid
1574+  46AC ED 43 45 F2 	ld	(YF246-1),bc		; set driveid and sector dirsector buffer
1575+  46B0 C5          	push	bc
1576+  46B1 79          	ld	a,c			; relative dirsector
1577+  46B2 CD 0D 46    	call	A460D			; setup dirsector parameters
1578+  46B5 CD C5 46    	call	A46C5			; read dirsector with DOS error handling
1579+  46B8 C1          	pop	bc
1580+  46B9 C9          	ret
1581+  46BA             
1582+  46BA             ;	Subroutine	BDOS 2F (read logical sector)
1583+  46BA             ;	Inputs		
1584+  46BA             ;	Outputs		________________________
1585+  46BA             
1586+  46BA 44          A46BA:	ld	b,h
1587+  46BB 7D          	ld	a,l
1588+  46BC 32 E1 F2    	ld	(YF2E1),a		; set current driveid
1589+  46BF CD 53 45    	call	A4555			; get pointer to DPB of current drive
1590+  46C2 2A 3D F2    	ld	hl,(YF23D)		; transferaddress
1591+  46C5             
1592+  46C5             ;	Subroutine	read sectors with DOS error handling
1593+  46C5             ;	Inputs		
1594+  46C5             ;	Outputs		________________________
1595+  46C5             
1596+  46C5 CD 70 F2    A46C5:	call	XF270
1597+  46C8 AF          	xor	a
1598+  46C9 32 FF F2    	ld	(YF2FF),a		; flag read disk operation
1599+  46CC CD D7 46    	call	A46D7			; read sector
1600+  46CF D0          	ret	nc			; no error, quit
1601+  46D0 CD E8 46    	call	A46E8			; adjust parameters to restart at error sector and start diskerror handler
1602+  46D3 3D          	dec	a
1603+  46D4 28 EF       	jr	z,A46C5			; RETRY, try again
1604+  46D6 C9          	ret				; IGNORE, quit
1605+  46D7             
1606+  46D7             ;	Subroutine	read sectors
1607+  46D7             ;	Inputs		
1608+  46D7             ;	Outputs		________________________
1609+  46D7             
1610+  46D7 DD 7E 00    A46D7:	ld	a,(ix+0)		; driveid
1611+  46DA DD 4E 01    	ld	c,(ix+1)		; mediadescriptor
1612+  46DD E5          	push	hl
1613+  46DE D5          	push	de
1614+  46DF C5          	push	bc
1615+  46E0 CD 52 60    	call	A6052			; read disksector
1616+  46E3 D1          	pop	de
1617+  46E4 4A          	ld	c,d
1618+  46E5 D1          	pop	de
1619+  46E6 E1          	pop	hl
1620+  46E7 C9          	ret
1621+  46E8             
1622+  46E8             ;	Subroutine	adjust parameters to restart at error sector and start diskerror handler
1623+  46E8             ;	Inputs		
1624+  46E8             ;	Outputs		________________________
1625+  46E8             
1626+  46E8 F5          A46E8:	push	af
1627+  46E9 79          	ld	a,c
1628+  46EA 90          	sub	b
1629+  46EB 4F          	ld	c,a
1630+  46EC C5          	push	bc
1631+  46ED 06 00       	ld	b,000H
1632+  46EF EB          	ex	de,hl
1633+  46F0 09          	add	hl,bc
1634+  46F1 E5          	push	hl
1635+  46F2 D5          	push	de
1636+  46F3 DD 5E 02    	ld	e,(ix+2)
1637+  46F6 DD 56 03    	ld	d,(ix+3)		; sectorsize
1638+  46F9 CD 16 49    	call	A4916			; multiply
1639+  46FC E1          	pop	hl
1640+  46FD D1          	pop	de
1641+  46FE 09          	add	hl,bc
1642+  46FF C1          	pop	bc
1643+  4700 F1          	pop	af
1644+  4701 4F          	ld	c,a
1645+  4702 3A FF F2    	ld	a,(YF2FF)		; type of diskoperation
1646+  4705 B1          	or	c
1647+  4706 4F          	ld	c,a
1648+  4707 DD 7E 00    	ld	a,(ix+0)		; driveid
1649+  470A             
1650+  470A             ;	Subroutine	start diskerror handler
1651+  470A             ;	Inputs		
1652+  470A             ;	Outputs		________________________
1653+  470A             
1654+  470A CD 73 F2    A470A:	call	XF273
1655+  470D C5          	push	bc
1656+  470E D5          	push	de
1657+  470F E5          	push	hl
1658+  4710 2A 23 F3    	ld	hl,(YF323)
1659+  4713 CD E8 F1    	call	XF1E8			; start diskerror handler in DOS memory
1660+  4716 79          	ld	a,c			; requested action
1661+  4717 E1          	pop	hl
1662+  4718 D1          	pop	de
1663+  4719 C1          	pop	bc
1664+  471A FE 02       	cp	2
1665+  471C C0          	ret	nz
1666+  471D C3 E2 F1    	jp	XF1E2			; Warm boot
1667+  4720             
1668+  4720             ;	Subroutine	BDOS 30 (write logical sector)
1669+  4720             ;	Inputs		
1670+  4720             ;	Outputs		________________________
1671+  4720             
1672+  4720 44          A4720:	ld	b,h
1673+  4721 7D          	ld	a,l
1674+  4722 32 E1 F2    	ld	(YF2E1),a		; set current driveid
1675+  4725 CD 53 45    	call	A4555			; get pointer to DPB of current drive
1676+  4728 2A 3D F2    	ld	hl,(YF23D)		; transferaddress
1677+  472B 18 28       	jr	A4755			; write sectors with DOS error handling
1678+  472D             
1679+  472D             ;	Subroutine	flush datasector buffer
1680+  472D             ;	Inputs		
1681+  472D             ;	Outputs		________________________
1682+  472D             
1683+  472D 21 42 F2    A472D:	ld	hl,YF242
1684+  4730 AF          	xor	a
1685+  4731 BE          	cp	(hl)			; datasector buffer changed ?
1686+  4732 77          	ld	(hl),a			; now it is unchanged
1687+  4733 C8          	ret	z			; nope, quit
1688+  4734 DD 2A 43 F2 	ld	ix,(YF243)		; saved DPB pointer
1689+  4738 2A 4F F3    	ld	hl,(YF34F)		; datasector buffer
1690+  473B 06 01       	ld	b,1			; 1 sector
1691+  473D ED 5B 3F F2 	ld	de,(YF23F)		; sectornumber of datasector buffer
1692+  4741 18 12       	jr	A4755			; write sector with DOS error handling
1693+  4743             
1694+  4743             ;	Subroutine	flush directory buffer
1695+  4743             ;	Inputs		
1696+  4743             ;	Outputs		________________________
1697+  4743             
1698+  4743 3A 3C F2    A4743:	ld	a,(YF23C)
1699+  4746 B7          	or	a			; directory buffer changed ?
1700+  4747 C8          	ret	z			; nope, quit
1701+  4748             
1702+  4748             ;	Subroutine	write dirsector buffer
1703+  4748             ;	Inputs		
1704+  4748             ;	Outputs		________________________
1705+  4748             
1706+  4748 CD 76 F2    A4748:	call	XF276
1707+  474B AF          	xor	a
1708+  474C 32 3C F2    	ld	(YF23C),a		; directory buffer unchanged
1709+  474F 3A 45 F2    	ld	a,(YF245)		; current dirsector (offset)
1710+  4752 CD 0D 46    	call	A460D			; setup dirsector parameters
1711+  4755             
1712+  4755             ;	Subroutine	write sectors with DOS error handling
1713+  4755             ;	Inputs		
1714+  4755             ;	Outputs		________________________
1715+  4755             
1716+  4755 CD 79 F2    A4755:	call	XF279
1717+  4758 3E 01       	ld	a,1
1718+  475A 32 FF F2    	ld	(YF2FF),a		; flag write disk operation
1719+  475D DD 7E 00    	ld	a,(ix+0)		; driveid
1720+  4760 DD 4E 01    	ld	c,(ix+1)		; mediadescriptor
1721+  4763 E5          	push	hl
1722+  4764 D5          	push	de
1723+  4765 C5          	push	bc
1724+  4766 CD 54 60    	call	A6054			; write disksector
1725+  4769 D1          	pop	de
1726+  476A 4A          	ld	c,d
1727+  476B D1          	pop	de
1728+  476C E1          	pop	hl
1729+  476D D0          	ret	nc			; no error, quit
1730+  476E CD E8 46    	call	A46E8			; adjust parameters to restart at error sector and start diskerror handler
1731+  4771 3D          	dec	a
1732+  4772 28 E1       	jr	z,A4755			; RETRY, try again
1733+  4774 C9          	ret				; IGNORE, quit
1734+  4775             
1735+  4775             ;	Subroutine	BDOS 14 (read next record)
1736+  4775             ;	Inputs		
1737+  4775             ;	Outputs		________________________
1738+  4775             
1739+  4775 CD F8 4E    A4775:	call	A4EF8			; get recordnumber from CR,EX and S2 fields
1740+  4778 CD 23 4B    	call	A4B23			; read record
1741+  477B 18 06       	jr	A4783			; update sequencial fields
1742+  477D             
1743+  477D             ;	Subroutine	BDOS 15 (write next record)
1744+  477D             ;	Inputs		
1745+  477D             ;	Outputs		________________________
1746+  477D             
1747+  477D CD F8 4E    A477D:	call	A4EF8			; get recordnumber from CR,EX and S2 fields
1748+  4780 CD A3 4C    	call	A4CA3			; write record
1749+  4783 CD 6A 48    A4783:	call	A486A			; increase recordnumber if something was read/written
1750+  4786 18 14       	jr	A479C			; update CR,EX and S2 field
1751+  4788             
1752+  4788             ;	Subroutine	BDOS 21 (random access read record)
1753+  4788             ;	Inputs		
1754+  4788             ;	Outputs		________________________
1755+  4788             
1756+  4788 CD 57 48    A4788:	call	A4857			; get recordnumber from Rx fields, 1 record
1757+  478B CD 23 4B    	call	A4B23			; read record
1758+  478E 18 09       	jr	A4799			; update Rx, CR,EX and S2 field
1759+  4790             
1760+  4790 FD E5       A4790:	push	iy
1761+  4792 D1          	pop	de
1762+  4793             
1763+  4793             ;	Subroutine	BDOS 22 (random access write record)
1764+  4793             ;	Inputs		
1765+  4793             ;	Outputs		________________________
1766+  4793             
1767+  4793 CD 57 48    A4793:	call	A4857			; get recordnumber from Rx fields, 1 record
1768+  4796 CD A3 4C    	call	A4CA3			; write record
1769+  4799 CD 44 48    A4799:	call	A4844			; update Rx fields
1770+  479C             
1771+  479C 7D          A479C:	ld	a,l
1772+  479D E6 7F       	and	07FH
1773+  479F FD 77 20    	ld	(iy+32),a		; CR
1774+  47A2 CB 25       	sla	l
1775+  47A4 CB 14       	rl	h
1776+  47A6 FD 74 0C    	ld	(iy+12),h		; S2
1777+  47A9 CB 13       	rl	e
1778+  47AB FD 73 0E    	ld	(iy+14),e		; EX
1779+  47AE 3A DE F2    	ld	a,(YF2DE)		; result recordoperation
1780+  47B1 C9          	ret
1781+  47B2             
1782+  47B2             ;	Subroutine	BDOS 27 (MSXDOS random block read)
1783+  47B2             ;	Inputs		
1784+  47B2             ;	Outputs		________________________
1785+  47B2             
1786+  47B2 AF          A47B2:	xor	a
1787+  47B3 32 06 F3    	ld	(YF306),a		; no CP/M call
1788+  47B6 CD 5A 48    	call	A485A			; get random record number
1789+  47B9 CD 23 4B    	call	A4B23			; read record(s)
1790+  47BC 18 0A       	jr	A47C8
1791+  47BE             
1792+  47BE             ;	Subroutine	BDOS 26 (MSXDOS random block write)
1793+  47BE             ;	Inputs		
1794+  47BE             ;	Outputs		________________________
1795+  47BE             
1796+  47BE AF          A47BE:	xor	a
1797+  47BF 32 06 F3    	ld	(YF306),a		; no CP/M call
1798+  47C2 CD 5A 48    	call	A485A			; get random record number
1799+  47C5 CD A3 4C    	call	A4CA3			; write record(s)
1800+  47C8 CD 6A 48    A47C8:	call	A486A			; increase recordnumber if something was read/written
1801+  47CB CD 44 48    	call	A4844			; update Rx fields
1802+  47CE 69          	ld	l,c
1803+  47CF 60          	ld	h,b
1804+  47D0 C9          	ret
1805+  47D1             
1806+  47D1             ;	Subroutine	BDOS 28 (write random with zero fill)
1807+  47D1             ;	Inputs		
1808+  47D1             ;	Outputs		________________________
1809+  47D1             
1810+  47D1 D5          A47D1:	push	de
1811+  47D2 FD E1       	pop	iy
1812+  47D4 FD 7E 10    	ld	a,(iy+16)
1813+  47D7 FD 4E 11    	ld	c,(iy+17)
1814+  47DA FD 46 12    	ld	b,(iy+18)
1815+  47DD FD 5E 13    	ld	e,(iy+19)
1816+  47E0 87          	add	a,a
1817+  47E1 CB 11       	rl	c
1818+  47E3 CB 10       	rl	b
1819+  47E5 CB 13       	rl	e			; convert filesize to a random record number
1820+  47E7 B7          	or	a			; was filesize a multiply of 128 ?
1821+  47E8 28 06       	jr	z,A47F0
1822+  47EA 03          	inc	bc
1823+  47EB 78          	ld	a,b
1824+  47EC B1          	or	c
1825+  47ED 20 01       	jr	nz,A47F0
1826+  47EF 1C          	inc	e			; no, increase random record number
1827+  47F0             
1828+  47F0             ; the following code depends on the fact that CP/M 2.2 only uses the R0 and R1 field
1829+  47F0             ; code only works when the random record (filesize) is within 65536 records of the random record (fcb)
1830+  47F0             
1831+  47F0 FD 6E 21    A47F0:	ld	l,(iy+33)
1832+  47F3 FD 66 22    	ld	h,(iy+34)		; R1 and R0
1833+  47F6 ED 42       	sbc	hl,bc
1834+  47F8 28 96       	jr	z,A4790			; exact at end of file, random access write record and quit
1835+  47FA FD 7E 23    	ld	a,(iy+35)
1836+  47FD 9B          	sbc	a,e			; before end of file ?
1837+  47FE 38 90       	jr	c,A4790			; yep, random access write record and quit
1838+  4800 E5          	push	hl			; save number of gap records
1839+  4801 CD 90 47    	call	A4790			; random access write record (gap in filled with garbage)
1840+  4804 D1          	pop	de
1841+  4805 B7          	or	a
1842+  4806 C0          	ret	nz			; error, quit
1843+  4807             
1844+  4807             ; now the gap is filled. dirsector buffer is used for the zero filled record
1845+  4807             ; neat code should first flush the dirsector buffer, but this is ommited
1846+  4807             
1847+  4807 2A 3D F2    	ld	hl,(YF23D)		; transferaddress
1848+  480A E5          	push	hl
1849+  480B 2A 51 F3    	ld	hl,(YF351)
1850+  480E 22 3D F2    	ld	(YF23D),hl		; tempory use dirsector buffer
1851+  4811 06 80       	ld	b,128
1852+  4813 77          A4813:	ld	(hl),a
1853+  4814 23          	inc	hl
1854+  4815 10 FC       	djnz	A4813			; create a zero filed random record
1855+  4817 3D          	dec	a
1856+  4818 32 46 F2    	ld	(YF246),a		; invalid dirsector buffer
1857+  481B FD 6E 21    	ld	l,(iy+33)
1858+  481E FD 66 22    	ld	h,(iy+34)
1859+  4821 ED 52       	sbc	hl,de
1860+  4823 4D          	ld	c,l
1861+  4824 44          	ld	b,h
1862+  4825 EB          	ex	de,hl
1863+  4826 16 00       	ld	d,000H
1864+  4828 FD 7E 23    	ld	a,(iy+35)
1865+  482B 9A          	sbc	a,d
1866+  482C 5F          	ld	e,a			; start record of gap
1867+  482D E5          A482D:	push	hl
1868+  482E 21 01 00    	ld	hl,1
1869+  4831 CD A3 4C    	call	A4CA3			; write record
1870+  4834 CD 6A 48    	call	A486A			; increase recordnumber if something was writen
1871+  4837 4D          	ld	c,l
1872+  4838 44          	ld	b,h
1873+  4839 E1          	pop	hl
1874+  483A 2B          	dec	hl
1875+  483B 7C          	ld	a,h
1876+  483C B5          	or	l
1877+  483D 20 EE       	jr	nz,A482D		; next record
1878+  483F E1          	pop	hl
1879+  4840 22 3D F2    	ld	(YF23D),hl		; restore transferaddress
1880+  4843 C9          	ret
1881+  4844             
1882+  4844 3A DE F2    A4844:	ld	a,(YF2DE)		; result recordoperation
1883+  4847 FD 75 21    	ld	(iy+33),l
1884+  484A FD 74 22    	ld	(iy+34),h
1885+  484D FD 73 23    	ld	(iy+35),e
1886+  4850 14          	inc	d
1887+  4851 15          	dec	d
1888+  4852 C8          	ret	z
1889+  4853 FD 72 24    	ld	(iy+36),d
1890+  4856 C9          	ret
1891+  4857             
1892+  4857 21 01 00    A4857:	ld	hl,1			; 1 record
1893+  485A D5          A485A:	push	de
1894+  485B FD E1       	pop	iy
1895+  485D FD 4E 21    	ld	c,(iy+33)		; R0
1896+  4860 FD 46 22    	ld	b,(iy+34)		; R1
1897+  4863 FD 5E 23    	ld	e,(iy+35)		; R2
1898+  4866 FD 56 24    	ld	d,(iy+36)		; R3
1899+  4869 C9          	ret
1900+  486A             
1901+  486A C8          A486A:	ret	z
1902+  486B 23          	inc	hl
1903+  486C 7C          	ld	a,h
1904+  486D B5          	or	l
1905+  486E C0          	ret	nz
1906+  486F 13          	inc	de
1907+  4870 C9          	ret
1908+  4871             
1909+  4871 E1          A4871:	pop	hl
1910+  4872 69          	ld	l,c
1911+  4873 60          	ld	h,b
1912+  4874 3E 01       	ld	a,1
1913+  4876 32 DE F2    	ld	(YF2DE),a		; error in recordoperation
1914+  4879 AF          	xor	a
1915+  487A 4F          	ld	c,a
1916+  487B 47          	ld	b,a
1917+  487C C9          	ret
1918+  487D             
1919+  487D 22 E8 F2    A487D:	ld	(YF2E8),hl		; number of records requested
1920+  4880 ED 43 E4 F2 	ld	(YF2E4+0),bc
1921+  4884 ED 53 E6 F2 	ld	(YF2E4+2),de		; startrecord
1922+  4888 FD 7E 00    	ld	a,(iy+0)
1923+  488B CD 27 44    	call	A4427			; validate fcb driveid
1924+  488E 38 E1       	jr	c,A4871
1925+  4890 11 80 00    	ld	de,00080H
1926+  4893 3A 06 F3    	ld	a,(YF306)
1927+  4896 B7          	or	a			; Random Block ?
1928+  4897 20 0F       	jr	nz,A48A8
1929+  4899 FD 7E 0E    	ld	a,(iy+14)
1930+  489C FD 56 0F    	ld	d,(iy+15)		; yep, use user set recordsize
1931+  489F 5F          	ld	e,a
1932+  48A0 B2          	or	d			; zero recordsize ?
1933+  48A1 20 05       	jr	nz,A48A8
1934+  48A3 1E 80       	ld	e,128
1935+  48A5 FD 73 0E    	ld	(iy+14),e		; yep, use 128 bytes default
1936+  48A8 14          A48A8:	inc	d
1937+  48A9 15          	dec	d
1938+  48AA 20 05       	jr	nz,A48B1
1939+  48AC 7B          	ld	a,e
1940+  48AD FE 40       	cp	64
1941+  48AF 38 04       	jr	c,A48B5
1942+  48B1 AF          A48B1:	xor	a
1943+  48B2 32 E7 F2    	ld	(YF2E4+3),a		; recordsize >64, clear b31-b24 of record (use 24 bit recordnumbers)
1944+  48B5 2A 3D F2    A48B5:	ld	hl,(YF23D)
1945+  48B8 22 E2 F2    	ld	(YF2E2),hl		; current transferaddress
1946+  48BB AF          	xor	a
1947+  48BC 32 DE F2    	ld	(YF2DE),a		; no error in recordoperation
1948+  48BF 32 DF F2    	ld	(YF2DF),a		; flag do not increase sector
1949+  48C2 ED 4B E8 F2 	ld	bc,(YF2E8)		; number of records requested
1950+  48C6 CD 16 49    	call	A4916			; * recordsize
1951+  48C9 FD 7E 18    	ld	a,(iy+24)
1952+  48CC B7          	or	a
1953+  48CD F8          	ret	m			; DOS device, quit
1954+  48CE C5          	push	bc
1955+  48CF CD 53 45    	call	A4555			; get pointer to DPB of current drive
1956+  48D2 ED 4B E4 F2 	ld	bc,(YF2E4+0)
1957+  48D6 CD 16 49    	call	A4916			; multiply
1958+  48D9 ED 43 F4 F2 	ld	(YF2F4+0),bc
1959+  48DD C5          	push	bc
1960+  48DE ED 4B E6 F2 	ld	bc,(YF2E4+2)
1961+  48E2 CD 1C 49    	call	A491C			; multiply high word
1962+  48E5 ED 43 F6 F2 	ld	(YF2F4+2),bc		; startbyte = startrecord * recordsize
1963+  48E9 60          	ld	h,b
1964+  48EA 69          	ld	l,c
1965+  48EB C1          	pop	bc			; BCHL = startbyte
1966+  48EC DD 5E 02    	ld	e,(ix+2)
1967+  48EF DD 56 03    	ld	d,(ix+3)
1968+  48F2 CD 32 49    	call	A4932			; / sectorsize
1969+  48F5 22 F2 F2    	ld	(YF2F2),hl		; offset in sector of startbyte
1970+  48F8 ED 43 EE F2 	ld	(YF2EE),bc		; relative sector of startbyte
1971+  48FC DD 7E 06    	ld	a,(ix+6)
1972+  48FF A1          	and	c			; clustermask
1973+  4900 32 DD F2    	ld	(YF2DD),a		; current relative sector in cluster (of startbyte)
1974+  4903 DD 7E 07    	ld	a,(ix+7)		; clustershift
1975+  4906 3D          A4906:	dec	a
1976+  4907 28 06       	jr	z,A490F
1977+  4909 CB 38       	srl	b
1978+  490B CB 19       	rr	c
1979+  490D 18 F7       	jr	A4906
1980+  490F             
1981+  490F ED 43 EC F2 A490F:	ld	(YF2EC),bc		; relative cluster of startbyte
1982+  4913 C1          	pop	bc
1983+  4914 AF          	xor	a
1984+  4915 C9          	ret
1985+  4916             
1986+  4916             ;	Subroutine	multiply
1987+  4916             ;	Inputs		
1988+  4916             ;	Outputs		________________________
1989+  4916             
1990+  4916 CD 7C F2    A4916:	call	XF27C
1991+  4919 21 00 00    	ld	hl,0
1992+  491C             
1993+  491C             ;	Subroutine	multiply high word
1994+  491C             ;	Inputs		
1995+  491C             ;	Outputs		________________________
1996+  491C             
1997+  491C 78          A491C:	ld	a,b
1998+  491D 06 11       	ld	b,011H
1999+  491F 18 07       	jr	A4928
2000+  4921             
2001+  4921 30 01       A4921:	jr	nc,A4924
2002+  4923 19          	add	hl,de
2003+  4924 CB 1C       A4924:	rr	h
2004+  4926 CB 1D       	rr	l
2005+  4928 1F          A4928:	rra
2006+  4929 CB 19       	rr	c
2007+  492B 10 F4       	djnz	A4921
2008+  492D 47          	ld	b,a
2009+  492E C9          	ret
2010+  492F             
2011+  492F             ;	Subroutine	divide
2012+  492F             ;	Inputs		
2013+  492F             ;	Outputs		________________________
2014+  492F             
2015+  492F             DIV16:
2016+  492F 21 00 00    A492F:	ld	hl,0
2017+  4932             
2018+  4932             ;	Subroutine	divide
2019+  4932             ;	Inputs		
2020+  4932             ;	Outputs		________________________
2021+  4932             
2022+  4932 CD 7F F2    A4932:	call	XF27F
2023+  4935 78          	ld	a,b
2024+  4936 06 10       	ld	b,010H
2025+  4938 CB 11       	rl	c
2026+  493A 17          	rla
2027+  493B CB 15       A493B:	rl	l
2028+  493D CB 14       	rl	h
2029+  493F 38 0D       	jr	c,A494E
2030+  4941 ED 52       	sbc	hl,de
2031+  4943 30 01       	jr	nc,A4946
2032+  4945 19          	add	hl,de
2033+  4946 3F          A4946:	ccf
2034+  4947 CB 11       A4947:	rl	c
2035+  4949 17          	rla
2036+  494A 10 EF       	djnz	A493B
2037+  494C 47          	ld	b,a
2038+  494D C9          	ret
2039+  494E             
2040+  494E B7          A494E:	or	a
2041+  494F ED 52       	sbc	hl,de
2042+  4951 18 F4       	jr	A4947
2043+  4953             
2044+  4953             ;	Subroutine	calculate partial sector transfers
2045+  4953             ;	Inputs		
2046+  4953             ;	Outputs		________________________
2047+  4953             
2048+  4953 60          A4953:	ld	h,b
2049+  4954 69          	ld	l,c			; bytes to transfer
2050+  4955 ED 4B F2 F2 	ld	bc,(YF2F2)		; offset in sector startbyte
2051+  4959 78          	ld	a,b
2052+  495A B1          	or	c
2053+  495B 5F          	ld	e,a
2054+  495C 57          	ld	d,a
2055+  495D 28 13       	jr	z,A4972			; at start sector, no partial start
2056+  495F DD 5E 02    	ld	e,(ix+2)
2057+  4962 DD 56 03    	ld	d,(ix+3)
2058+  4965 EB          	ex	de,hl			; sectorsize
2059+  4966 ED 42       	sbc	hl,bc
2060+  4968 EB          	ex	de,hl			; bytes left in sector
2061+  4969 ED 52       	sbc	hl,de			; enough ?
2062+  496B 30 05       	jr	nc,A4972		; nop, get what you can
2063+  496D 19          	add	hl,de
2064+  496E EB          	ex	de,hl
2065+  496F 21 00 00    	ld	hl,0
2066+  4972 ED 53 F8 F2 A4972:	ld	(YF2F8),de		; bytes to transfer from partial sector
2067+  4976 4D          	ld	c,l
2068+  4977 44          	ld	b,h			; bytes left after partial sector transfer
2069+  4978 DD 5E 02    	ld	e,(ix+2)
2070+  497B DD 56 03    	ld	d,(ix+3)
2071+  497E CD 2F 49    	call	A492F			; / sectorsize
2072+  4981 22 FA F2    	ld	(YF2FA),hl		; partial bytes in endsector
2073+  4984 ED 43 FC F2 	ld	(YF2FC),bc		; hole sectors of transfer
2074+  4988 C9          	ret
2075+  4989             
2076+  4989             ;	Subroutine	get absolute cluster
2077+  4989             ;	Inputs		
2078+  4989             ;	Outputs		________________________
2079+  4989             
2080+  4989 CD 82 F2    A4989:	call	XF282
2081+  498C FD 6E 1C    	ld	l,(iy+28)
2082+  498F FD 66 1D    	ld	h,(iy+29)		; current cluster of file
2083+  4992 FD 5E 1E    	ld	e,(iy+30)
2084+  4995 FD 56 1F    	ld	d,(iy+31)		; current relative cluster of file
2085+  4998 7D          	ld	a,l
2086+  4999 B4          	or	h
2087+  499A 28 33       	jr	z,A49CF			; file has no start cluster,
2088+  499C C5          	push	bc
2089+  499D 79          	ld	a,c
2090+  499E 93          	sub	e
2091+  499F 4F          	ld	c,a
2092+  49A0 78          	ld	a,b
2093+  49A1 9A          	sbc	a,d
2094+  49A2 47          	ld	b,a
2095+  49A3 30 0B       	jr	nc,A49B0		; requested cluster behind current, search from current cluster
2096+  49A5 C1          	pop	bc
2097+  49A6 11 00 00    	ld	de,0			; relative cluster 0
2098+  49A9 FD 6E 1A    	ld	l,(iy+26)
2099+  49AC FD 66 1B    	ld	h,(iy+27)		; start cluster of file
2100+  49AF F5          	push	af
2101+  49B0 F1          A49B0:	pop	af
2102+  49B1 CD 85 F2    A49B1:	call	XF285
2103+  49B4 78          	ld	a,b
2104+  49B5 B1          	or	c
2105+  49B6 C8          	ret	z
2106+  49B7 D5          	push	de
2107+  49B8 E5          	push	hl
2108+  49B9 CD F4 41    	call	A41F4			; get FAT entry content
2109+  49BC D1          	pop	de
2110+  49BD 7C          	ld	a,h
2111+  49BE FE 0F       	cp	00FH
2112+  49C0 38 05       	jr	c,A49C7
2113+  49C2 7D          	ld	a,l
2114+  49C3 FE F8       	cp	0F8H
2115+  49C5 30 05       	jr	nc,A49CC		; end cluster
2116+  49C7 D1          A49C7:	pop	de
2117+  49C8 13          	inc	de
2118+  49C9 0B          	dec	bc
2119+  49CA 18 E5       	jr	A49B1
2120+  49CC             
2121+  49CC EB          A49CC:	ex	de,hl
2122+  49CD D1          	pop	de
2123+  49CE C9          	ret
2124+  49CF             
2125+  49CF 03          A49CF:	inc	bc			; BC<>0 (means not found)
2126+  49D0 1B          	dec	de
2127+  49D1 C9          	ret
2128+  49D2             
2129+  49D2             ;	Subroutine	read datasector
2130+  49D2             ;	Inputs		
2131+  49D2             ;	Outputs		________________________
2132+  49D2             
2133+  49D2 32 E0 F2    A49D2:	ld	(YF2E0),a
2134+  49D5 2A EC F2    	ld	hl,(YF2EC)		; relative cluster
2135+  49D8 3A DD F2    	ld	a,(YF2DD)		; current relative sector in cluster
2136+  49DB CD DB 4E    	call	A4EDB			; get sectornumber of cluster
2137+  49DE EB          	ex	de,hl
2138+  49DF 2A 3F F2    	ld	hl,(YF23F)
2139+  49E2 ED 52       	sbc	hl,de			; is it currently in the datasector buffer ?
2140+  49E4 20 0A       	jr	nz,A49F0		; nope, get it
2141+  49E6 3A E1 F2    	ld	a,(YF2E1)		; current driveid
2142+  49E9 6F          	ld	l,a
2143+  49EA 3A 41 F2    	ld	a,(YF241)
2144+  49ED BD          	cp	l			; same drive as owner datasector buffer ?
2145+  49EE 28 2B       	jr	z,A4A1B			; yep,
2146+  49F0 D5          A49F0:	push	de
2147+  49F1 DD E5       	push	ix
2148+  49F3 CD 2D 47    	call	A472D			; flush datasector buffer
2149+  49F6 DD E1       	pop	ix
2150+  49F8 D1          	pop	de
2151+  49F9 3A E0 F2    	ld	a,(YF2E0)
2152+  49FC B7          	or	a			; real or fake read ?
2153+  49FD 20 0E       	jr	nz,A4A0D		; fake read
2154+  49FF 3D          	dec	a
2155+  4A00 32 41 F2    	ld	(YF241),a
2156+  4A03 2A 4F F3    	ld	hl,(YF34F)		; datasector buffer
2157+  4A06 06 01       	ld	b,1			; 1 sector
2158+  4A08 D5          	push	de
2159+  4A09 CD C5 46    	call	A46C5			; read sector with DOS error handling
2160+  4A0C D1          	pop	de
2161+  4A0D ED 53 3F F2 A4A0D:	ld	(YF23F),de		; current datasector
2162+  4A11 3A E1 F2    	ld	a,(YF2E1)		; current driveid
2163+  4A14 32 41 F2    	ld	(YF241),a		; set owner datasector buffer
2164+  4A17 DD 22 43 F2 	ld	(YF243),ix		; save DPB pointer
2165+  4A1B 3E 01       A4A1B:	ld	a,1
2166+  4A1D 32 DF F2    	ld	(YF2DF),a		; flag do increase sector
2167+  4A20 2A E2 F2    	ld	hl,(YF2E2)
2168+  4A23 E5          	push	hl
2169+  4A24 ED 4B F8 F2 	ld	bc,(YF2F8)
2170+  4A28 09          	add	hl,bc
2171+  4A29 22 E2 F2    	ld	(YF2E2),hl		; update current transferaddress
2172+  4A2C 2A 4F F3    	ld	hl,(YF34F)		; datasector buffer
2173+  4A2F ED 5B F2 F2 	ld	de,(YF2F2)
2174+  4A33 19          	add	hl,de
2175+  4A34 D1          	pop	de
2176+  4A35 C9          	ret
2177+  4A36             
2178+  4A36             ;	Subroutine	do partical sector read if needed
2179+  4A36             ;	Inputs		
2180+  4A36             ;	Outputs		________________________
2181+  4A36             
2182+  4A36 CD 88 F2    A4A36:	call	XF288
2183+  4A39 2A F8 F2    	ld	hl,(YF2F8)
2184+  4A3C 7C          	ld	a,h
2185+  4A3D B5          	or	l			; partial sector read
2186+  4A3E C8          	ret	z			; nope, quit
2187+  4A3F AF          	xor	a			; real read
2188+  4A40 CD D2 49    	call	A49D2			; read datasector
2189+  4A43 C3 D9 F1    	jp	XF1D9			; transfer to DOS memory
2190+  4A46             
2191+  4A46             ;	Subroutine	handle partial sector write
2192+  4A46             ;	Inputs		
2193+  4A46             ;	Outputs		________________________
2194+  4A46             
2195+  4A46 CD 8B F2    A4A46:	call	XF28B
2196+  4A49 2A F8 F2    	ld	hl,(YF2F8)
2197+  4A4C 7C          	ld	a,h
2198+  4A4D B5          	or	l			; partial start ?
2199+  4A4E C8          	ret	z			; nop, quit
2200+  4A4F 2A EE F2    	ld	hl,(YF2EE)
2201+  4A52 23          	inc	hl
2202+  4A53 22 EE F2    	ld	(YF2EE),hl		; update relative sector of startbyte
2203+  4A56 AF          	xor	a
2204+  4A57 EB          	ex	de,hl
2205+  4A58 2A F0 F2    	ld	hl,(YF2F0)
2206+  4A5B ED 52       	sbc	hl,de			; sector behind end of file ?
2207+  4A5D 1F          	rra				; if yes, fake read
2208+  4A5E CD D2 49    	call	A49D2			; read datasector
2209+  4A61 EB          	ex	de,hl
2210+  4A62 CD D9 F1    	call	XF1D9			; transfer from DOS memory
2211+  4A65 3E 01       	ld	a,1
2212+  4A67 32 42 F2    	ld	(YF242),a		; flag datasector changed
2213+  4A6A C9          	ret
2214+  4A6B             
2215+  4A6B             ;	Subroutine	last partial sector ?
2216+  4A6B             ;	Inputs		
2217+  4A6B             ;	Outputs		________________________
2218+  4A6B             
2219+  4A6B 21 00 00    A4A6B:	ld	hl,0
2220+  4A6E 22 F2 F2    	ld	(YF2F2),hl
2221+  4A71 2A FA F2    	ld	hl,(YF2FA)
2222+  4A74 22 F8 F2    	ld	(YF2F8),hl
2223+  4A77 7C          	ld	a,h
2224+  4A78 B5          	or	l
2225+  4A79 37          	scf
2226+  4A7A C8          	ret	z
2227+  4A7B             
2228+  4A7B             ;	Subroutine	to next sector (only when partical read was done)
2229+  4A7B             ;	Inputs		
2230+  4A7B             ;	Outputs		________________________
2231+  4A7B             
2232+  4A7B 3A DF F2    A4A7B:	ld	a,(YF2DF)
2233+  4A7E B7          	or	a			; flag do not increase
2234+  4A7F C8          	ret	z			; yep, quit
2235+  4A80 3A DD F2    	ld	a,(YF2DD)
2236+  4A83 DD BE 06    	cp	(ix+6)			; clustermask
2237+  4A86 38 1A       	jr	c,A4AA2			; still sectors left in this cluster, increase relative sector in cluster
2238+  4A88 ED 5B EC F2 	ld	de,(YF2EC)		; current cluster of file
2239+  4A8C 21 F7 0F    	ld	hl,00FF7H
2240+  4A8F ED 52       	sbc	hl,de
2241+  4A91 D8          	ret	c			; is the end cluster, quit
2242+  4A92 EB          	ex	de,hl
2243+  4A93 CD F4 41    	call	A41F4			; get FAT entry content
2244+  4A96 22 EC F2    	ld	(YF2EC),hl		; new current cluster of file
2245+  4A99 2A EA F2    	ld	hl,(YF2EA)
2246+  4A9C 23          	inc	hl
2247+  4A9D 22 EA F2    	ld	(YF2EA),hl		; new current relative cluster of file
2248+  4AA0 3E FF       	ld	a,0FFH			; relative sector in cluster 0
2249+  4AA2 3C          A4AA2:	inc	a
2250+  4AA3 32 DD F2    	ld	(YF2DD),a
2251+  4AA6 B7          	or	a
2252+  4AA7 C9          	ret
2253+  4AA8             
2254+  4AA8             ; finish CON read
2255+  4AA8             
2256+  4AA8 7E          A4AA8:	ld	a,(hl)
2257+  4AA9 ED A0       	ldi
2258+  4AAB FE 0D       	cp	00DH
2259+  4AAD 20 02       	jr	nz,A4AB1
2260+  4AAF 36 0A       	ld	(hl),00AH
2261+  4AB1 FE 0A       A4AB1:	cp	00AH
2262+  4AB3 28 15       	jr	z,A4ACA
2263+  4AB5 78          	ld	a,b
2264+  4AB6 B1          	or	c
2265+  4AB7 20 EF       	jr	nz,A4AA8
2266+  4AB9 22 00 F3    A4AB9:	ld	(YF300),hl
2267+  4ABC             
2268+  4ABC             ; finish read record for dos devices
2269+  4ABC             
2270+  4ABC ED 53 E2 F2 A4ABC:	ld	(YF2E2),de		; update current transferaddress
2271+  4AC0 C2 E2 4B    	jp	nz,A4BE2
2272+  4AC3 FD CB 18 B6 	res	6,(iy+24)
2273+  4AC7 C3 E2 4B    	jp	A4BE2
2274+  4ACA             
2275+  4ACA CD A8 53    A4ACA:	call	A53A8			; console output
2276+  4ACD 21 00 00    	ld	hl,00000H
2277+  4AD0 79          	ld	a,c
2278+  4AD1 B0          	or	b
2279+  4AD2 20 25       	jr	nz,A4AF9
2280+  4AD4 3C          	inc	a
2281+  4AD5 18 E2       	jr	A4AB9
2282+  4AD7             
2283+  4AD7             ;	Subroutine	read record for dos devices
2284+  4AD7             ;	Inputs		
2285+  4AD7             ;	Outputs		________________________
2286+  4AD7             
2287+  4AD7 ED 5B E2 F2 A4AD7:	ld	de,(YF2E2)		; current transferaddress
2288+  4ADB 3C          	inc	a
2289+  4ADC 28 14       	jr	z,A4AF2			; CON, handle
2290+  4ADE 3C          	inc	a
2291+  4ADF 20 DB       	jr	nz,A4ABC		; PRN, quit
2292+  4AE1             
2293+  4AE1             ; read record AUX
2294+  4AE1             
2295+  4AE1 CD 6E 54    A4AE1:	call	A546E			; auxiliary input
2296+  4AE4 12          	ld	(de),a
2297+  4AE5 13          	inc	de
2298+  4AE6 FE 1A       	cp	01AH
2299+  4AE8 28 D2       	jr	z,A4ABC			; CTRL-Z, 
2300+  4AEA 0B          	dec	bc
2301+  4AEB 78          	ld	a,b
2302+  4AEC B1          	or	c			; all bytes done ?
2303+  4AED 20 F2       	jr	nz,A4AE1		; nope, next byte
2304+  4AEF 3C          	inc	a
2305+  4AF0 18 CA       	jr	A4ABC
2306+  4AF2             
2307+  4AF2             ; read record CON
2308+  4AF2             
2309+  4AF2 2A 00 F3    A4AF2:	ld	hl,(YF300)
2310+  4AF5 7C          	ld	a,h
2311+  4AF6 B5          	or	l
2312+  4AF7 20 AF       	jr	nz,A4AA8
2313+  4AF9             
2314+  4AF9             ; VERSION 1.1 CHANGE
2315+  4AF9             ; CHANGED, BUGFIX
2316+  4AF9             ; ld hl,128
2317+  4AF9             
2318+  4AF9 21 7F 00    A4AF9:	ld	hl,127
2319+  4AFC 3A D9 F4    	ld	a,(YCONBF+0)
2320+  4AFF BD          	cp	l
2321+  4B00 28 03       	jr	z,A4B05
2322+  4B02 22 D9 F4    	ld	(YCONBF+0),hl
2323+  4B05 C5          A4B05:	push	bc
2324+  4B06 D5          	push	de
2325+  4B07 11 D9 F4    	ld	de,YCONBF
2326+  4B0A CD E0 50    	call	A50E0			; BDOS 0A (buffered console input)
2327+  4B0D D1          	pop	de
2328+  4B0E C1          	pop	bc
2329+  4B0F 21 DB F4    	ld	hl,YCONBF+2
2330+  4B12 7E          	ld	a,(hl)
2331+  4B13 FE 1A       	cp	01AH
2332+  4B15 20 91       	jr	nz,A4AA8
2333+  4B17 12          	ld	(de),a
2334+  4B18 13          	inc	de
2335+  4B19 3E 0A       	ld	a,00AH			; LF
2336+  4B1B CD A8 53    	call	A53A8			; console output
2337+  4B1E AF          	xor	a
2338+  4B1F 67          	ld	h,a
2339+  4B20 6F          	ld	l,a
2340+  4B21 18 96       	jr	A4AB9
2341+  4B23             
2342+  4B23             ;	Subroutine	read record
2343+  4B23             ;	Inputs		DEBC = recordnumber, HL = number of records
2344+  4B23             ;	Outputs		DEHL = last record done, BC = number of records done
2345+  4B23             
2346+  4B23 CD 7D 48    A4B23:	call	A487D			; initialize record info
2347+  4B26 FA D7 4A    	jp	m,A4AD7			; dos device, special action
2348+  4B29 FD 6E 10    	ld	l,(iy+16)
2349+  4B2C FD 66 11    	ld	h,(iy+17)
2350+  4B2F ED 5B F4 F2 	ld	de,(YF2F4+0)
2351+  4B33 B7          	or	a
2352+  4B34 ED 52       	sbc	hl,de
2353+  4B36 E5          	push	hl
2354+  4B37 FD 6E 12    	ld	l,(iy+18)
2355+  4B3A FD 66 13    	ld	h,(iy+19)
2356+  4B3D ED 5B F6 F2 	ld	de,(YF2F4+2)
2357+  4B41 ED 52       	sbc	hl,de
2358+  4B43 E1          	pop	hl
2359+  4B44 DA 97 4C    	jp	c,A4C97			; startbyte behind end of file, quit with nothing done
2360+  4B47 20 0D       	jr	nz,A4B56		; startbyte at least 65536 bytes from the end of file, go get it
2361+  4B49 7C          	ld	a,h
2362+  4B4A B5          	or	l
2363+  4B4B CA 97 4C    	jp	z,A4C97			; startbyte is at end of file, quit with nothing done
2364+  4B4E E5          	push	hl
2365+  4B4F ED 42       	sbc	hl,bc			; requested number of bytes past file ?
2366+  4B51 E1          	pop	hl
2367+  4B52 30 02       	jr	nc,A4B56		; nope, go get it
2368+  4B54 44          	ld	b,h
2369+  4B55 4D          	ld	c,l			; only read number of bytes until the end of file
2370+  4B56 CD 8E F2    A4B56:	call	XF28E
2371+  4B59 CD 53 49    	call	A4953			; calculate partial sector transfers
2372+  4B5C ED 4B EC F2 	ld	bc,(YF2EC)		; relative cluster
2373+  4B60 CD 89 49    	call	A4989			; get absolute cluster
2374+  4B63 78          	ld	a,b
2375+  4B64 B1          	or	c			; found ?
2376+  4B65 C2 97 4C    	jp	nz,A4C97		; nope, quit with nothing done
2377+  4B68 22 EC F2    	ld	(YF2EC),hl		; current cluster = cluster of startbyte
2378+  4B6B ED 53 EA F2 	ld	(YF2EA),de		; current relative cluster = relative cluster of startbyte
2379+  4B6F CD 36 4A    	call	A4A36			; do partical sector read if needed
2380+  4B72 2A FC F2    	ld	hl,(YF2FC)
2381+  4B75 7C          	ld	a,h
2382+  4B76 B5          	or	l
2383+  4B77 CA DC 4B    	jp	z,A4BDC			; not any whole sectors to transfer, to partical end
2384+  4B7A CD 7B 4A    	call	A4A7B			; to next sector (only when partical read was done)
2385+  4B7D 38 63       	jr	c,A4BE2			; there is no next,
2386+  4B7F 3E 01       	ld	a,1
2387+  4B81 32 DF F2    	ld	(YF2DF),a		; flag do increase sector
2388+  4B84 3A DD F2    	ld	a,(YF2DD)		; current relative sector in cluster
2389+  4B87 ED 4B FC F2 	ld	bc,(YF2FC)
2390+  4B8B 2A EC F2    	ld	hl,(YF2EC)		; current cluster of file
2391+  4B8E C5          A4B8E:	push	bc
2392+  4B8F CD 48 4E    	call	A4E48			; calculate sequential sectors
2393+  4B92 C5          	push	bc
2394+  4B93 F5          	push	af
2395+  4B94 47          	ld	b,a
2396+  4B95 CD C5 46    	call	A46C5			; read sectors with DOS error handling
2397+  4B98 F1          	pop	af
2398+  4B99 4F          	ld	c,a
2399+  4B9A 06 00       	ld	b,000H			; number of sectors read
2400+  4B9C 38 23       	jr	c,A4BC1			; sectors read does not include the sector in the datasector buffer
2401+  4B9E 3A 42 F2    	ld	a,(YF242)
2402+  4BA1 B7          	or	a			; datasector buffer changed ?
2403+  4BA2 28 1D       	jr	z,A4BC1			; nope, then no need to transfer the datasector buffer
2404+  4BA4 C5          	push	bc
2405+  4BA5 DD 4E 02    	ld	c,(ix+2)
2406+  4BA8 DD 46 03    	ld	b,(ix+3)		; sectorsize
2407+  4BAB C5          	push	bc
2408+  4BAC E5          	push	hl
2409+  4BAD 2A 3F F2    	ld	hl,(YF23F)		; sectornumber of datasector buffer
2410+  4BB0 ED 52       	sbc	hl,de
2411+  4BB2 EB          	ex	de,hl
2412+  4BB3 CD 16 49    	call	A4916			; multiply
2413+  4BB6 E1          	pop	hl
2414+  4BB7 09          	add	hl,bc
2415+  4BB8 C1          	pop	bc
2416+  4BB9 EB          	ex	de,hl
2417+  4BBA 2A 4F F3    	ld	hl,(YF34F)		; datasector buffer
2418+  4BBD CD D9 F1    	call	XF1D9			; transfer to DOS memory
2419+  4BC0 C1          	pop	bc
2420+  4BC1 D1          A4BC1:	pop	de
2421+  4BC2 E1          	pop	hl
2422+  4BC3 B7          	or	a
2423+  4BC4 ED 42       	sbc	hl,bc			; done all whole sectors ?
2424+  4BC6 28 14       	jr	z,A4BDC			; yep, go partial end
2425+  4BC8 4D          	ld	c,l
2426+  4BC9 44          	ld	b,h
2427+  4BCA 21 F7 0F    	ld	hl,00FF7H
2428+  4BCD ED 52       	sbc	hl,de			; end cluster ?
2429+  4BCF 38 11       	jr	c,A4BE2			; yep, finish without partial end
2430+  4BD1 2A EA F2    	ld	hl,(YF2EA)
2431+  4BD4 23          	inc	hl
2432+  4BD5 22 EA F2    	ld	(YF2EA),hl		; increase current relarive cluster
2433+  4BD8 AF          	xor	a			; current relative sector in cluster = first sector
2434+  4BD9 EB          	ex	de,hl
2435+  4BDA 18 B2       	jr	A4B8E			; again
2436+  4BDC             
2437+  4BDC CD 6B 4A    A4BDC:	call	A4A6B			; last partial sector ?
2438+  4BDF D4 36 4A    	call	nc,A4A36		; yes, do partical sector read if needed
2439+  4BE2 CD 91 F2    A4BE2:	call	XF291
2440+  4BE5 2A E2 F2    	ld	hl,(YF2E2)		; current transferaddress (end)
2441+  4BE8 ED 5B 3D F2 	ld	de,(YF23D)		; transferaddress (begin)
2442+  4BEC B7          	or	a
2443+  4BED ED 52       	sbc	hl,de
2444+  4BEF 4D          	ld	c,l
2445+  4BF0 44          	ld	b,h			; size of transfer
2446+  4BF1 11 80 00    	ld	de,00080H
2447+  4BF4 3A 06 F3    	ld	a,(YF306)
2448+  4BF7 B7          	or	a			; Random Block
2449+  4BF8 20 06       	jr	nz,A4C00		; nope, use 128 bytes recordsize
2450+  4BFA FD 5E 0E    	ld	e,(iy+14)
2451+  4BFD FD 56 0F    	ld	d,(iy+15)		; user recordsize for Random Block
2452+  4C00 CD 2F 49    A4C00:	call	A492F			; how many records ?
2453+  4C03 7C          	ld	a,h
2454+  4C04 B5          	or	l			; partly records ?
2455+  4C05 28 10       	jr	z,A4C17			; nop,
2456+  4C07 03          	inc	bc			; records +1
2457+  4C08 EB          	ex	de,hl
2458+  4C09 ED 52       	sbc	hl,de			; 'missed' bytes
2459+  4C0B ED 5B E2 F2 	ld	de,(YF2E2)
2460+  4C0F AF          A4C0F:	xor	a
2461+  4C10 12          	ld	(de),a
2462+  4C11 13          	inc	de
2463+  4C12 2B          	dec	hl
2464+  4C13 7C          	ld	a,h
2465+  4C14 B5          	or	l
2466+  4C15 20 F8       	jr	nz,A4C0F		; clear 'missed' bytes
2467+  4C17 2A E8 F2    A4C17:	ld	hl,(YF2E8)		; number of records requested
2468+  4C1A ED 42       	sbc	hl,bc
2469+  4C1C 28 04       	jr	z,A4C22			; all done,
2470+  4C1E 3C          	inc	a
2471+  4C1F 32 DE F2    	ld	(YF2DE),a		; error in record operation
2472+  4C22 CD 94 F2    A4C22:	call	XF294
2473+  4C25 2A EC F2    	ld	hl,(YF2EC)
2474+  4C28 FD 75 1C    	ld	(iy+28),l
2475+  4C2B FD 74 1D    	ld	(iy+29),h		; current cluster of file FCB
2476+  4C2E 2A EA F2    	ld	hl,(YF2EA)
2477+  4C31 FD 75 1E    	ld	(iy+30),l
2478+  4C34 FD 74 1F    	ld	(iy+31),h		; current relative cluster of file FCB
2479+  4C37 2A E4 F2    A4C37:	ld	hl,(YF2E4+0)
2480+  4C3A ED 5B E6 F2 	ld	de,(YF2E4+2)		; startrecord
2481+  4C3E 78          	ld	a,b
2482+  4C3F B1          	or	c			; done any records ?
2483+  4C40 C8          	ret	z			; nope, quit
2484+  4C41 0B          	dec	bc
2485+  4C42 09          	add	hl,bc
2486+  4C43 03          	inc	bc
2487+  4C44 D0          	ret	nc
2488+  4C45 13          	inc	de			; return current record
2489+  4C46 C9          	ret
2490+  4C47             
2491+  4C47             ;	Subroutine	write record for dos devices
2492+  4C47             ;	Inputs		
2493+  4C47             ;	Outputs		________________________
2494+  4C47             
2495+  4C47 2A 3D F2    A4C47:	ld	hl,(YF23D)		; transferaddress
2496+  4C4A F6 40       	or	040H
2497+  4C4C 3C          	inc	a
2498+  4C4D 28 24       	jr	z,A4C73			; CON, handle
2499+  4C4F 3C          	inc	a
2500+  4C50 28 11       	jr	z,A4C63			; AUX, handle
2501+  4C52 3C          	inc	a
2502+  4C53 28 2C       A4C53:	jr	z,A4C81			; NUL, handle
2503+  4C55             
2504+  4C55 7E          	ld	a,(hl)
2505+  4C56 23          	inc	hl
2506+  4C57 FE 1A       	cp	01AH
2507+  4C59 28 26       	jr	z,A4C81
2508+  4C5B CD 66 54    	call	A5466			; printer output
2509+  4C5E 0B          	dec	bc
2510+  4C5F 78          	ld	a,b
2511+  4C60 B1          	or	c
2512+  4C61 18 F0       	jr	A4C53
2513+  4C63             
2514+  4C63 7E          A4C63:	ld	a,(hl)
2515+  4C64 23          	inc	hl
2516+  4C65 CD 75 54    	call	A5475			; auxiliary output
2517+  4C68 FE 1A       	cp	01AH
2518+  4C6A 28 15       	jr	z,A4C81
2519+  4C6C 0B          	dec	bc
2520+  4C6D 78          	ld	a,b
2521+  4C6E B1          	or	c
2522+  4C6F 20 F2       	jr	nz,A4C63
2523+  4C71 18 0E       	jr	A4C81
2524+  4C73             
2525+  4C73 7E          A4C73:	ld	a,(hl)
2526+  4C74 23          	inc	hl
2527+  4C75 FE 1A       	cp	01AH
2528+  4C77 28 08       	jr	z,A4C81
2529+  4C79 CD A8 53    	call	A53A8			; console output
2530+  4C7C 0B          	dec	bc
2531+  4C7D 78          	ld	a,b
2532+  4C7E B1          	or	c
2533+  4C7F 20 F2       	jr	nz,A4C73
2534+  4C81 ED 4B E8 F2 A4C81:	ld	bc,(YF2E8)		; no. of records
2535+  4C85 18 B0       	jr	A4C37
2536+  4C87             
2537+  4C87 4B          A4C87:	ld	c,e
2538+  4C88 42          	ld	b,d			; clusters to skip
2539+  4C89 CD B1 49    	call	A49B1			; get next absolute cluster
2540+  4C8C 78          	ld	a,b
2541+  4C8D B1          	or	c			; found ?
2542+  4C8E CA 41 4D    	jp	z,A4D41			; yep,
2543+  4C91 CD 12 4F    	call	A4F12			; allocate cluster chain
2544+  4C94 D2 41 4D    	jp	nc,A4D41		; ok, go writing
2545+  4C97             
2546+  4C97 CD 97 F2    A4C97:	call	XF297
2547+  4C9A AF          	xor	a
2548+  4C9B 4F          	ld	c,a
2549+  4C9C 47          	ld	b,a			; no records read/write
2550+  4C9D 3C          	inc	a
2551+  4C9E 32 DE F2    	ld	(YF2DE),a		; error in record operation
2552+  4CA1 18 94       	jr	A4C37
2553+  4CA3             
2554+  4CA3             ;	Subroutine	write record
2555+  4CA3             ;	Inputs		DEBC = recordnumber, HL = number of records
2556+  4CA3             ;	Outputs		________________________
2557+  4CA3             
2558+  4CA3 CD 7D 48    A4CA3:	call	A487D			; initialize record info
2559+  4CA6 F5          	push	af
2560+  4CA7 C5          	push	bc
2561+  4CA8 CD 96 54    	call	A5496			; get time and date (dirformat)
2562+  4CAB FD 71 14    	ld	(iy+20),c
2563+  4CAE FD 70 15    	ld	(iy+21),b
2564+  4CB1 FD 73 16    	ld	(iy+22),e
2565+  4CB4 FD 72 17    	ld	(iy+23),d
2566+  4CB7 C1          	pop	bc
2567+  4CB8 F1          	pop	af
2568+  4CB9 FA 47 4C    	jp	m,A4C47			; DOS device, special action
2569+  4CBC FD CB 18 B6 	res	6,(iy+24)		; flag FCB changed
2570+  4CC0 C5          	push	bc
2571+  4CC1 CD 53 49    	call	A4953			; calculate partical sector transfers
2572+  4CC4 C1          	pop	bc
2573+  4CC5 2A F4 F2    	ld	hl,(YF2F4+0)
2574+  4CC8 ED 5B F6 F2 	ld	de,(YF2F4+2)		; startbyte
2575+  4CCC 78          	ld	a,b
2576+  4CCD B1          	or	c			; zero bytes to write (only possible with Random Block) ?
2577+  4CCE CA DD 4D    	jp	z,A4DDD			; yep, filesize adjust action
2578+  4CD1 0B          	dec	bc
2579+  4CD2 09          	add	hl,bc
2580+  4CD3 30 01       	jr	nc,A4CD6
2581+  4CD5 13          	inc	de			; endbyte
2582+  4CD6 44          A4CD6:	ld	b,h
2583+  4CD7 4D          	ld	c,l
2584+  4CD8 EB          	ex	de,hl
2585+  4CD9 DD 5E 02    	ld	e,(ix+2)
2586+  4CDC DD 56 03    	ld	d,(ix+3)
2587+  4CDF CD 32 49    	call	A4932			; / sectorsize
2588+  4CE2 60          	ld	h,b
2589+  4CE3 69          	ld	l,c			; relative sector of endbyte
2590+  4CE4 DD 46 07    	ld	b,(ix+7)		; clustershift
2591+  4CE7 05          	dec	b
2592+  4CE8 28 06       	jr	z,A4CF0
2593+  4CEA CB 3C       A4CEA:	srl	h
2594+  4CEC CB 1D       	rr	l
2595+  4CEE 10 FA       	djnz	A4CEA			; relative cluster of endbyte
2596+  4CF0 E5          A4CF0:	push	hl
2597+  4CF1 FD 4E 10    	ld	c,(iy+16)
2598+  4CF4 FD 46 11    	ld	b,(iy+17)
2599+  4CF7 FD 6E 12    	ld	l,(iy+18)
2600+  4CFA FD 66 13    	ld	h,(iy+19)		; filesize
2601+  4CFD CD 32 49    	call	A4932			; / sectorsize
2602+  4D00 7C          	ld	a,h
2603+  4D01 B5          	or	l			; offset in sector
2604+  4D02 28 01       	jr	z,A4D05
2605+  4D04 03          	inc	bc			; relative sector
2606+  4D05 CD 9A F2    A4D05:	call	XF29A
2607+  4D08 ED 43 F0 F2 	ld	(YF2F0),bc		; relative sector behind fileend
2608+  4D0C ED 4B EC F2 	ld	bc,(YF2EC)		; relative cluster of startbyte
2609+  4D10 CD 89 49    	call	A4989			; get absolute cluster
2610+  4D13 22 EC F2    	ld	(YF2EC),hl		; current cluster = cluster of startbyte
2611+  4D16 ED 53 EA F2 	ld	(YF2EA),de		; current relative cluster = relative cluster of startbyte
2612+  4D1A E3          	ex	(sp),hl
2613+  4D1B B7          	or	a
2614+  4D1C ED 52       	sbc	hl,de			; start and endbyte in same cluster ?
2615+  4D1E EB          	ex	de,hl
2616+  4D1F E1          	pop	hl
2617+  4D20 28 1F       	jr	z,A4D41			; yep,
2618+  4D22 78          	ld	a,b
2619+  4D23 B1          	or	c			; is cluster of startbyte found ?
2620+  4D24 CA 87 4C    	jp	z,A4C87			; yep, make chain to cluster of endbyte if needed and start writing
2621+  4D27 C5          	push	bc
2622+  4D28 4B          	ld	c,e
2623+  4D29 42          	ld	b,d			; clusters to allocate
2624+  4D2A CD 12 4F    	call	A4F12			; allocate cluster chain
2625+  4D2D C1          	pop	bc
2626+  4D2E DA 97 4C    	jp	c,A4C97			; failed, quit with nothing done
2627+  4D31 ED 5B EA F2 	ld	de,(YF2EA)
2628+  4D35 13          	inc	de			; relative cluster to start
2629+  4D36 0B          	dec	bc			; clusters to skip
2630+  4D37 CD B1 49    	call	A49B1			; get next absolute cluster
2631+  4D3A 22 EC F2    	ld	(YF2EC),hl		; cluster of startbyte
2632+  4D3D ED 53 EA F2 	ld	(YF2EA),de		; relative cluster of startbyte
2633+  4D41 CD 46 4A    A4D41:	call	A4A46			; handle partial sector write
2634+  4D44 2A FC F2    	ld	hl,(YF2FC)
2635+  4D47 7C          	ld	a,h
2636+  4D48 B5          	or	l			; any complete sectors ?
2637+  4D49 28 41       	jr	z,A4D8C			; nope, goto partial end
2638+  4D4B ED 5B EE F2 	ld	de,(YF2EE)
2639+  4D4F 19          	add	hl,de
2640+  4D50 22 EE F2    	ld	(YF2EE),hl		; update relative sector of startbyte
2641+  4D53 CD 7B 4A    	call	A4A7B			; to the next sector (only when partial write was done)
2642+  4D56 3E 01       	ld	a,1
2643+  4D58 32 DF F2    	ld	(YF2DF),a		; flag do increase sector
2644+  4D5B 3A DD F2    	ld	a,(YF2DD)		; current relative sector in cluster
2645+  4D5E 2A EC F2    	ld	hl,(YF2EC)		; relative cluster
2646+  4D61 ED 4B FC F2 	ld	bc,(YF2FC)		; whole sectors
2647+  4D65 C5          A4D65:	push	bc
2648+  4D66 CD 48 4E    	call	A4E48			; calculate sequencial sectors
2649+  4D69 C5          	push	bc
2650+  4D6A F5          	push	af
2651+  4D6B 47          	ld	b,a
2652+  4D6C 38 05       	jr	c,A4D73			; sectors writen does not include the sector in the datasector buffer
2653+  4D6E 3E FF       	ld	a,0FFH
2654+  4D70 32 41 F2    	ld	(YF241),a		; invalid datasector buffer
2655+  4D73 CD 55 47    A4D73:	call	A4755			; write datasectors with DOS error handling
2656+  4D76 F1          	pop	af
2657+  4D77 D1          	pop	de
2658+  4D78 E1          	pop	hl
2659+  4D79 4F          	ld	c,a
2660+  4D7A AF          	xor	a
2661+  4D7B 47          	ld	b,a
2662+  4D7C ED 42       	sbc	hl,bc			; whole sectors left ?
2663+  4D7E 28 0C       	jr	z,A4D8C			; nop, go to partial end
2664+  4D80 4D          	ld	c,l
2665+  4D81 44          	ld	b,h
2666+  4D82 2A EA F2    	ld	hl,(YF2EA)
2667+  4D85 23          	inc	hl
2668+  4D86 22 EA F2    	ld	(YF2EA),hl		; update relative cluster
2669+  4D89 EB          	ex	de,hl
2670+  4D8A 18 D9       	jr	A4D65			; again
2671+  4D8C             
2672+  4D8C CD 9D F2    A4D8C:	call	XF29D
2673+  4D8F CD 6B 4A    	call	A4A6B			; last partial sector ?
2674+  4D92 D4 46 4A    	call	nc,A4A46		; partial end, handle partial sector write
2675+  4D95 2A E2 F2    	ld	hl,(YF2E2)		; current transferaddress
2676+  4D98 ED 5B 3D F2 	ld	de,(YF23D)		; transferaddress
2677+  4D9C B7          	or	a
2678+  4D9D ED 52       	sbc	hl,de
2679+  4D9F ED 5B F4 F2 	ld	de,(YF2F4+0)
2680+  4DA3 19          	add	hl,de
2681+  4DA4 ED 5B F6 F2 	ld	de,(YF2F4+2)
2682+  4DA8 30 01       	jr	nc,A4DAB
2683+  4DAA 13          	inc	de
2684+  4DAB 22 F4 F2    A4DAB:	ld	(YF2F4+0),hl
2685+  4DAE ED 53 F6 F2 	ld	(YF2F4+2),de		; startbyte = startbyte + transfersize
2686+  4DB2 FD 4E 10    	ld	c,(iy+16)
2687+  4DB5 FD 46 11    	ld	b,(iy+17)
2688+  4DB8 B7          	or	a
2689+  4DB9 ED 42       	sbc	hl,bc
2690+  4DBB FD 4E 12    	ld	c,(iy+18)
2691+  4DBE FD 46 13    	ld	b,(iy+19)
2692+  4DC1 EB          	ex	de,hl
2693+  4DC2 ED 42       	sbc	hl,bc			; has file expanded ?
2694+  4DC4 38 10       	jr	c,A4DD6			; nop,
2695+  4DC6 FD E5       A4DC6:	push	iy
2696+  4DC8 E1          	pop	hl
2697+  4DC9 11 10 00    	ld	de,00010H
2698+  4DCC 19          	add	hl,de
2699+  4DCD EB          	ex	de,hl
2700+  4DCE 21 F4 F2    	ld	hl,YF2F4		; filelength = endbyte
2701+  4DD1 01 04 00    	ld	bc,4
2702+  4DD4 ED B0       	ldir
2703+  4DD6 ED 4B E8 F2 A4DD6:	ld	bc,(YF2E8)		; no. of records
2704+  4DDA C3 22 4C    	jp	A4C22
2705+  4DDD             
2706+  4DDD             ; filesize adjust
2707+  4DDD             
2708+  4DDD 7C          A4DDD:	ld	a,h
2709+  4DDE B5          	or	l
2710+  4DDF B2          	or	d
2711+  4DE0 B3          	or	e			; startbyte zero ?
2712+  4DE1 28 4F       	jr	z,A4E32			; yep, kill chain and quit
2713+  4DE3 01 01 00    	ld	bc,1
2714+  4DE6 ED 42       	sbc	hl,bc
2715+  4DE8 EB          	ex	de,hl
2716+  4DE9 0B          	dec	bc
2717+  4DEA ED 42       	sbc	hl,bc
2718+  4DEC 42          	ld	b,d
2719+  4DED 4B          	ld	c,e			; filesize = startbyte-1
2720+  4DEE DD 5E 02    	ld	e,(ix+2)
2721+  4DF1 DD 56 03    	ld	d,(ix+3)
2722+  4DF4 CD 32 49    	call	A4932			; / sectorsize
2723+  4DF7 DD 7E 07    	ld	a,(ix+7)		; clustershift
2724+  4DFA 3D          A4DFA:	dec	a
2725+  4DFB 28 06       	jr	z,A4E03
2726+  4DFD CB 38       	srl	b
2727+  4DFF CB 19       	rr	c
2728+  4E01 18 F7       	jr	A4DFA
2729+  4E03             
2730+  4E03 CD 89 49    A4E03:	call	A4989			; get absolute cluster
2731+  4E06 78          	ld	a,b
2732+  4E07 B1          	or	c			; found ?
2733+  4E08 28 1C       	jr	z,A4E26			; yep, this means chain must be shortend
2734+  4E0A CD 12 4F    	call	A4F12			; allocate cluster chain
2735+  4E0D DA 97 4C    	jp	c,A4C97			; failed, quit with nothing done
2736+  4E10 01 00 00    A4E10:	ld	bc,0
2737+  4E13 ED 43 E8 F2 	ld	(YF2E8),bc		; number of records = 0
2738+  4E17 ED 43 EA F2 	ld	(YF2EA),bc		; current relative cluster = 0
2739+  4E1B FD 6E 1A    	ld	l,(iy+26)
2740+  4E1E FD 66 1B    	ld	h,(iy+27)		; start cluster of file
2741+  4E21 22 EC F2    	ld	(YF2EC),hl		; current cluster = start cluster of file
2742+  4E24 18 A0       	jr	A4DC6
2743+  4E26             
2744+  4E26 01 FF 0F    A4E26:	ld	bc,00FFFH
2745+  4E29 CD 9E 4F    	call	A4F9E			; mark end & release rest chain
2746+  4E2C 1B          A4E2C:	dec	de
2747+  4E2D             
2748+  4E2D             ; VERSION 1.1 CHANGE
2749+  4E2D             ; CHANGED, BUGFIX
2750+  4E2D             ; ld a,0FFH
2751+  4E2D             
2752+  4E2D 3E 01       	ld	a,1
2753+  4E2F 12          	ld	(de),a			; flag FAT buffer changed
2754+  4E30 18 DE       	jr	A4E10
2755+  4E32             
2756+  4E32 FD 6E 1A    A4E32:	ld	l,(iy+26)
2757+  4E35 FD 66 1B    	ld	h,(iy+27)
2758+  4E38 7C          	ld	a,h
2759+  4E39 B5          	or	l			; file has start cluster ?
2760+  4E3A 28 D4       	jr	z,A4E10			; nop,
2761+  4E3C AF          	xor	a
2762+  4E3D FD 77 1A    	ld	(iy+26),a
2763+  4E40 FD 77 1B    	ld	(iy+27),a		; file has no start cluster (empty file)
2764+  4E43 CD 9B 4F    	call	A4F9B			; release cluster chain
2765+  4E46 18 E4       	jr	A4E2C			; mark FAT buffer changed
2766+  4E48             
2767+  4E48             ;	Subroutine	calculate sequencial sectors
2768+  4E48             ;	Inputs		
2769+  4E48             ;	Outputs		________________________
2770+  4E48             
2771+  4E48 CD A0 F2    A4E48:	call	XF2A0
2772+  4E4B 57          	ld	d,a
2773+  4E4C E5          	push	hl
2774+  4E4D 04          	inc	b
2775+  4E4E 05          	dec	b
2776+  4E4F 28 02       	jr	z,A4E53
2777+  4E51 0E FF       	ld	c,0FFH
2778+  4E53 59          A4E53:	ld	e,c
2779+  4E54 D5          	push	de
2780+  4E55 DD 7E 06    	ld	a,(ix+6)		; clustermask
2781+  4E58 32 DD F2    	ld	(YF2DD),a		; current relative sector in cluster
2782+  4E5B 3C          	inc	a
2783+  4E5C 92          	sub	d
2784+  4E5D 47          	ld	b,a
2785+  4E5E 22 EC F2    A4E5E:	ld	(YF2EC),hl
2786+  4E61 E5          	push	hl
2787+  4E62 CD F4 41    	call	A41F4			; get FAT entry content
2788+  4E65 D1          	pop	de
2789+  4E66 79          	ld	a,c
2790+  4E67 90          	sub	b
2791+  4E68 4F          	ld	c,a
2792+  4E69 28 0D       	jr	z,A4E78
2793+  4E6B DD 46 06    	ld	b,(ix+6)		; clustermask
2794+  4E6E 38 5A       	jr	c,A4ECA
2795+  4E70 04          	inc	b
2796+  4E71 13          	inc	de
2797+  4E72 EB          	ex	de,hl
2798+  4E73 ED 52       	sbc	hl,de
2799+  4E75 EB          	ex	de,hl
2800+  4E76 28 E6       	jr	z,A4E5E
2801+  4E78 D1          A4E78:	pop	de
2802+  4E79 E3          	ex	(sp),hl
2803+  4E7A E5          	push	hl
2804+  4E7B D5          	push	de
2805+  4E7C 7B          	ld	a,e
2806+  4E7D 91          	sub	c
2807+  4E7E 5F          	ld	e,a
2808+  4E7F 16 00       	ld	d,000H
2809+  4E81 DD 4E 02    	ld	c,(ix+2)
2810+  4E84 DD 46 03    	ld	b,(ix+3)		; sectorsize
2811+  4E87 CD 16 49    	call	A4916			; multiply
2812+  4E8A F1          	pop	af
2813+  4E8B 2A E2 F2    	ld	hl,(YF2E2)
2814+  4E8E E5          	push	hl
2815+  4E8F 09          	add	hl,bc
2816+  4E90 22 E2 F2    	ld	(YF2E2),hl		; update current transferaddress
2817+  4E93 C1          	pop	bc
2818+  4E94 E1          	pop	hl
2819+  4E95 C5          	push	bc
2820+  4E96 D5          	push	de
2821+  4E97 EB          	ex	de,hl
2822+  4E98 2A EC F2    	ld	hl,(YF2EC)
2823+  4E9B ED 52       	sbc	hl,de
2824+  4E9D ED 4B EA F2 	ld	bc,(YF2EA)
2825+  4EA1 09          	add	hl,bc
2826+  4EA2 22 EA F2    	ld	(YF2EA),hl
2827+  4EA5 EB          	ex	de,hl
2828+  4EA6 CD DB 4E    	call	A4EDB			; get sectornumber of cluster
2829+  4EA9 EB          	ex	de,hl
2830+  4EAA C1          	pop	bc
2831+  4EAB 3A 41 F2    	ld	a,(YF241)
2832+  4EAE DD BE 00    	cp	(ix+0)			; driveid
2833+  4EB1 79          	ld	a,c
2834+  4EB2 37          	scf
2835+  4EB3 20 12       	jr	nz,A4EC7
2836+  4EB5 2A 3F F2    	ld	hl,(YF23F)		; sectornumber of datasector buffer
2837+  4EB8 B7          	or	a
2838+  4EB9 ED 52       	sbc	hl,de
2839+  4EBB 38 0A       	jr	c,A4EC7
2840+  4EBD 60          	ld	h,b
2841+  4EBE 69          	ld	l,c
2842+  4EBF 19          	add	hl,de
2843+  4EC0 2B          	dec	hl
2844+  4EC1 ED 4B 3F F2 	ld	bc,(YF23F)		; sectornumber of datasector buffer
2845+  4EC5 ED 42       	sbc	hl,bc
2846+  4EC7 E1          A4EC7:	pop	hl
2847+  4EC8 C1          	pop	bc
2848+  4EC9 C9          	ret
2849+  4ECA             
2850+  4ECA 80          A4ECA:	add	a,b
2851+  4ECB 32 DD F2    	ld	(YF2DD),a		; current relative sector in cluster
2852+  4ECE 0E 00       	ld	c,000H
2853+  4ED0 18 A6       	jr	A4E78
2854+  4ED2             
2855+  4ED2             ;	Subroutine	get decoded characterpair (not needed, uses for secret message)
2856+  4ED2             ;	Inputs		
2857+  4ED2             ;	Outputs		________________________
2858+  4ED2             
2859+  4ED2 CD FA 41    A4ED2:	call	A41FA
2860+  4ED5 7D          	ld	a,l
2861+  4ED6 29          	add	hl,hl
2862+  4ED7 29          	add	hl,hl			; second char in H
2863+  4ED8 E6 3F       	and	03FH			; first char in A
2864+  4EDA C9          	ret
2865+  4EDB             
2866+  4EDB             ;	Subroutine	get sectornumber of cluster
2867+  4EDB             ;	Inputs		HL = cluster, A = relative sector in cluster
2868+  4EDB             ;	Outputs		HL = sectornumber
2869+  4EDB             
2870+  4EDB CD A3 F2    A4EDB:	call	XF2A3
2871+  4EDE C5          	push	bc
2872+  4EDF DD 46 07    	ld	b,(ix+7)		; clustershift
2873+  4EE2 2B          	dec	hl
2874+  4EE3 2B          	dec	hl
2875+  4EE4 05          	dec	b
2876+  4EE5 28 06       	jr	z,A4EED
2877+  4EE7 CB 25       A4EE7:	sla	l
2878+  4EE9 CB 14       	rl	h
2879+  4EEB 10 FA       	djnz	A4EE7
2880+  4EED B5          A4EED:	or	l
2881+  4EEE 6F          	ld	l,a
2882+  4EEF DD 4E 0C    	ld	c,(ix+12)
2883+  4EF2 DD 46 0D    	ld	b,(ix+13)
2884+  4EF5 09          	add	hl,bc			; + first datasector
2885+  4EF6 C1          	pop	bc
2886+  4EF7 C9          	ret
2887+  4EF8             
2888+  4EF8             ;	Subroutine	get recordnumber from S2,EX and CR fields
2889+  4EF8             ;	Inputs		
2890+  4EF8             ;	Outputs		________________________
2891+  4EF8             
2892+  4EF8 D5          A4EF8:	push	de
2893+  4EF9 FD E1       	pop	iy
2894+  4EFB FD 4E 20    	ld	c,(iy+32)		; CR (current record)
2895+  4EFE FD 46 0C    	ld	b,(iy+12)		; EX (extent)
2896+  4F01 FD 5E 0E    	ld	e,(iy+14)		; S2
2897+  4F04 16 00       	ld	d,0
2898+  4F06 CB 21       	sla	c
2899+  4F08 CB 3B       	srl	e
2900+  4F0A CB 18       	rr	b
2901+  4F0C CB 19       	rr	c			; debc = recordnumber
2902+  4F0E 21 01 00    	ld	hl,1			; 1 record
2903+  4F11 C9          	ret
2904+  4F12             
2905+  4F12             ;	Subroutine	allocate cluster chain
2906+  4F12             ;	Inputs		
2907+  4F12             ;	Outputs		________________________
2908+  4F12             
2909+  4F12 CD A6 F2    A4F12:	call	XF2A6
2910+  4F15 DD 5E 13    	ld	e,(ix+19)
2911+  4F18 DD 56 14    	ld	d,(ix+20)
2912+  4F1B EB          	ex	de,hl			; pointer to FAT buffer of drive
2913+  4F1C 7E          	ld	a,(hl)
2914+  4F1D 23          	inc	hl
2915+  4F1E 66          	ld	h,(hl)
2916+  4F1F 6F          	ld	l,a			; pointer to FAT
2917+  4F20 E5          	push	hl
2918+  4F21 EB          	ex	de,hl
2919+  4F22 DD 5E 0E    	ld	e,(ix+14)
2920+  4F25 DD 56 0F    	ld	d,(ix+15)		; Max cluster
2921+  4F28 ED 53 02 F3 	ld	(YF302),de		; store
2922+  4F2C E5          	push	hl
2923+  4F2D C5          A4F2D:	push	bc			; clusters to allocate
2924+  4F2E E5          	push	hl			; start cluster
2925+  4F2F 54          	ld	d,h
2926+  4F30 5D          	ld	e,l
2927+  4F31 D5          A4F31:	push	de
2928+  4F32 EB          	ex	de,hl
2929+  4F33 2A 02 F3    	ld	hl,(YF302)
2930+  4F36 2B          	dec	hl
2931+  4F37 B7          	or	a
2932+  4F38 ED 52       	sbc	hl,de
2933+  4F3A EB          	ex	de,hl			; last cluster on disk ?
2934+  4F3B D1          	pop	de
2935+  4F3C 30 10       	jr	nc,A4F4E		; nop, go up
2936+  4F3E 7B          	ld	a,e
2937+  4F3F B2          	or	d			; search below finished ?
2938+  4F40 20 14       	jr	nz,A4F56		; nop, go below
2939+  4F42 E1          	pop	hl
2940+  4F43 E1          	pop	hl
2941+  4F44 E1          	pop	hl
2942+  4F45 01 FF 0F    	ld	bc,00FFFH
2943+  4F48 CD 9E 4F    	call	A4F9E			; mark end & release rest chain
2944+  4F4B 37          	scf
2945+  4F4C 18 46       	jr	A4F94
2946+  4F4E             
2947+  4F4E 23          A4F4E:	inc	hl
2948+  4F4F CD 5E 4F    	call	A4F5E			; try to allocate
2949+  4F52 7B          	ld	a,e			; nop not free !
2950+  4F53 B2          	or	d			; search below finished ?
2951+  4F54 28 DB       	jr	z,A4F31			; try again (up)
2952+  4F56 1B          A4F56:	dec	de
2953+  4F57 EB          	ex	de,hl
2954+  4F58 CD 5E 4F    	call	A4F5E			; try to allocate
2955+  4F5B EB          	ex	de,hl			; nop not free !
2956+  4F5C 18 D3       	jr	A4F31			; try again
2957+  4F5E             
2958+  4F5E             ;	Subroutine	allocate cluster if free
2959+  4F5E             ;	Inputs		
2960+  4F5E             ;	Outputs		________________________
2961+  4F5E             
2962+  4F5E E5          A4F5E:	push	hl
2963+  4F5F D5          	push	de
2964+  4F60 CD F4 41    	call	A41F4			; cluster free ?
2965+  4F63 D1          	pop	de
2966+  4F64 E1          	pop	hl
2967+  4F65 C0          	ret	nz			; nop, no alloc
2968+  4F66 C1          	pop	bc
2969+  4F67 4D          	ld	c,l
2970+  4F68 44          	ld	b,h
2971+  4F69 E3          	ex	(sp),hl
2972+  4F6A DD 5E 13    	ld	e,(ix+19)
2973+  4F6D DD 56 14    	ld	d,(ix+20)		; pointer to FAT buffer of drive
2974+  4F70 CD 21 42    	call	A4221			; set FAT entry content
2975+  4F73 E1          	pop	hl
2976+  4F74 C1          	pop	bc
2977+  4F75 0B          	dec	bc
2978+  4F76 78          	ld	a,b
2979+  4F77 B1          	or	c
2980+  4F78 20 B3       	jr	nz,A4F2D
2981+  4F7A 01 FF 0F    	ld	bc,00FFFH		; chain endmarker
2982+  4F7D CD 21 42    	call	A4221			; set FAT entry content
2983+  4F80 1B          	dec	de
2984+  4F81 3E 01       	ld	a,1
2985+  4F83 12          	ld	(de),a			; FAT changed
2986+  4F84 E1          	pop	hl
2987+  4F85 E5          	push	hl
2988+  4F86 CD F4 41    	call	A41F4			; get FAT entry content
2989+  4F89 C1          	pop	bc
2990+  4F8A 79          	ld	a,c
2991+  4F8B B0          	or	b
2992+  4F8C 20 06       	jr	nz,A4F94
2993+  4F8E FD 75 1A    	ld	(iy+26),l
2994+  4F91 FD 74 1B    	ld	(iy+27),h		; start cluster of file
2995+  4F94 EB          A4F94:	ex	de,hl
2996+  4F95 C1          	pop	bc
2997+  4F96 71          	ld	(hl),c
2998+  4F97 23          	inc	hl
2999+  4F98 70          	ld	(hl),b
3000+  4F99 EB          	ex	de,hl
3001+  4F9A C9          	ret
3002+  4F9B             
3003+  4F9B             ;	Subroutine	release cluster chain
3004+  4F9B             ;	Inputs		
3005+  4F9B             ;	Outputs		________________________
3006+  4F9B             
3007+  4F9B 01 00 00    A4F9B:	ld	bc,0
3008+  4F9E             
3009+  4F9E             ;	Subroutine	set cluster entry and release rest of cluster chain
3010+  4F9E             ;	Inputs		
3011+  4F9E             ;	Outputs		________________________
3012+  4F9E             
3013+  4F9E CD A9 F2    A4F9E:	call	XF2A9
3014+  4FA1 E5          	push	hl
3015+  4FA2 CD F4 41    	call	A41F4			; get FAT entry content
3016+  4FA5 E3          	ex	(sp),hl
3017+  4FA6 CD 21 42    	call	A4221			; set FAT entry content
3018+  4FA9 E1          	pop	hl
3019+  4FAA 7C          	ld	a,h
3020+  4FAB B5          	or	l
3021+  4FAC C8          	ret	z
3022+  4FAD 7C          	ld	a,h
3023+  4FAE FE 0F       	cp	00FH
3024+  4FB0 38 E9       	jr	c,A4F9B
3025+  4FB2 7D          	ld	a,l
3026+  4FB3 FE F8       	cp	0F8H
3027+  4FB5 38 E4       	jr	c,A4F9B 		; not end of chain, release
3028+  4FB7 C9          	ret
3029+  4FB8             
3030+  4FB8             ;	Subroutine	BDOS 11 (search for first)
3031+  4FB8             ;	Inputs		
3032+  4FB8             ;	Outputs		________________________
3033+  4FB8             
3034+  4FB8 CD A5 42    A4FB8:	call	A42A5			; validate FCB, clear S2 and find direntry
3035+  4FBB 38 43       A4FBB:	jr	c,A5000			; error, quit
3036+  4FBD 3A B8 F2    	ld	a,(YF2B8)
3037+  4FC0 28 02       	jr	z,A4FC4			; file, save direntry number for search next
3038+  4FC2 3E FF       	ld	a,0FFH			; device, flag search next invalid
3039+  4FC4 32 0B F3    A4FC4:	ld	(YF30B),a
3040+  4FC7 DD 22 09 F3 	ld	(YF309),ix		; save pointer to DPB
3041+  4FCB ED 5B 3D F2 	ld	de,(YF23D)		; transferaddress
3042+  4FCF 3A E1 F2    	ld	a,(YF2E1)		; current driveid
3043+  4FD2 3C          	inc	a
3044+  4FD3 12          	ld	(de),a
3045+  4FD4 13          	inc	de
3046+  4FD5 7E          	ld	a,(hl)
3047+  4FD6 FE 05       	cp	005H
3048+  4FD8 20 02       	jr	nz,A4FDC
3049+  4FDA 36 E5       	ld	(hl),0E5H
3050+  4FDC 01 20 00    A4FDC:	ld	bc,32
3051+  4FDF CD D9 F1    	call	XF1D9			; transfer direntry to DOS memory (?? LDIR is also sufficient)
3052+  4FE2 CD 39 44    	call	A4439			; get max record and extent
3053+  4FE5 3A 0C F3    	ld	a,(YF30C)
3054+  4FE8 B8          	cp	b			; orginal FCB EX byte same as max extent ?
3055+  4FE9 28 04       	jr	z,A4FEF			; same, RC = max record
3056+  4FEB 30 13       	jr	nc,A5000		; bigger, quit with error
3057+  4FED 0E 80       	ld	c,080H			; smaller, RC = 128 (means extend is full)
3058+  4FEF 2A 3D F2    A4FEF:	ld	hl,(YF23D)		; transferaddress
3059+  4FF2 11 0C 00    	ld	de,0000CH
3060+  4FF5 19          	add	hl,de
3061+  4FF6 46          	ld	b,(hl)			; MS-DOS fileattribute
3062+  4FF7 77          	ld	(hl),a			; EX = orginal FCB EX byte (CP/M: requested extent)
3063+  4FF8 23          	inc	hl
3064+  4FF9 70          	ld	(hl),b			; S1 = MS-DOS fileattribute (CP/M: reserved)
3065+  4FFA 23          	inc	hl
3066+  4FFB 72          	ld	(hl),d			; S2 = 0 (CP/M: extent high byte)
3067+  4FFC 23          	inc	hl
3068+  4FFD 71          	ld	(hl),c			; RC = (CP/M: recordcount)
3069+  4FFE AF          	xor	a			; CP/M direntry 0, no error
3070+  4FFF C9          	ret
3071+  5000             
3072+  5000 3E FF       A5000:	ld	a,0FFH
3073+  5002 32 0B F3    	ld	(YF30B),a		; search for next invalid
3074+  5005 C9          	ret
3075+  5006             
3076+  5006             ;	Subroutine	BDOS 12 (search for next)
3077+  5006             ;	Inputs		
3078+  5006             ;	Outputs		________________________
3079+  5006             
3080+  5006 CD 0E 44    A5006:	call	A440E			; validate FCB drive and filename
3081+  5009 38 F5       	jr	c,A5000			; invalid,
3082+  500B 3A 0B F3    	ld	a,(YF30B)		; saved direntrynumber of last search first
3083+  500E FE FF       	cp	0FFH
3084+  5010 28 EE       	jr	z,A5000			; flag search next invalid, quit with error
3085+  5012 32 B8 F2    	ld	(YF2B8),a
3086+  5015 DD 2A 09 F3 	ld	ix,(YF309)		; saved pointer to DPB
3087+  5019 CD BC 42    	call	A42BC			; find next directoryentry
3088+  501C 18 9D       	jr	A4FBB			; finish
3089+  501E             
3090+  501E             ;	Subroutine	BDOS 23 (compute filesize)
3091+  501E             ;	Inputs		
3092+  501E             ;	Outputs		________________________
3093+  501E             
3094+  501E CD A5 42    A501E:	call	A42A5			; validate FCB, clear S2 and find direntry
3095+  5021 3E FF       	ld	a,0FFH
3096+  5023 D8          	ret	c			; error, quit
3097+  5024 D5          	push	de
3098+  5025 DD E1       	pop	ix
3099+  5027 FD 7E 1C    	ld	a,(iy+28)
3100+  502A FD 4E 1D    	ld	c,(iy+29)
3101+  502D FD 46 1E    	ld	b,(iy+30)
3102+  5030 FD 5E 1F    	ld	e,(iy+31)
3103+  5033 87          	add	a,a
3104+  5034 CB 11       	rl	c
3105+  5036 CB 10       	rl	b
3106+  5038 CB 13       	rl	e			; convert filesize to random record
3107+  503A B7          	or	a			; filesize a multiply of 128 ?
3108+  503B 28 06       	jr	z,A5043
3109+  503D 03          	inc	bc
3110+  503E 78          	ld	a,b
3111+  503F B1          	or	c
3112+  5040 20 01       	jr	nz,A5043
3113+  5042 1C          	inc	e			; nope, increase random record
3114+  5043 DD 71 21    A5043:	ld	(ix+33),c
3115+  5046 DD 70 22    	ld	(ix+34),b
3116+  5049 DD 73 23    	ld	(ix+35),e		; set R2,R1 and R0
3117+  504C AF          	xor	a
3118+  504D C9          	ret				; quit without error
3119+  504E             
3120+  504E             ;	Subroutine	BDOS 18 (return bitmap of logged-in drives)
3121+  504E             ;	Inputs		
3122+  504E             ;	Outputs		________________________
3123+  504E             
3124+  504E 3A 47 F3    A504E:	ld	a,(YF347)
3125+  5051 47          	ld	b,a
3126+  5052 AF          	xor	a
3127+  5053 37          A5053:	scf
3128+  5054 17          	rla
3129+  5055 10 FC       	djnz	A5053			; all drives all online
3130+  5057 C9          	ret
3131+  5058             
3132+  5058             ;	Subroutine	BDOS 1A (set DMA address)
3133+  5058             ;	Inputs		
3134+  5058             ;	Outputs		________________________
3135+  5058             
3136+  5058 ED 53 3D F2 A5058:	ld	(YF23D),de		; set transferaddress
3137+  505C C9          	ret
3138+  505D             
3139+  505D             ;	Subroutine	BDOS 1B (MSXDOS get allocation)
3140+  505D             ;	Inputs		
3141+  505D             ;	Outputs		________________________
3142+  505D             
3143+  505D AF          A505D:	xor	a
3144+  505E 32 06 F3    	ld	(YF306),a		; no CP/M call
3145+  5061 7B          	ld	a,e
3146+  5062 CD 27 44    	call	A4427			; validate fcb driveid
3147+  5065 3E FF       	ld	a,0FFH
3148+  5067 D8          	ret	c			; error, quit
3149+  5068 CD DB 44    	call	A44DB			; get latest FAT
3150+  506B DD 5E 13    	ld	e,(ix+19)
3151+  506E DD 56 14    	ld	d,(ix+20)
3152+  5071 D5          	push	de
3153+  5072 FD E1       	pop	iy			; pointer to FAT buffer of drive
3154+  5074 21 02 00    	ld	hl,2			; start at clusterentry 2
3155+  5077 44          	ld	b,h
3156+  5078 4C          	ld	c,h			; free cluster = 0
3157+  5079 DD 5E 0E    	ld	e,(ix+14)
3158+  507C DD 56 0F    	ld	d,(ix+15)
3159+  507F 1B          	dec	de			; number of clusters on disk
3160+  5080 D5          	push	de
3161+  5081 D5          A5081:	push	de
3162+  5082 E5          	push	hl
3163+  5083 CD F4 41    	call	A41F4			; get FAT entry content
3164+  5086 E1          	pop	hl
3165+  5087 D1          	pop	de
3166+  5088 20 01       	jr	nz,A508B
3167+  508A 03          	inc	bc			; free clusters + 1
3168+  508B 23          A508B:	inc	hl
3169+  508C 1B          	dec	de
3170+  508D 7B          	ld	a,e
3171+  508E B2          	or	d
3172+  508F 20 F0       	jr	nz,A5081		; next cluster
3173+  5091 60          	ld	h,b
3174+  5092 69          	ld	l,c			; number of free clusters
3175+  5093 D1          	pop	de			; number of clusters
3176+  5094 DD 7E 06    	ld	a,(ix+6)
3177+  5097 3C          	inc	a			; number of sectors per cluster
3178+  5098 DD 4E 02    	ld	c,(ix+2)
3179+  509B DD 46 03    	ld	b,(ix+3)		; sectorsize
3180+  509E C9          	ret
3181+  509F             
3182+  509F             ;	Subroutine	BDOS 0D (reset discs)
3183+  509F             ;	Inputs		
3184+  509F             ;	Outputs		________________________
3185+  509F             
3186+  509F 21 80 00    A509F:	ld	hl,00080H
3187+  50A2 22 3D F2    	ld	(YF23D),hl		; default transferaddress
3188+  50A5 AF          	xor	a
3189+  50A6 32 47 F2    	ld	(YF247),a		; default driveid 0 (A:)
3190+  50A9 CD 2D 47    	call	A472D			; flush datasector buffer
3191+  50AC 21 55 F3    	ld	hl,YF355
3192+  50AF 3A 47 F3    	ld	a,(YF347)		; all drives
3193+  50B2 5E          A50B2:	ld	e,(hl)
3194+  50B3 23          	inc	hl
3195+  50B4 56          	ld	d,(hl)			; pointer to DPB
3196+  50B5 23          	inc	hl
3197+  50B6 E5          	push	hl
3198+  50B7 F5          	push	af
3199+  50B8 D5          	push	de
3200+  50B9 DD E1       	pop	ix
3201+  50BB CD C4 45    	call	A45C4			; flush FAT buffer
3202+  50BE F1          	pop	af
3203+  50BF E1          	pop	hl
3204+  50C0 3D          	dec	a
3205+  50C1 20 EF       	jr	nz,A50B2		; next drive
3206+  50C3 C9          	ret
3207+  50C4             
3208+  50C4             ;	Subroutine	BDOS 25 (return current drive)
3209+  50C4             ;	Inputs		
3210+  50C4             ;	Outputs		________________________
3211+  50C4             
3212+  50C4 3A 47 F2    A50C4:	ld	a,(YF247)
3213+  50C7 C9          	ret
3214+  50C8             
3215+  50C8             ;	Subroutine	BDOS 34 (update random access pointer)
3216+  50C8             ;	Inputs		
3217+  50C8             ;	Outputs		________________________
3218+  50C8             
3219+  50C8 CD F8 4E    A50C8:	call	A4EF8			; get recordnumber from CR,EX and S2 field
3220+  50CB FD 75 21    	ld	(iy+33),l
3221+  50CE FD 74 22    	ld	(iy+34),h
3222+  50D1 FD 73 23    	ld	(iy+35),e
3223+  50D4 C9          	ret
3224+  50D5             
3225+  50D5             ;	Subroutine	BDOS 0E (select disc)
3226+  50D5             ;	Inputs		
3227+  50D5             ;	Outputs		________________________
3228+  50D5             
3229+  50D5 3A 47 F3    A50D5:	ld	a,(YF347)
3230+  50D8 BB          	cp	e
3231+  50D9 D8          	ret	c
3232+  50DA C8          	ret	z
3233+  50DB 21 47 F2    	ld	hl,YF247
3234+  50DE 73          	ld	(hl),e
3235+  50DF C9          	ret
3236+  50E0             
3237+  50E0             ;	Subroutine	BDOS 0A (buffered console input)
3238+  50E0             ;	Inputs		
3239+  50E0             ;	Outputs		________________________
3240+  50E0             
3241+  50E0 D5          A50E0:	push	de
3242+  50E1 3A 37 F2    	ld	a,(YF237)
3243+  50E4 32 38 F2    	ld	(YF238),a		; save current console columnpos to record start of inputline
3244+  50E7 AF          	xor	a
3245+  50E8 32 39 F2    	ld	(YF239),a		; not in insertmode
3246+  50EB 62          	ld	h,d
3247+  50EC 6B          	ld	l,e
3248+  50ED 47          	ld	b,a
3249+  50EE 4E          	ld	c,(hl)			; size of buffer
3250+  50EF 23          	inc	hl
3251+  50F0 57          	ld	d,a
3252+  50F1 5E          	ld	e,(hl)			; length of line already in buffer
3253+  50F2 23          	inc	hl
3254+  50F3 DD 21 59 F4 	ld	ix,YCONTP
3255+  50F7 7B          	ld	a,e
3256+  50F8 B9          	cp	c			; is lengthbyte valid ?
3257+  50F9             
3258+  50F9             ; VERSION 1.1 CHANGE
3259+  50F9             ; CHANGED, BUGFIX
3260+  50F9             ; jr nc,A5103
3261+  50F9             
3262+  50F9 30 06       	jr	nc,A5101		; equal, use the line in buffer as basis otherwise use empty line as basis
3263+  50FB E5          	push	hl			; length smaller than size of buffer
3264+  50FC 19          	add	hl,de
3265+  50FD 7E          	ld	a,(hl)
3266+  50FE E1          	pop	hl
3267+  50FF FE 0D       	cp	00DH			; then line must be terminated by a CR
3268+  5101 28 01       A5101:	jr	z,A5104			; it is, use the line in buffer as basis
3269+  5103 5A          A5103:	ld	e,d			; use empty line as basis
3270+  5104             
3271+  5104             ; linputinput headloop, also lineinput CTRL-F
3272+  5104             
3273+  5104 CD AC F2    A5104:	call	XF2AC			; hook
3274+  5107 CD 4E 54    	call	A544E			; BDOS 8 (direct input)
3275+  510A E5          A510A:	push	hl
3276+  510B C5          	push	bc
3277+  510C 21 74 53    	ld	hl,T5374
3278+  510F 01 11 00    	ld	bc,NKEYNT		; number of keyentries
3279+  5112 ED B1       	cpir
3280+  5114 09          	add	hl,bc
3281+  5115 09          	add	hl,bc
3282+  5116 09          	add	hl,bc
3283+  5117 4E          	ld	c,(hl)
3284+  5118 23          	inc	hl
3285+  5119 66          	ld	h,(hl)
3286+  511A 69          	ld	l,c
3287+  511B C1          	pop	bc
3288+  511C E3          	ex	(sp),hl
3289+  511D C9          	ret
3290+  511E             
3291+  511E             ; lineinput CTRL-A, MSX graphic header
3292+  511E             
3293+  511E CD 4E 54    A511E:	call	A544E			; BDOS 8 (direct input)
3294+  5121 FE 40       	cp	040H
3295+  5123 38 E5       	jr	c,A510A
3296+  5125 FE 60       	cp	060H
3297+  5127 30 E1       	jr	nc,A510A
3298+  5129 F5          	push	af
3299+  512A 78          	ld	a,b
3300+  512B 3C          	inc	a
3301+  512C B9          	cp	c
3302+  512D 30 2F       	jr	nc,A515E		; beep
3303+  512F 3E 01       	ld	a,1
3304+  5131 DD 77 00    	ld	(ix+0),a
3305+  5134 DD 23       	inc	ix
3306+  5136 04          	inc	b
3307+  5137 CD 5D 53    	call	A535D
3308+  513A F1          	pop	af
3309+  513B             
3310+  513B             
3311+  513B             ; lineinput, normal key action
3312+  513B             
3313+  513B F5          A513B:	push	af
3314+  513C 78          	ld	a,b
3315+  513D B9          	cp	c
3316+  513E 30 1E       	jr	nc,A515E		; beep
3317+  5140 F1          	pop	af
3318+  5141 DD 77 00    	ld	(ix+0),a
3319+  5144 DD 23       	inc	ix
3320+  5146 04          	inc	b
3321+  5147 CD 5D 53    	call	A535D
3322+  514A 3A 39 F2    	ld	a,(YF239)
3323+  514D B7          	or	a			; insertmode ?
3324+  514E 20 B4       	jr	nz,A5104		; yep,
3325+  5150 14          	inc	d
3326+  5151 7B          	ld	a,e
3327+  5152 BA          	cp	d
3328+  5153 38 AF       	jr	c,A5104
3329+  5155 7E          	ld	a,(hl)
3330+  5156 3D          	dec	a
3331+  5157 23          	inc	hl
3332+  5158 20 AA       	jr	nz,A5104
3333+  515A 14          	inc	d
3334+  515B 23          	inc	hl
3335+  515C 18 A6       	jr	A5104
3336+  515E             
3337+  515E F1          A515E:	pop	af
3338+  515F 3E 07       	ld	a,007H			; bell
3339+  5161 CD A8 53    	call	A53A8			; console output
3340+  5164 18 9E       	jr	A5104
3341+  5166             
3342+  5166             ; lineinput UP key, ESC key, CTRL-U (VOID)
3343+  5166             
3344+  5166 D1          A5166:	pop	de
3345+  5167 3A 38 F2    	ld	a,(YF238)
3346+  516A 47          	ld	b,a
3347+  516B 3A 37 F2    	ld	a,(YF237)
3348+  516E 90          	sub	b			; length of the inputline
3349+  516F 28 06       	jr	z,A5177			; empty inputline, restart line input
3350+  5171 47          	ld	b,a
3351+  5172 CD 4F 53    A5172:	call	A534F
3352+  5175 10 FB       	djnz	A5172
3353+  5177 C3 E0 50    A5177:	jp	A50E0			; restart lineinput
3354+  517A             
3355+  517A             ; lineinput CTRL-J
3356+  517A             
3357+  517A 78          A517A:	ld	a,b
3358+  517B 32 3A F2    	ld	(YF23A),a		; store current linelength (for secret message)
3359+  517E CD 83 51    	call	A5183			; newline
3360+  5181 18 81       A5181:	jr	A5104
3361+  5183             
3362+  5183 3E 0D       A5183:	ld	a,00DH
3363+  5185 CD A8 53    	call	A53A8			; console output
3364+  5188 3E 0A       	ld	a,00AH
3365+  518A C3 A8 53    	jp	A53A8			; console output
3366+  518D             
3367+  518D             ; lineinput CR key
3368+  518D             
3369+  518D D1          A518D:	pop	de
3370+  518E CD A8 53    A518E:	call	A53A8			; console output
3371+  5191 D5          	push	de
3372+  5192 13          	inc	de
3373+  5193 78          	ld	a,b
3374+  5194 12          	ld	(de),a
3375+  5195 B9          	cp	c
3376+  5196 F5          	push	af
3377+  5197 13          	inc	de
3378+  5198 48          	ld	c,b
3379+  5199 AF          	xor	a
3380+  519A 47          	ld	b,a
3381+  519B B1          	or	c
3382+  519C 28 05       	jr	z,A51A3
3383+  519E 21 59 F4    	ld	hl,YCONTP
3384+  51A1 ED B0       	ldir
3385+  51A3 F1          A51A3:	pop	af
3386+  51A4 28 03       	jr	z,A51A9
3387+  51A6 3E 0D       	ld	a,00DH
3388+  51A8 12          	ld	(de),a
3389+  51A9 D1          A51A9:	pop	de
3390+  51AA C9          	ret
3391+  51AB             
3392+  51AB             ; lineinput LEFT key, BS key (BS)
3393+  51AB             
3394+  51AB 3A 3A F2    A51AB:	ld	a,(YF23A)
3395+  51AE A0          	and	b
3396+  51AF FE 7F       	cp	07FH
3397+  51B1 CA 44 52    	jp	z,A5244			; secret programmers message
3398+  51B4 04          	inc	b
3399+  51B5 05          	dec	b
3400+  51B6 28 24       	jr	z,A51DC
3401+  51B8 05          	dec	b
3402+  51B9 DD 2B       	dec	ix
3403+  51BB CD 4F 53    	call	A534F
3404+  51BE 04          	inc	b
3405+  51BF 05          	dec	b
3406+  51C0 28 0C       	jr	z,A51CE
3407+  51C2 05          	dec	b
3408+  51C3 DD 2B       	dec	ix
3409+  51C5 DD 7E 00    	ld	a,(ix+0)
3410+  51C8 3D          	dec	a
3411+  51C9 28 11       	jr	z,A51DC
3412+  51CB 04          	inc	b
3413+  51CC DD 23       	inc	ix
3414+  51CE DD 7E 00    A51CE:	ld	a,(ix+0)
3415+  51D1 FE 20       	cp	020H
3416+  51D3 30 07       	jr	nc,A51DC
3417+  51D5 FE 09       	cp	009H
3418+  51D7 28 22       	jr	z,A51FB
3419+  51D9 CD 4F 53    	call	A534F
3420+  51DC 3A 39 F2    A51DC:	ld	a,(YF239)
3421+  51DF B7          	or	a			; insertmode ?
3422+  51E0 20 9F       	jr	nz,A5181		; yep,
3423+  51E2 14          	inc	d
3424+  51E3 15          	dec	d
3425+  51E4 28 9B       	jr	z,A5181
3426+  51E6 15          	dec	d
3427+  51E7 7A          	ld	a,d
3428+  51E8 BB          	cp	e
3429+  51E9 30 96       	jr	nc,A5181
3430+  51EB 2B          	dec	hl
3431+  51EC 7A          	ld	a,d
3432+  51ED FE 01       	cp	001H
3433+  51EF 38 90       	jr	c,A5181
3434+  51F1 2B          	dec	hl
3435+  51F2 7E          	ld	a,(hl)
3436+  51F3 3D          	dec	a
3437+  51F4 23          	inc	hl
3438+  51F5 20 8A       	jr	nz,A5181
3439+  51F7 15          	dec	d
3440+  51F8 2B          	dec	hl
3441+  51F9 18 86       	jr	A5181
3442+  51FB             
3443+  51FB E5          A51FB:	push	hl
3444+  51FC C5          	push	bc
3445+  51FD 3A 38 F2    	ld	a,(YF238)
3446+  5200 4F          	ld	c,a			; start of the inputline
3447+  5201 04          	inc	b
3448+  5202 05          	dec	b
3449+  5203 28 15       	jr	z,A521A
3450+  5205 21 59 F4    	ld	hl,YCONTP
3451+  5208 7E          A5208:	ld	a,(hl)
3452+  5209 23          	inc	hl
3453+  520A FE 01       	cp	001H
3454+  520C 28 0A       	jr	z,A5218
3455+  520E 0C          	inc	c
3456+  520F FE 20       	cp	020H
3457+  5211 30 05       	jr	nc,A5218
3458+  5213 FE 09       	cp	009H
3459+  5215 28 13       	jr	z,A522A
3460+  5217 0C          	inc	c
3461+  5218 10 EE       A5218:	djnz	A5208
3462+  521A 3A 37 F2    A521A:	ld	a,(YF237)		; current console columnpos
3463+  521D 91          	sub	c
3464+  521E 28 06       	jr	z,A5226
3465+  5220 47          	ld	b,a
3466+  5221 CD 4F 53    A5221:	call	A534F
3467+  5224 10 FB       	djnz	A5221
3468+  5226 C1          A5226:	pop	bc
3469+  5227 E1          	pop	hl
3470+  5228 18 B2       	jr	A51DC
3471+  522A             
3472+  522A 79          A522A:	ld	a,c
3473+  522B C6 07       	add	a,007H
3474+  522D E6 F8       	and	0F8H
3475+  522F 4F          	ld	c,a
3476+  5230 18 E6       	jr	A5218
3477+  5232             
3478+  5232             ; lineinput INS key (INSERT)
3479+  5232             
3480+  5232 3A 39 F2    A5232:	ld	a,(YF239)
3481+  5235 EE 01       	xor	001H
3482+  5237 18 05       	jr	A523E			; toggle insertmode
3483+  5239             
3484+  5239             ; unused code
3485+  5239             
3486+  5239 AF          	xor	a
3487+  523A 18 02       	jr	A523E
3488+  523C             
3489+  523C             ; unused code
3490+  523C             
3491+  523C 3E 01       	ld	a,001H
3492+  523E             
3493+  523E 32 39 F2    A523E:	ld	(YF239),a
3494+  5241 C3 04 51    	jp	A5104
3495+  5244             
3496+  5244             ;	Subroutine	display message of programmer (not needed)
3497+  5244             ;	Inputs		
3498+  5244             ;	Outputs
3499+  5244             ;	Remark		activated by:
3500+  5244             ;			input 127 or 255 chars, press CTRL-J, press BS or LEFT
3501+  5244             
3502+  5244 AF          A5244:	xor	a
3503+  5245 32 3A F2    	ld	(YF23A),a
3504+  5248 C5          	push	bc
3505+  5249 06 10       	ld	b,16
3506+  524B 11 7D 54    	ld	de,T547D
3507+  524E 21 00 00    	ld	hl,0
3508+  5251 E5          A5251:	push	hl
3509+  5252 CD D2 4E    	call	A4ED2			; get decoded characterpair
3510+  5255 C6 20       	add	a,020H
3511+  5257 CD A8 53    	call	A53A8			; console output
3512+  525A 7C          	ld	a,h
3513+  525B C6 20       	add	a,020H
3514+  525D CD A8 53    	call	A53A8			; console output
3515+  5260 E1          	pop	hl
3516+  5261 23          	inc	hl
3517+  5262 10 ED       	djnz	A5251
3518+  5264 C1          	pop	bc
3519+  5265             
3520+  5265             ; lineinput HOME key (NEWLINE)
3521+  5265             
3522+  5265 3E 40       A5265:	ld	a,040H
3523+  5267 D1          	pop	de
3524+  5268 CD 8E 51    	call	A518E
3525+  526B CD 83 51    	call	A5183			; newline
3526+  526E 3A 38 F2    	ld	a,(YF238)
3527+  5271 B7          	or	a			; start of the inputline at the begin of a line ?
3528+  5272 CA E0 50    	jp	z,A50E0			; yep, restart lineinput routine
3529+  5275 47          	ld	b,a
3530+  5276 3E 20       	ld	a," "
3531+  5278 CD A8 53    A5278:	call	A53A8			; console output
3532+  527B 10 FB       	djnz	A5278
3533+  527D C3 E0 50    	jp	A50E0			; restart lineinput routine
3534+  5280             
3535+  5280             ; lineinput DOWN key (COPYALL)
3536+  5280             
3537+  5280 3E FF       A5280:	ld	a,0FFH
3538+  5282 18 31       	jr	A52B5
3539+  5284             
3540+  5284             ; lineinput CTRL-L (SKIPUP)
3541+  5284             
3542+  5284 CD E3 52    A5284:	call	A52E3
3543+  5287 DA 04 51    	jp	c,A5104
3544+  528A C5          	push	bc
3545+  528B 4F          	ld	c,a
3546+  528C 06 00       	ld	b,000H
3547+  528E 09          	add	hl,bc
3548+  528F C1          	pop	bc
3549+  5290 82          	add	a,d
3550+  5291 57          	ld	d,a
3551+  5292 C3 04 51    	jp	A5104
3552+  5295             
3553+  5295             ; lineinput SELECT key (COPYUP)
3554+  5295             
3555+  5295 CD E3 52    A5295:	call	A52E3
3556+  5298 DA 04 51    	jp	c,A5104
3557+  529B 18 18       	jr	A52B5
3558+  529D             
3559+  529D             ; lineinput DEL key (SKIP1)
3560+  529D             
3561+  529D 7A          A529D:	ld	a,d
3562+  529E BB          	cp	e
3563+  529F D2 04 51    	jp	nc,A5104
3564+  52A2 14          	inc	d
3565+  52A3 7E          	ld	a,(hl)
3566+  52A4 3D          	dec	a
3567+  52A5 23          	inc	hl
3568+  52A6 C2 04 51    	jp	nz,A5104
3569+  52A9 14          	inc	d
3570+  52AA 23          	inc	hl
3571+  52AB C3 04 51    	jp	A5104
3572+  52AE             
3573+  52AE             ; lineinput RIGHT key (COPY1)
3574+  52AE             
3575+  52AE 7E          A52AE:	ld	a,(hl)
3576+  52AF 3D          	dec	a
3577+  52B0 3E 01       	ld	a,001H
3578+  52B2 20 01       	jr	nz,A52B5
3579+  52B4 3C          	inc	a
3580+  52B5 F5          A52B5:	push	af
3581+  52B6 AF          	xor	a
3582+  52B7 32 39 F2    	ld	(YF239),a		; insertmode off
3583+  52BA 78          	ld	a,b
3584+  52BB B9          	cp	c
3585+  52BC 30 21       	jr	nc,A52DF
3586+  52BE 7A          	ld	a,d
3587+  52BF BB          	cp	e
3588+  52C0 30 1D       	jr	nc,A52DF
3589+  52C2 7E          	ld	a,(hl)
3590+  52C3 FE 01       	cp	001H
3591+  52C5 20 06       	jr	nz,A52CD
3592+  52C7 78          	ld	a,b
3593+  52C8 3C          	inc	a
3594+  52C9 B9          	cp	c
3595+  52CA 30 13       	jr	nc,A52DF
3596+  52CC 7E          	ld	a,(hl)
3597+  52CD 23          A52CD:	inc	hl
3598+  52CE DD 77 00    	ld	(ix+0),a
3599+  52D1 DD 23       	inc	ix
3600+  52D3 CD 5D 53    	call	A535D
3601+  52D6 04          	inc	b
3602+  52D7 14          	inc	d
3603+  52D8 F1          	pop	af
3604+  52D9 3D          	dec	a
3605+  52DA 20 D9       	jr	nz,A52B5
3606+  52DC C3 04 51    	jp	A5104
3607+  52DF             
3608+  52DF F1          A52DF:	pop	af
3609+  52E0 C3 04 51    	jp	A5104
3610+  52E3             
3611+  52E3 CD 4E 54    A52E3:	call	A544E			; BDOS 8 (direct input)
3612+  52E6 FE 01       	cp	001H
3613+  52E8 20 35       	jr	nz,A531F
3614+  52EA CD 4E 54    	call	A544E			; BDOS 8 (direct input)
3615+  52ED FE 40       	cp	040H
3616+  52EF 38 2E       	jr	c,A531F
3617+  52F1 FE 60       	cp	060H
3618+  52F3 30 2A       	jr	nc,A531F
3619+  52F5 E5          	push	hl
3620+  52F6 D5          	push	de
3621+  52F7 C5          	push	bc
3622+  52F8 FD 21 00 00 	ld	iy,00000H
3623+  52FC 37          A52FC:	scf
3624+  52FD F5          	push	af
3625+  52FE 3E 01       	ld	a,001H
3626+  5300 CD 1F 53    	call	A531F
3627+  5303 38 15       	jr	c,A531A
3628+  5305 4F          	ld	c,a
3629+  5306 06 00       	ld	b,000H
3630+  5308 09          	add	hl,bc
3631+  5309 82          	add	a,d
3632+  530A 57          	ld	d,a
3633+  530B FD E5       	push	iy
3634+  530D F1          	pop	af
3635+  530E 81          	add	a,c
3636+  530F F5          	push	af
3637+  5310 FD E1       	pop	iy
3638+  5312 23          	inc	hl
3639+  5313 F1          	pop	af
3640+  5314 BE          	cp	(hl)
3641+  5315 2B          	dec	hl
3642+  5316 20 E4       	jr	nz,A52FC
3643+  5318 FD E5       	push	iy
3644+  531A F1          A531A:	pop	af
3645+  531B C1          	pop	bc
3646+  531C D1          	pop	de
3647+  531D E1          	pop	hl
3648+  531E C9          	ret
3649+  531F             
3650+  531F C5          A531F:	push	bc
3651+  5320 F5          	push	af
3652+  5321 7B          	ld	a,e
3653+  5322 92          	sub	d
3654+  5323 38 26       	jr	c,A534B
3655+  5325 28 24       	jr	z,A534B
3656+  5327 3D          	dec	a
3657+  5328 28 21       	jr	z,A534B
3658+  532A 4F          	ld	c,a
3659+  532B 06 00       	ld	b,000H
3660+  532D F1          	pop	af
3661+  532E E5          	push	hl
3662+  532F F5          	push	af
3663+  5330 7E          	ld	a,(hl)
3664+  5331 3D          	dec	a
3665+  5332 20 02       	jr	nz,A5336
3666+  5334 23          	inc	hl
3667+  5335 0D          	dec	c
3668+  5336 F1          A5336:	pop	af
3669+  5337 0C          	inc	c
3670+  5338 0D          	dec	c
3671+  5339 20 04       	jr	nz,A533F
3672+  533B E1          	pop	hl
3673+  533C C1          	pop	bc
3674+  533D 37          	scf
3675+  533E C9          	ret
3676+  533F             
3677+  533F 23          A533F:	inc	hl
3678+  5340 ED B1       	cpir
3679+  5342 E1          	pop	hl
3680+  5343 20 07       	jr	nz,A534C
3681+  5345 7B          	ld	a,e
3682+  5346 92          	sub	d
3683+  5347 3D          	dec	a
3684+  5348 91          	sub	c
3685+  5349 C1          	pop	bc
3686+  534A C9          	ret
3687+  534B             
3688+  534B F1          A534B:	pop	af
3689+  534C C1          A534C:	pop	bc
3690+  534D 37          	scf
3691+  534E C9          	ret
3692+  534F             
3693+  534F 3E 08       A534F:	ld	a,008H
3694+  5351 CD A8 53    	call	A53A8			; console output
3695+  5354 3E 20       	ld	a,020H
3696+  5356 CD A8 53    	call	A53A8			; console output
3697+  5359 3E 08       	ld	a,008H
3698+  535B 18 4B       	jr	A53A8			; console output
3699+  535D             
3700+  535D FE 20       A535D:	cp	020H
3701+  535F 30 47       	jr	nc,A53A8		; console output
3702+  5361 FE 09       	cp	009H
3703+  5363 28 43       	jr	z,A53A8			; console output
3704+  5365 FE 01       	cp	001H
3705+  5367 28 3F       	jr	z,A53A8			; console output
3706+  5369 F5          	push	af
3707+  536A 3E 5E       	ld	a,"^"
3708+  536C CD A8 53    	call	A53A8			; console output
3709+  536F F1          	pop	af
3710+  5370 F6 40       	or	040H
3711+  5372 18 34       	jr	A53A8			; console output
3712+  5374             
3713+  5374             ; keytable lineinput
3714+  5374             ; first table contains all keycodes, code 8 at the end is a fake one for 'other key', because it is already in the table
3715+  5374             ; second table contains all serviceroutines, but in reserve order (so last one belongs to the first keycode)
3716+  5374             
3717+  5374             T5374:	defb	006H,07FH,008H,00DH,00AH,015H,00BH,00CH
3717+  5374 067F080D0A150B0C
3718+  537C             	defb	01BH,012H,018H,01CH,01DH,01EH,01FH,001H
3718+  537C 1B12181C1D1E1F01
3719+  5384 08          	defb	008H
3720+  5385             
3721+  5385 3B 51       	defw	A513B
3722+  5387             	defw	A511E,A5280,A5166,A51AB,A52AE,A5295,A5232,A5166
3722+  5387 1E5180526651AB51AE52955232526651
3723+  5397             	defw	A5284,A5265,A5166,A517A,A518D,A51AB,A529D,A5104
3723+  5397 8452655266517A518D51AB519D520451
3724+  53A7             
3725+  53A7             NKEYNT	equ	($-T5374)/3
3726+  53A7             
3727+  53A7             
3728+  53A7             ;	Subroutine	BDOS 02 (console output)
3729+  53A7             ;	Inputs		
3730+  53A7             ;	Outputs		________________________
3731+  53A7             
3732+  53A7 7B          A53A7:	ld	a,e
3733+  53A8 CD AF F2    A53A8:	call	XF2AF
3734+  53AB FE 0B       	cp	00BH
3735+  53AD 28 39       	jr	z,A53E8
3736+  53AF FE 0C       	cp	00CH
3737+  53B1 28 35       	jr	z,A53E8
3738+  53B3 FE 1C       	cp	01CH
3739+  53B5 28 1E       	jr	z,A53D5
3740+  53B7 FE 1D       	cp	01DH
3741+  53B9 28 35       	jr	z,A53F0
3742+  53BB FE 0D       	cp	00DH
3743+  53BD 28 29       	jr	z,A53E8
3744+  53BF FE 08       	cp	008H
3745+  53C1 28 2D       	jr	z,A53F0
3746+  53C3 FE 09       	cp	009H
3747+  53C5 28 31       	jr	z,A53F8
3748+  53C7 FE 7F       	cp	07FH
3749+  53C9 28 25       	jr	z,A53F0
3750+  53CB FE 20       	cp	020H
3751+  53CD 38 06       	jr	c,A53D5
3752+  53CF E5          	push	hl
3753+  53D0 21 37 F2    	ld	hl,YF237
3754+  53D3 34          	inc	(hl)			; increase console columnpos
3755+  53D4 E1          	pop	hl
3756+  53D5 C5          A53D5:	push	bc
3757+  53D6 47          	ld	b,a
3758+  53D7 CD 12 54    	call	A5412
3759+  53DA 78          	ld	a,b
3760+  53DB CD 8F 40    	call	A408F			; output to screen
3761+  53DE 3A 3B F2    	ld	a,(YF23B)
3762+  53E1 B7          	or	a			; console output also to printer ?
3763+  53E2 78          	ld	a,b
3764+  53E3 C1          	pop	bc
3765+  53E4 C8          	ret	z			; nope, quit
3766+  53E5 C3 9B 40    	jp	A409B			; output to printer
3767+  53E8             
3768+  53E8 F5          A53E8:	push	af
3769+  53E9 AF          	xor	a
3770+  53EA 32 37 F2    	ld	(YF237),a		; console columpos
3771+  53ED F1          	pop	af
3772+  53EE 18 E5       	jr	A53D5
3773+  53F0             
3774+  53F0 E5          A53F0:	push	hl
3775+  53F1 21 37 F2    	ld	hl,YF237
3776+  53F4 35          	dec	(hl)			; decrease console columnpos
3777+  53F5 E1          	pop	hl
3778+  53F6 18 DD       	jr	A53D5
3779+  53F8             
3780+  53F8 3E 20       A53F8:	ld	a," "
3781+  53FA CD A8 53    	call	A53A8			; console output
3782+  53FD 3A 37 F2    	ld	a,(YF237)
3783+  5400 E6 07       	and	007H
3784+  5402 20 F4       	jr	nz,A53F8		; to the next console tabposition
3785+  5404 C9          	ret
3786+  5405             
3787+  5405 FE 10       A5405:	cp	010H			; CTRL-P ?
3788+  5407 28 14       	jr	z,A541D			; yep, handle it
3789+  5409 FE 0E       	cp	00EH			; CTRL-N ?
3790+  540B 28 10       	jr	z,A541D			; yep, handle it
3791+  540D FE 03       	cp	003H			; CTRL-C ?
3792+  540F 28 0C       	jr	z,A541D			; yep, handle it
3793+  5411 C9          	ret				; nope, quit
3794+  5412             
3795+  5412 CD 34 40    A5412:	call	A4034			; check if keyboardinput available
3796+  5415 C8          	ret	z			; nope, quit
3797+  5416 FE 13       	cp	013H			; CTRL-S ?
3798+  5418 20 EB       	jr	nz,A5405		; nope, check other specials
3799+  541A CD 78 40    	call	A4078			; get keyboardinput (the CTRL-S)
3800+  541D             					; next wait for other consoleinput
3801+  541D CD 78 40    A541D:	call	A4078			; get keyboardinput
3802+  5420 FE 10       	cp	010H
3803+  5422 28 0D       	jr	z,A5431			; CTRL-P, enable printer output
3804+  5424 FE 0E       	cp	00EH
3805+  5426 28 0F       	jr	z,A5437			; CTRL-N, disable printer output
3806+  5428 FE 03       	cp	003H			; CTRL-C ?
3807+  542A C0          	ret	nz			; nope, quit
3808+  542B 2A 25 F3    	ld	hl,(YF325)
3809+  542E C3 E8 F1    	jp	XF1E8			; start abort handler in DOS memory
3810+  5431             
3811+  5431 3E 01       A5431:	ld	a,1
3812+  5433 32 3B F2    	ld	(YF23B),a
3813+  5436 C9          	ret
3814+  5437             
3815+  5437 AF          A5437:	xor	a
3816+  5438 32 3B F2    	ld	(YF23B),a
3817+  543B C9          	ret
3818+  543C             
3819+  543C             ;	Subroutine	BDOS 0B (console status)
3820+  543C             ;	Inputs		
3821+  543C             ;	Outputs		________________________
3822+  543C             
3823+  543C CD 12 54    A543C:	call	A5412
3824+  543F 3E 00       	ld	a,000H
3825+  5441 C8          	ret	z
3826+  5442 F6 FF       	or	0FFH
3827+  5444 C9          	ret
3828+  5445             
3829+  5445             ;	Subroutine	BDOS 01 (console input)
3830+  5445             ;	Inputs		
3831+  5445             ;	Outputs		________________________
3832+  5445             
3833+  5445 CD 4E 54    A5445:	call	A544E			; BDOS 8 (direct input)
3834+  5448 F5          	push	af
3835+  5449 CD A8 53    	call	A53A8			; console output
3836+  544C F1          	pop	af
3837+  544D C9          	ret
3838+  544E             
3839+  544E             ;	Subroutine	BDOS 08 (direct input)
3840+  544E             ;	Inputs		
3841+  544E             ;	Outputs		________________________
3842+  544E             
3843+  544E CD 1D 54    A544E:	call	A541D
3844+  5451 28 FB       	jr	z,A544E
3845+  5453 C9          	ret
3846+  5454             
3847+  5454             ;	Subroutine	BDOS 06 (direct console i/o)
3848+  5454             ;	Inputs		A=0FFH for console input, A<>0FFH for console output
3849+  5454             ;	Outputs		A=input (console input)
3850+  5454             
3851+  5454 7B          A5454:	ld	a,e
3852+  5455 FE FF       	cp	0FFH			; console input ?
3853+  5457 C2 8F 40    	jp	nz,A408F		; console output, output to screen and quit
3854+  545A CD 34 40    	call	A4034			; check if keyboardinput available
3855+  545D C2 78 40    	jp	nz,A4078		; yep, get keyboardinput and quit
3856+  5460 AF          	xor	a
3857+  5461 C9          	ret
3858+  5462             
3859+  5462             ;	Subroutine	BDOS 07 (MSXDOS direct input)
3860+  5462             ;	Inputs		
3861+  5462             ;	Outputs		________________________
3862+  5462             
3863+  5462 C3 78 40    A5462:	jp	A4078			; get keyboardinput
3864+  5465             
3865+  5465             ;	Subroutine	BDOS 05 (printer output)
3866+  5465             ;	Inputs		
3867+  5465             ;	Outputs		________________________
3868+  5465             
3869+  5465 7B          A5465:	ld	a,e
3870+  5466 F5          A5466:	push	af
3871+  5467 CD 12 54    	call	A5412
3872+  546A F1          	pop	af
3873+  546B C3 9B 40    	jp	A409B			; output to printer
3874+  546E             
3875+  546E             ;	Subroutine	BDOS 03 (auxiliary input)
3876+  546E             ;	Inputs		
3877+  546E             ;	Outputs		________________________
3878+  546E             
3879+  546E CD 12 54    A546E:	call	A5412
3880+  5471 C3 71 F3    	jp	XF371
3881+  5474             
3882+  5474             ;	Subroutine	BDOS 04 (auxiliary output)
3883+  5474             ;	Inputs		
3884+  5474             ;	Outputs		________________________
3885+  5474             
3886+  5474 7B          A5474:	ld	a,e
3887+  5475 F5          A5475:	push	af
3888+  5476 CD 12 54    	call	A5412
3889+  5479 F1          	pop	af
3890+  547A C3 74 F3    	jp	XF374
3891+  547D             
3892+  547D             ; Programmers message, decoded in FAT entries (not needed)
3893+  547D             ; MSXDOS BY T PATERSON J SUZUKI   @
3894+  547D             
3895+  547D             T547D:	defb	0EDH,08CH,093H,0EFH,00CH,088H,039H,040H
3895+  547D ED8C93EF0C883940
3896+  5485             	defb	003H,070H,048H,097H,0F2H,0FCH,0BAH,080H
3896+  5485 03704897F2FCBA80
3897+  548D             	defb	00AH,0CCH,0B5H,05EH,0AFH,029H,000H,000H
3897+  548D 0ACCB55EAF290000
3898+  5495             
3899+  5495             ; unused code
3900+  5495             
3901+  5495 C9          	ret
3902+  5496             
3903+  5496 CD B2 F2    A5496:	call	XF2B2
3904+  5499 CD C0 54    	call	A54C0			; get time and date values
3905+  549C 79          	ld	a,c
3906+  549D 87          	add	a,a
3907+  549E 87          	add	a,a
3908+  549F 87          	add	a,a
3909+  54A0 CB 10       	rl	b
3910+  54A2 87          	add	a,a
3911+  54A3 CB 10       	rl	b
3912+  54A5 87          	add	a,a
3913+  54A6 CB 10       	rl	b
3914+  54A8 CB 3A       	srl	d
3915+  54AA B2          	or	d
3916+  54AB 5F          	ld	e,a
3917+  54AC 50          	ld	d,b
3918+  54AD ED 4B 49 F2 	ld	bc,(YF249)
3919+  54B1 79          	ld	a,c
3920+  54B2 87          	add	a,a
3921+  54B3 87          	add	a,a
3922+  54B4 87          	add	a,a
3923+  54B5 87          	add	a,a
3924+  54B6 87          	add	a,a
3925+  54B7 CB 10       	rl	b
3926+  54B9 4F          	ld	c,a
3927+  54BA 3A 48 F2    	ld	a,(YF248)		; current day
3928+  54BD B1          	or	c
3929+  54BE 4F          	ld	c,a
3930+  54BF C9          	ret
3931+  54C0             
3932+  54C0 CD 79 41    A54C0:	call	A4179			; get date and time
3933+  54C3 38 46       	jr	c,A550B			; from clockchip,
3934+  54C5 D5          	push	de
3935+  54C6 E5          	push	hl
3936+  54C7 ED 5B 4C F2 	ld	de,(YF24C)		; days since 1-1-1980
3937+  54CB B7          	or	a
3938+  54CC ED 52       	sbc	hl,de
3939+  54CE E1          	pop	hl
3940+  54CF D1          	pop	de
3941+  54D0 C8          	ret	z
3942+  54D1 22 4C F2    	ld	(YF24C),hl
3943+  54D4 C5          	push	bc
3944+  54D5 D5          	push	de
3945+  54D6 4D          	ld	c,l
3946+  54D7 44          	ld	b,h
3947+  54D8 11 B5 05    	ld	de,4*365+1
3948+  54DB CD 2F 49    	call	A492F			; divide
3949+  54DE 79          	ld	a,c
3950+  54DF 87          	add	a,a
3951+  54E0 87          	add	a,a
3952+  54E1 87          	add	a,a
3953+  54E2 06 00       	ld	b,000H
3954+  54E4 11 34 55    	ld	de,T5534
3955+  54E7 CD 15 55    	call	A5515
3956+  54EA CB 3F       	srl	a
3957+  54EC 30 04       	jr	nc,A54F2
3958+  54EE 11 C8 00    	ld	de,200
3959+  54F1 19          	add	hl,de
3960+  54F2 CD 23 55    A54F2:	call	A5523			; setup days in februari
3961+  54F5 3E 01       	ld	a,001H
3962+  54F7 11 2B F2    	ld	de,YF22B
3963+  54FA CD 15 55    	call	A5515
3964+  54FD 32 49 F2    	ld	(YF249),a
3965+  5500 2C          	inc	l
3966+  5501 7D          	ld	a,l
3967+  5502 32 48 F2    	ld	(YF248),a		; current day
3968+  5505 CD 88 55    A5505:	call	A5588
3969+  5508 D1          	pop	de
3970+  5509 C1          	pop	bc
3971+  550A C9          	ret
3972+  550B             
3973+  550B C5          A550B:	push	bc
3974+  550C D5          	push	de
3975+  550D 2A 4A F2    	ld	hl,(YF24A)
3976+  5510 CD 9D 55    	call	A559D			; calculate days since 1-1-1980
3977+  5513 18 F0       	jr	A5505
3978+  5515             
3979+  5515 EB          A5515:	ex	de,hl
3980+  5516 4E          	ld	c,(hl)
3981+  5517 23          	inc	hl
3982+  5518 EB          	ex	de,hl
3983+  5519 B7          	or	a
3984+  551A ED 42       	sbc	hl,bc
3985+  551C 38 03       	jr	c,A5521
3986+  551E 3C          	inc	a
3987+  551F 18 F4       	jr	A5515
3988+  5521             
3989+  5521 09          A5521:	add	hl,bc
3990+  5522 C9          	ret
3991+  5523             
3992+  5523 CD B5 F2    A5523:	call	XF2B5
3993+  5526 32 4A F2    	ld	(YF24A),a		; year (offset)
3994+  5529 E6 03       A5529:	and	003H
3995+  552B 3E 1C       	ld	a,28
3996+  552D 20 01       	jr	nz,A5530
3997+  552F 3C          	inc	a
3998+  5530 32 2C F2    A5530:	ld	(YF22B+1),a
3999+  5533 C9          	ret
4000+  5534             
4001+  5534             T5534:	defb	200,166,200,165,200,165,200,165
4001+  5534 C8A6C8A5C8A5C8A5
4002+  553C             
4003+  553C             ;	Subroutine	BDOS 2A (MSXDOS get date)
4004+  553C             ;	Inputs		
4005+  553C             ;	Outputs		________________________
4006+  553C             
4007+  553C AF          A553C:	xor	a
4008+  553D 32 06 F3    	ld	(YF306),a		; no CP/M call
4009+  5540 CD C0 54    	call	A54C0			; get time and date values
4010+  5543 2A 4A F2    	ld	hl,(YF24A)
4011+  5546 11 BC 07    	ld	de,1980
4012+  5549 19          	add	hl,de
4013+  554A ED 5B 48 F2 	ld	de,(YF248)		; current day and month
4014+  554E 3A 4E F2    	ld	a,(YF24E)
4015+  5551 C9          	ret
4016+  5552             
4017+  5552             ;	Subroutine	BDOS 2B (set date)
4018+  5552             ;	Inputs		
4019+  5552             ;	Outputs		________________________
4020+  5552             
4021+  5552 01 44 F8    A5552:	ld	bc,-1980
4022+  5555 09          	add	hl,bc
4023+  5556 30 42       	jr	nc,A559A		; year <1980, error
4024+  5558 7C          	ld	a,h
4025+  5559 B7          	or	a
4026+  555A 20 3E       	jr	nz,A559A		; yearoffset not in 1 byte, error
4027+  555C 7D          	ld	a,l
4028+  555D FE 78       	cp	120
4029+  555F 30 39       	jr	nc,A559A		; year >2099, error
4030+  5561 CD 29 55    	call	A5529			; setup febuari days
4031+  5564 1C          	inc	e
4032+  5565 1D          	dec	e
4033+  5566 28 32       	jr	z,A559A			; day 0, error
4034+  5568 7A          	ld	a,d
4035+  5569 B7          	or	a
4036+  556A 28 2E       	jr	z,A559A			; month 0, error
4037+  556C FE 0D       	cp	12+1
4038+  556E 30 2A       	jr	nc,A559A		; month >12, error
4039+  5570 E5          	push	hl
4040+  5571 21 2A F2    	ld	hl,YF22B-1
4041+  5574 85          	add	a,l
4042+  5575 6F          	ld	l,a
4043+  5576 30 01       	jr	nc,A5579
4044+  5578 24          	inc	h
4045+  5579 7E          A5579:	ld	a,(hl)			; days in month
4046+  557A E1          	pop	hl
4047+  557B BB          	cp	e
4048+  557C 38 1C       	jr	c,A559A			; invalid day, error
4049+  557E ED 53 48 F2 	ld	(YF248),de		; current day and month
4050+  5582 CD 9D 55    	call	A559D			; calculate days since 1-1-1980
4051+  5585 CD 15 41    	call	A4115			; store date (clockchip or otherwise)
4052+  5588 ED 4B 4C F2 A5588:	ld	bc,(YF24C)		; days since 1-1-1980
4053+  558C 11 07 00    	ld	de,7
4054+  558F 03          	inc	bc
4055+  5590 03          	inc	bc
4056+  5591 CD 2F 49    	call	A492F			; divide
4057+  5594 7D          	ld	a,l
4058+  5595 32 4E F2    	ld	(YF24E),a
4059+  5598 AF          	xor	a
4060+  5599 C9          	ret
4061+  559A             
4062+  559A 3E FF       A559A:	ld	a,0FFH
4063+  559C C9          	ret
4064+  559D             
4065+  559D 7D          A559D:	ld	a,l			; year (offset)
4066+  559E CD 23 55    	call	A5523			; setup days in februari
4067+  55A1 4D          	ld	c,l
4068+  55A2 CB 39       	srl	c
4069+  55A4 CB 39       	srl	c			; /4
4070+  55A6 06 00       	ld	b,0
4071+  55A8 11 B5 05    	ld	de,4*365+1
4072+  55AB CD 16 49    	call	A4916			; multiply
4073+  55AE 69          	ld	l,c
4074+  55AF 60          	ld	h,b
4075+  55B0 3A 4A F2    	ld	a,(YF24A)		; year (offset)
4076+  55B3 E6 03       	and	003H
4077+  55B5 87          	add	a,a
4078+  55B6 11 34 55    	ld	de,T5534
4079+  55B9 06 00       	ld	b,0
4080+  55BB 3C          	inc	a
4081+  55BC CD D2 55    	call	A55D2
4082+  55BF 11 2B F2    	ld	de,YF22B
4083+  55C2 3A 49 F2    	ld	a,(YF249)		; current month
4084+  55C5 CD D2 55    	call	A55D2
4085+  55C8 3A 48 F2    	ld	a,(YF248)		; current day
4086+  55CB 3D          	dec	a
4087+  55CC 4F          	ld	c,a
4088+  55CD 09          	add	hl,bc
4089+  55CE 22 4C F2    	ld	(YF24C),hl		; days since 1-1-1980
4090+  55D1 C9          	ret
4091+  55D2             
4092+  55D2 3D          A55D2:	dec	a
4093+  55D3 C8          	ret	z
4094+  55D4 EB          	ex	de,hl
4095+  55D5 4E          	ld	c,(hl)
4096+  55D6 23          	inc	hl
4097+  55D7 EB          	ex	de,hl
4098+  55D8 09          	add	hl,bc
4099+  55D9 18 F7       	jr	A55D2
4100+  55DB             
4101+  55DB             ;	Subroutine	BDOS 2C (MSXDOS get time)
4102+  55DB             ;	Inputs		
4103+  55DB             ;	Outputs		________________________
4104+  55DB             
4105+  55DB AF          A55DB:	xor	a
4106+  55DC 32 06 F3    	ld	(YF306),a		; no CP/M call
4107+  55DF CD C0 54    	call	A54C0			; get time and date values
4108+  55E2 60          	ld	h,b
4109+  55E3 69          	ld	l,c
4110+  55E4 AF          	xor	a
4111+  55E5 C9          	ret
4112+  55E6             
4113+  55E6             ;	Subroutine	BDOS 2D (set time)
4114+  55E6             ;	Inputs		
4115+  55E6             ;	Outputs		________________________
4116+  55E6             
4117+  55E6 44          A55E6:	ld	b,h
4118+  55E7 4D          	ld	c,l
4119+  55E8 78          	ld	a,b
4120+  55E9 FE 18       	cp	24
4121+  55EB 30 AD       	jr	nc,A559A
4122+  55ED 3E 3B       	ld	a,59
4123+  55EF B9          	cp	c
4124+  55F0 38 A8       	jr	c,A559A
4125+  55F2 BA          	cp	d
4126+  55F3 38 A5       	jr	c,A559A
4127+  55F5 7B          	ld	a,e
4128+  55F6 FE 64       	cp	100
4129+  55F8 30 A0       	jr	nc,A559A
4130+  55FA CD 30 41    	call	A4130			; store time (clockchip or otherwise)
4131+  55FD AF          	xor	a
4132+  55FE C9          	ret
4133+  55FF             
4134+  55FF             ;	Subroutine	BDOS 2E (set verify flag)
4135+  55FF             ;	Inputs		
4136+  55FF             ;	Outputs		________________________
4137+  55FF             
4138+  55FF 7B          A55FF:	ld	a,e
4139+  5600 32 0D F3    	ld	(RAWFLG),a
4140+  5603 C9          	ret
4141+  5604             
4142+  5604             ;	Subroutine	Validate FCB filename
4143+  5604             ;	Inputs		HL = address of FCB+1,DE = destination
4144+  5604             ;	Outputs		________________________
4145+  5604             ;	Remark		is copied to 0F1F4H
4146+  5604             
4147+  5604 7E          A5604:	ld	a,(hl)
4148+  5605 FE 20       	cp	" "
4149+  5607 37          	scf
4150+  5608 C8          	ret	z			; filename that start with a space is illegal, quit
4151+  5609 01 02 08    	ld	bc,00802H		; first do the filename, then the fileextension
4152+  560C FE E5       	cp	0E5H
4153+  560E 20 12       	jr	nz,A5622		; not the charcode also used as deleted file marker
4154+  5610 3E 05       	ld	a,005H
4155+  5612 12          	ld	(de),a
4156+  5613 23          	inc	hl
4157+  5614 13          	inc	de
4158+  5615 05          	dec	b			; use replacement charcode 005H, otherwise fileentry looks deleted
4159+  5616 3E E5       	ld	a,0E5H
4160+  5618 CD 81 56    	call	A5681			; is this a double byte 'header' char ?
4161+  561B 30 05       	jr	nc,A5622		; nope, no special action
4162+  561D 7E          	ld	a,(hl)
4163+  561E 12          	ld	(de),a
4164+  561F 23          	inc	hl
4165+  5620 13          	inc	de
4166+  5621 05          	dec	b			; yep, copy 'follow' char
4167+  5622 7E          A5622:	ld	a,(hl)
4168+  5623 CD 81 56    	call	A5681			; is this a double byte 'header' char ?
4169+  5626 30 09       	jr	nc,A5631		; nope, do upcasing and check
4170+  5628 12          	ld	(de),a
4171+  5629 23          	inc	hl
4172+  562A 13          	inc	de			; copy 'header' char
4173+  562B 05          	dec	b
4174+  562C 37          	scf
4175+  562D C8          	ret	z			; no 'follow' char, quit with error
4176+  562E 7E          	ld	a,(hl)
4177+  562F 18 36       	jr	A5667			; copy 'follow' char and continue
4178+  5631             
4179+  5631 3A 0E F3    A5631:	ld	a,(YF30E)
4180+  5634 A7          	and	a
4181+  5635 7E          	ld	a,(hl)
4182+  5636 28 14       	jr	z,A564C			; japanese have no accent chars,
4183+  5638 FE 80       	cp	080H
4184+  563A 38 10       	jr	c,A564C			; normal ASCII,
4185+  563C FE BA       	cp	0BAH
4186+  563E 30 0C       	jr	nc,A564C
4187+  5640 E5          	push	hl			; 080H-0B9H accent chars
4188+  5641 C5          	push	bc
4189+  5642 4F          	ld	c,a
4190+  5643 06 00       	ld	b,000H
4191+  5645 21 16 56    	ld	hl,T5696-080H
4192+  5648 09          	add	hl,bc
4193+  5649 7E          	ld	a,(hl)			; get the upcase version of the accent char
4194+  564A C1          	pop	bc
4195+  564B E1          	pop	hl
4196+  564C FE 61       A564C:	cp	"a"
4197+  564E 38 06       	jr	c,A5656
4198+  5650 FE 7B       	cp	"z"+1
4199+  5652 30 02       	jr	nc,A5656
4200+  5654 D6 20       	sub	020H			; lowercase char, make upcase
4201+  5656 FE 20       A5656:	cp	020H
4202+  5658 D8          	ret	c			; control code are illegal, quit with error
4203+  5659 E5          	push	hl
4204+  565A C5          	push	bc
4205+  565B 21 77 56    	ld	hl,T5677
4206+  565E 01 0A 00    	ld	bc,0000AH
4207+  5661 ED B1       	cpir				; one of the illegal chars ?
4208+  5663 C1          	pop	bc
4209+  5664 E1          	pop	hl
4210+  5665 37          	scf
4211+  5666 C8          	ret	z			; yep, quit with error
4212+  5667 12          A5667:	ld	(de),a			; copy char
4213+  5668 23          	inc	hl
4214+  5669 13          	inc	de
4215+  566A 10 B6       	djnz	A5622			; next char
4216+  566C 06 03       	ld	b,003H
4217+  566E 0D          	dec	c
4218+  566F 20 B1       	jr	nz,A5622		; now do the fileextension
4219+  5671 B7          	or	a			; flag no error
4220+  5672 7E          	ld	a,(hl)
4221+  5673 32 0C F3    	ld	(YF30C),a		; save the FCB EX byte
4222+  5676 C9          	ret
4223+  5677             
4224+  5677             T5677:	defb	".",34,"/[]:+=;,"
4224+  5677 2E222F5B5D3A2B3D3B2C
4225+  5681             
4226+  5681             ;	Subroutine	check if double byte header char
4227+  5681             ;	Inputs		________________________
4228+  5681             ;	Outputs		________________________
4229+  5681             
4230+  5681 E5          A5681:	push	hl
4231+  5682 21 0F F3    	ld	hl,YF30F
4232+  5685 BE          	cp	(hl)
4233+  5686 3F          	ccf
4234+  5687 30 0B       	jr	nc,A5694		; below (F30F), quit (not in range)
4235+  5689 23          	inc	hl
4236+  568A BE          	cp	(hl)
4237+  568B 38 07       	jr	c,A5694			; below (F310), quit (in range 1)
4238+  568D 23          	inc	hl
4239+  568E BE          	cp	(hl)
4240+  568F 3F          	ccf
4241+  5690 30 02       	jr	nc,A5694		; below (F311), quit (not in range)
4242+  5692 23          	inc	hl
4243+  5693 BE          	cp	(hl)
4244+  5694 E1          A5694:	pop	hl
4245+  5695 C9          	ret
4246+  5696             
4247+  5696             ;	Table 080H-0B9H accent upcase chars
4248+  5696             
4249+  5696             T5696:	defb	080H,09AH,"E" ,"A" ,08EH,"A" ,08FH,080H
4249+  5696 809A45418E418F80
4250+  569E             	defb	"E" ,"E" ,"E" ,"I" ,"I" ,"I" ,08EH,08FH
4250+  569E 4545454949498E8F
4251+  56A6             	defb	090H,092H,092H,"O" ,099H,"O" ,"U" ,"U"
4251+  56A6 9092924F994F5555
4252+  56AE             	defb	"Y" ,099H,09AH,09BH,09CH,09DH,09EH,09FH
4252+  56AE 59999A9B9C9D9E9F
4253+  56B6             	defb	"A" ,"I" ,"O" ,"U" ,0A5H,0A5H,0A6H,0A7H
4253+  56B6 41494F55A5A5A6A7
4254+  56BE             	defb	0A8H,0A9H,0AAH,0ABH,0ACH,0ADH,0AEH,0AFH
4254+  56BE A8A9AAABACADAEAF
4255+  56C6             	defb	0B0H,0B0H,0B2H,0B2H,0B4H,0B4H,0B6H,0B6H
4255+  56C6 B0B0B2B2B4B4B6B6
4256+  56CE B8 B8       	defb	0B8H,0B8H
4257+  56D0             
4258+  56D0             ;	Subroutine	unsupported CP/M BDOS calls
4259+  56D0             ;	Inputs		
4260+  56D0             ;	Outputs		________________________
4261+  56D0             
4262+  56D0 AF          A56D0:	xor	a
4263+  56D1 47          	ld	b,a
4264+  56D2 C9          	ret
4265+  56D3             
4266+  56D3             ;	Subroutine	BDOS handler (for DiskBASIC)
4267+  56D3             ;	Inputs		
4268+  56D3             ;	Outputs		________________________
4269+  56D3             
4270+  56D3 FB          A56D3:	ei
4271+  56D4 3E 01       	ld	a,1
4272+  56D6 32 06 F3    	ld	(YF306),a		; assume CP/M compatible call
4273+  56D9 79          	ld	a,c
4274+  56DA FE 31       	cp	031H			; valid BDOS function ?
4275+  56DC 30 F2       	jr	nc,A56D0		; nope, unsupported BDOS call
4276+  56DE D6 11       	sub	011H			; Search First BDOS function ?
4277+  56E0 20 04       	jr	nz,A56E6
4278+  56E2 ED 53 07 F3 	ld	(YF307),de		; yep, save address FCB for Search Next
4279+  56E6 3D          A56E6:	dec	a			; Search Next BDOS function ?
4280+  56E7 20 04       	jr	nz,A56ED
4281+  56E9 ED 5B 07 F3 	ld	de,(YF307)		; yep, get saved address FCB Search First
4282+  56ED E5          A56ED:	push	hl
4283+  56EE 21 00 57    	ld	hl,T5700
4284+  56F1 E3          	ex	(sp),hl			; after BDOS routine, fill HL in a CP/M compatible manner
4285+  56F2 E5          	push	hl
4286+  56F3 21 0D 57    	ld	hl,T570D
4287+  56F6 06 00       	ld	b,0
4288+  56F8 09          	add	hl,bc
4289+  56F9 09          	add	hl,bc
4290+  56FA 46          	ld	b,(hl)
4291+  56FB 23          	inc	hl
4292+  56FC 66          	ld	h,(hl)
4293+  56FD 68          	ld	l,b
4294+  56FE E3          	ex	(sp),hl
4295+  56FF C9          	ret				; start BDOS routine
4296+  5700             
4297+  5700 F5          T5700:	push	af
4298+  5701 3A 06 F3    	ld	a,(YF306)
4299+  5704 B7          	or	a			; CP/M compatible call
4300+  5705 28 04       	jr	z,A570B			; no, leave HL alone
4301+  5707 F1          	pop	af
4302+  5708 6F          	ld	l,a
4303+  5709 60          	ld	h,b			; CP/M compatible HL
4304+  570A C9          	ret
4305+  570B             
4306+  570B F1          A570B:	pop	af
4307+  570C C9          	ret
4308+  570D             
4309+  570D             T570D:	defw	A40A7,A5445,A53A7,A546E,A5474,A5465,A5454,A5462
4309+  570D A7404554A7536E547454655454546254
4310+  571D             	defw	A544E,XF1C9,A50E0,A543C,A41EF,A509F,A50D5,A4462
4310+  571D 4E54C9F1E0503C54EF419F50D5506244
4311+  572D             	defw	A456F,A4FB8,A5006,A436C,A4775,A477D,A461D,A4392
4311+  572D 6F45B84F06506C4375477D471D469243
4312+  573D             	defw	A504E,A50C4,A5058,A505D,A56D0,A56D0,A56D0,A56D0
4312+  573D 4E50C45058505D50D056D056D056D056
4313+  574D             	defw	A56D0,A4788,A4793,A501E,A50C8,A56D0,A47BE,A47B2
4313+  574D D056884793471E50C850D056BE47B247
4314+  575D             	defw	A47D1,A56D0,A553C,A5552,A55DB,A55E6,A55FF,A46BA
4314+  575D D147D0563C555255DB55E655FF55BA46
4315+  576D 20 47       	defw	A4720
4316+  576F             
4317+  576F             A576F:
4318+  576F                 if USE_ASCII8_ROM_MAPPER=1
4319+  576F~                ld a,ROM_BANK_0*2+1
4320+  576F~                ld (6800h),a    ;Set proper bank on second half of page 1
4321+  576F~                ld (7000h),a    ;To prevent ROM from initializing again on page 2
4322+  576F                 endif
4323+  576F             
4324+  576F                 if USE_ALTERNATIVE_PORTS=1
4325+  576F~                ld a,ROM_BANK_0+80h
4326+  576F~                ld (ROM_BANK_SWITCH),a
4327+  576F                 endif
4328+  576F             
4329+  576F CD 05 74        call DO_CHECK_CAN_INIT
4330+  5772 B7              or a
4331+  5773 CA 0C 58        jp z,A580C
4332+  5776 3D              dec a
4333+  5777 28 30           jr z,A57A9
4334+  5779 3D              dec a
4335+  577A C8              ret z
4336+  577B 3E 07       	ld	a,007H
4337+  577D DF          	rst	018H			; beep
4338+  577E C9              ret    
4339+  577F             
4340+  577F FF              ds 57A9h-$,0FFh
4341+  57A9             
4342+  57A9             ;	Subroutine	Initialize disksystem, first diskrom
4343+  57A9             
4344+  57A9 21 80 F3    A57A9:	ld	hl,0F380H+MYSIZE
4345+  57AC 11 C9 F1    	ld	de,XF1C9
4346+  57AF A7          	and	a
4347+  57B0 ED 52       	sbc	hl,de			; bytes needed for static workarea+workarea driver
4348+  57B2 D4 E8 5E    	call	nc,A5EE8		; allocate memory (adjust BASIC areapointers)
4349+  57B5 D8          	ret	c			; failed, quit
4350+  57B6 E5          A57B6:	push	hl
4351+  57B7 21 49 FE    	ld	hl,XF1C9-0F380H
4352+  57BA 01 C9 F1    	ld	bc,XF1C9
4353+  57BD AF          A57BD:	xor	a
4354+  57BE 02          	ld	(bc),a
4355+  57BF 03          	inc	bc
4356+  57C0 23          	inc	hl
4357+  57C1 7D          	ld	a,l
4358+  57C2 B4          	or	h
4359+  57C3 20 F8       	jr	nz,A57BD		; clear static workarea
4360+  57C5 22 AB F6    	ld	(AUTLIN),hl		; biggest sectorsize sofar = 0
4361+  57C8 06 14       	ld	b,4*2+4*3
4362+  57CA 21 21 FB    	ld	hl,YFB21
4363+  57CD 77          A57CD:	ld	(hl),a
4364+  57CE 23          	inc	hl
4365+  57CF 10 FC       	djnz	A57CD			; clear DRVTBL, DRVINT
4366+  57D1 21 4F F2    	ld	hl,XF24F
4367+  57D4 06 69       	ld	b,069H
4368+  57D6 36 C9       A57D6:	ld	(hl),0C9H
4369+  57D8 23          	inc	hl
4370+  57D9 10 FB       	djnz	A57D6			; init disksystem hooks
4371+  57DB 3E DB       	ld	a,0DBH
4372+  57DD 21 A8 C9    	ld	hl,0C9A8H
4373+  57E0 32 65 F3    	ld	(XF365+0),a
4374+  57E3 22 66 F3    	ld	(XF365+1),hl		; read primairy slotregister entry
4375+  57E6 3E 06       	ld	a,006H
4376+  57E8                 if INVERT_CTRL_KEY = 1
4377+  57E8~                call    SNSMAT_AND_INVERT_CTRL
4378+  57E8                 else
4379+  57E8 CD 41 01    	call	SNSMAT
4380+  57EB                 endif
4381+  57EB E6 02       	and	002H
4382+  57ED 32 3F F3    	ld	(YF33F),a		; saved CTRL key status for panthom drive
4383+  57F0 3E 07       	ld	a,007H
4384+  57F2 DF          	rst	018H			; beep
4385+  57F3 21 07 58    	ld	hl,T5807
4386+  57F6 11 CB FE    	ld	de,H.RUNC
4387+  57F9 01 05 00    	ld	bc,5
4388+  57FC ED B0       	ldir
4389+  57FE CD 2D 40    	call	A402D
4390+  5801 32 CC FE    	ld	(H.RUNC+1),a		; init RUNC hook, to intialize further when the interpeter is initialized
4391+  5804 D1          	pop	de			; base diskdriver workarea
4392+  5805 18 1E       	jr	A5825
4393+  5807             
4394+  5807 F7          T5807:	rst	030H
4395+  5808 00          	defb	0
4396+  5809 97 58       	defw	A5897
4397+  580B C9          	ret
4398+  580C             
4399+  580C             ;	Subroutine	Initialize disksystem, not the first diskrom
4400+  580C             
4401+  580C 21 21 FB    A580C:	ld	hl,YFB21		; DRVTBL
4402+  580F 06 04       	ld	b,4			; 4 diskroms
4403+  5811 AF          	xor	a
4404+  5812 86          A5812:	add	a,(hl)
4405+  5813 DA CC 5E    	jp	c,A5ECC			; invalid DRVTBL, error
4406+  5816 23          	inc	hl
4407+  5817 23          	inc	hl
4408+  5818 10 F8       	djnz	A5812
4409+  581A FE 08       	cp	8			; 8 or more drives ?
4410+  581C D0          	ret	nc			; yep, no more drives!
4411+  581D 21 00 00    	ld	hl,MYSIZE		; number of bytes for workarea driver
4412+  5820 CD E8 5E    	call	A5EE8			; allocate memory (adjust BASIC areapointers)
4413+  5823 D8          	ret	c			; failed, quit
4414+  5824 EB          	ex	de,hl
4415+  5825             
4416+  5825 CD CD 5F    A5825:	call	A5FCD			; get my SLTWRK entry
4417+  5828 73          	ld	(hl),e
4418+  5829 23          	inc	hl
4419+  582A 72          	ld	(hl),d			; save base workarea in SLTWRK
4420+  582B 2A AB F6    	ld	hl,(AUTLIN)
4421+  582E 11 00 02    	ld	de,SECLEN
4422+  5831 E7          	rst	020H			; SECLEN sofar big enough ?
4423+  5832 30 04       	jr	nc,A5838
4424+  5834 ED 53 AB F6 	ld	(AUTLIN),de		; nop, adjust
4425+  5838 11 21 FB    A5838:	ld	de,YFB21		; DRVTBL
4426+  583B 01 00 04    	ld	bc,00400H		; 4 diskroms
4427+  583E 1A          A583E:	ld	a,(de)
4428+  583F A7          	and	a
4429+  5840 28 09       	jr	z,A584B			; free entry, use it
4430+  5842 81          	add	a,c
4431+  5843 4F          	ld	c,a
4432+  5844 13          	inc	de
4433+  5845 13          	inc	de
4434+  5846 10 F6       	djnz	A583E			; next entry
4435+  5848 C3 CC 5E    	jp	A5ECC			; none free, error
4436+  584B             
4437+  584B 3A 3F F3    A584B:	ld	a,(YF33F)
4438+  584E A7          	and	a
4439+  584F 79          	ld	a,c			; phantom flag
4440+  5850 CD 87 74    A5850:	call	DRIVES			; query no. of drives
4441+  5853 85          	add	a,l
4442+  5854 FE 09       	cp	9
4443+  5856 7D          	ld	a,l			; more as 8 drives ?
4444+  5857 38 03       	jr	c,A585C			; nop, ok
4445+  5859 3E 08       	ld	a,8
4446+  585B 91          	sub	c			; as much as possible
4447+  585C C5          A585C:	push	bc
4448+  585D 12          	ld	(de),a			; save drives
4449+  585E 13          	inc	de
4450+  585F CD 2D 40    	call	A402D
4451+  5862 12          	ld	(de),a			; save slotid diskrom
4452+  5863 C1          	pop	bc			; drivenumber
4453+  5864 06 00       	ld	b,0
4454+  5866 21 55 F3    	ld	hl,YF355
4455+  5869 09          	add	hl,bc
4456+  586A 09          	add	hl,bc			; DPBTBL
4457+  586B E5          	push	hl
4458+  586C 1B          	dec	de
4459+  586D 1A          	ld	a,(de)
4460+  586E F5          	push	af
4461+  586F 4F          	ld	c,a			; drives
4462+  5870 11 15 00    	ld	de,21
4463+  5873 CD 16 49    	call	A4916			; * size of DPB
4464+  5876 69          	ld	l,c
4465+  5877 60          	ld	h,b			; number of bytes for the DPBs
4466+  5878 CD C8 5E    	call	A5EC8			; allocate memory (adjust BASIC areapointers, halt when error)
4467+  587B EB          	ex	de,hl
4468+  587C F1          	pop	af
4469+  587D E1          	pop	hl
4470+  587E 73          A587E:	ld	(hl),e
4471+  587F 23          	inc	hl
4472+  5880 72          	ld	(hl),d			; save in DPBTBL
4473+  5881 23          	inc	hl
4474+  5882 E5          	push	hl
4475+  5883 21 E6 7C    	ld	hl,DEFDPB
4476+  5886 01 15 00    	ld	bc,21
4477+  5889 ED B0       	ldir				; initialize DPB
4478+  588B E1          	pop	hl
4479+  588C 3D          	dec	a
4480+  588D 20 EF       	jr	nz,A587E		; next drive
4481+  588F CD CE 74    	call	INIENV			; initialize driver workarea
4482+  5892             
4483+  5892 C3 4E 74        jp DO_SET_DEVICE
4484+  5895             
4485+  5895 FF              ds 5897h-$,0FFh
4486+  5897             
4487+  5897             ;	Subroutine	H.RUNC interceptor
4488+  5897             ;	Inputs		-
4489+  5897             ;	Outputs		-
4490+  5897             ;	Remark		Control is passed to this routine when the BASIC interpreter is initialized
4491+  5897             ;			There are two ways: a BASIC program in ROM is started OR at the start of MSX-BASIC
4492+  5897             
4493+  5897 21 CB FE    A5897:	ld	hl,H.RUNC
4494+  589A 06 05       	ld	b,5
4495+  589C 36 C9       A589C:	ld	(hl),0C9H
4496+  589E 23          	inc	hl
4497+  589F 10 FB       	djnz	A589C			; clear RUNC hook
4498+  58A1             
4499+  58A1 CD 68 74        call DO_RUNC_INTERCEPTOR
4500+  58A4 D8              ret c
4501+  58A5             
4502+  58A5 FF              ds 58A8h-$,0FFh
4503+  58A8             
4504+  58A8 CD 2D 62    A58A8:	call	A622D			; hook H.LOPD when H.CLEA is hooked (for register system bottom)
4505+  58AB 32 48 F3    	ld	(YF348),a		; disksystem diskrom slotid
4506+  58AE 21 97 73    	ld	hl,A7397
4507+  58B1 11 C9 F1    	ld	de,XF1C9
4508+  58B4 01 6E 00    	ld	bc,0006EH
4509+  58B7 ED B0       	ldir				; initialize some static disksystem variables
4510+  58B9 21 34 00    	ld	hl,M0034
4511+  58BC 11 0F F3    	ld	de,YF30F
4512+  58BF 01 04 00    	ld	bc,4
4513+  58C2 ED B0       	ldir				; initialize double byte header char table
4514+  58C4 3A 2B 00    	ld	a,(IDBYT0)
4515+  58C7 0F          	rrca
4516+  58C8 0F          	rrca
4517+  58C9 0F          	rrca
4518+  58CA 0F          	rrca
4519+  58CB E6 07       	and	007H
4520+  58CD 32 0E F3    	ld	(YF30E),a		; date format
4521+  58D0 3E FF       	ld	a,0FFH
4522+  58D2 32 41 F2    	ld	(YF241),a		; invalid datasector buffer
4523+  58D5 32 46 F2    	ld	(YF246),a		; invalid directorysector buffer
4524+  58D8 32 4D F2    	ld	(YF24C+1),a		; days since 1-1-1980 is 65280 (0FF00H) (somewhere in the year 2158), this is inpossible, so when no clockchip this is updated!
4525+  58DB 3E 0D       	ld	a,00DH
4526+  58DD 32 5B F5    	ld	(YCONBF+130),a		; ?? end marker con buffer
4527+  58E0 3E 07       	ld	a,7
4528+  58E2 32 45 F3    	ld	(YF345),a		; max number of FCB's is 7
4529+  58E5 21 B5 05    	ld	hl,1461
4530+  58E8 22 3B F3    	ld	(YF33B),hl		; default date when no clockchip is 1-1-1984
4531+  58EB 06 08       	ld	b,8
4532+  58ED 21 68 F3    	ld	hl,XF368
4533+  58F0 36 C3       A58F0:	ld	(hl),0C3H
4534+  58F2 23          	inc	hl
4535+  58F3 23          	inc	hl
4536+  58F4 23          	inc	hl
4537+  58F5 10 F9       	djnz	A58F0			; initialize jumptable
4538+  58F7 2A AB F6    	ld	hl,(AUTLIN)
4539+  58FA E5          	push	hl			; size of the biggest sector
4540+  58FB CD C8 5E    	call	A5EC8			; allocate memory (adjust BASIC areapointers, halt when error)
4541+  58FE 22 4D F3    	ld	(SECBUF),hl		; allocate sectorbuffer
4542+  5901 E1          	pop	hl			; size of the biggest sector
4543+  5902 E5          	push	hl
4544+  5903 CD C8 5E    	call	A5EC8			; allocate memory (adjust BASIC areapointers, halt when error)
4545+  5906 22 4F F3    	ld	(YF34F),hl		; allocate datasector buffer
4546+  5909 E1          	pop	hl			; size of the biggest sector
4547+  590A CD C8 5E    	call	A5EC8			; allocate memory (adjust BASIC areapointers, halt when error)
4548+  590D 22 51 F3    	ld	(YF351),hl		; allocate dirsector buffer
4549+  5910 21 21 FB    	ld	hl,YFB21		; DRVTBL
4550+  5913 06 04       	ld	b,4			; 4 diskroms
4551+  5915 AF          	xor	a
4552+  5916 86          A5916:	add	a,(hl)
4553+  5917 DA CC 5E    	jp	c,A5ECC			; invalid DRVTBL, error
4554+  591A 23          	inc	hl
4555+  591B 23          	inc	hl
4556+  591C 10 F8       	djnz	A5916
4557+  591E FE 09       	cp	9			; more as 8 drives ?
4558+  5920 D2 CC 5E    	jp	nc,A5ECC		; yep, error
4559+  5923 32 47 F3    	ld	(YF347),a		; drives in system
4560+  5926 47          	ld	b,a			; number of drives
4561+  5927 0E 00       	ld	c,0			; drive 0
4562+  5929 21 55 F3    	ld	hl,YF355
4563+  592C 5E          A592C:	ld	e,(hl)
4564+  592D 23          	inc	hl
4565+  592E 56          	ld	d,(hl)			; DPB of drive
4566+  592F 23          	inc	hl
4567+  5930 E5          	push	hl
4568+  5931 D5          	push	de
4569+  5932 DD E1       	pop	ix
4570+  5934 DD 71 00    	ld	(ix+0),c		; set drivenumber in DPB
4571+  5937 0C          	inc	c
4572+  5938 C5          	push	bc
4573+  5939 DD 4E 02    	ld	c,(ix+2)
4574+  593C DD 46 03    	ld	b,(ix+3)		; sectorsize
4575+  593F DD 5E 10    	ld	e,(ix+16)
4576+  5942 16 00       	ld	d,0			; number of sectors per FAT
4577+  5944 CD 16 49    	call	A4916			; * FAT size
4578+  5947 03          	inc	bc			; and a FAT buffer flag
4579+  5948 69          	ld	l,c
4580+  5949 60          	ld	h,b			; size of the FAT buffer
4581+  594A CD C8 5E    	call	A5EC8			; allocate memory (adjust BASIC areapointers, halt when error)
4582+  594D 22 49 F3    	ld	(YF349),hl		; base system bottom sofar
4583+  5950 36 FF       	ld	(hl),0FFH		; flag invalid FAT buffer
4584+  5952 23          	inc	hl
4585+  5953 DD 75 13    	ld	(ix+19),l
4586+  5956 DD 74 14    	ld	(ix+20),h		; pointer to FAT buffer
4587+  5959 C1          	pop	bc
4588+  595A E1          	pop	hl
4589+  595B 10 CF       	djnz	A592C			; next drive
4590+  595D 21 27 F3    	ld	hl,XF327
4591+  5960 36 3E       	ld	(hl),03EH
4592+  5962 23          	inc	hl
4593+  5963 36 1A       	ld	(hl),01AH
4594+  5965 06 08       	ld	b,2*5-2
4595+  5967 23          A5967:	inc	hl
4596+  5968 36 C9       	ld	(hl),0C9H
4597+  596A 10 FB       	djnz	A5967			; initialize MSX-serial hooks
4598+  596C 21 27 F3    	ld	hl,XF327
4599+  596F 22 72 F3    	ld	(XF371+1),hl
4600+  5972 21 2C F3    	ld	hl,XF32C
4601+  5975 22 75 F3    	ld	(XF374+1),hl
4602+  5978 21 31 F3    	ld	hl,XF331
4603+  597B 22 7E F3    	ld	(XF37D+1),hl		; initialize jumptable
4604+  597E 21 2F 7D    	ld	hl,M7D2F
4605+  5981 3A C1 FC    	ld	a,(EXPTBL+0)
4606+  5984 CD 0C 00    	call	RDSLT
4607+  5987 F5          	push	af
4608+  5988 23          	inc	hl
4609+  5989 3A C1 FC    	ld	a,(EXPTBL+0)
4610+  598C CD 0C 00    	call	RDSLT
4611+  598F D1          	pop	de
4612+  5990 67          	ld	h,a
4613+  5991 6A          	ld	l,d			; read startup screen address
4614+  5992 E5          	push	hl
4615+  5993 DD E1       	pop	ix
4616+  5995 FD 2A C0 FC 	ld	iy,(EXPTBL-1+0)
4617+  5999 CD 1C 00    	call	CALSLT			; initialize BASIC screenmode
4618+  599C CD B8 40    	call	A40B8			; check for and initialize clockchip
4619+  599F CD 6E 5C    	call	A5C6E			; initialize hooks
4620+  59A2 3A C1 FC    	ld	a,(EXPTBL+0)
4621+  59A5 32 41 F3    	ld	(RAMAD0),a
4622+  59A8 32 42 F3    	ld	(RAMAD1),a		; assume no ram available for page 0 and 1
4623+  59AB CD 98 5F    	call	A5F98
4624+  59AE 32 43 F3    	ld	(RAMAD2),a		; slotid of current page 2
4625+  59B1 CD 95 5F    	call	A5F95
4626+  59B4 32 44 F3    	ld	(RAMAD3),a		; slotid of current page 3
4627+  59B7 0E 00       	ld	c,000H
4628+  59B9 CD 52 5E    	call	A5E52			; search ram in page 0
4629+  59BC 38 03       	jr	c,A59C1
4630+  59BE 32 41 F3    	ld	(RAMAD0),a		; found, set ram slotid page 0
4631+  59C1 0E 40       A59C1:	ld	c,040H
4632+  59C3 CD 52 5E    	call	A5E52			; search ram in page 1
4633+  59C6 38 03       	jr	c,A59CB
4634+  59C8 32 42 F3    	ld	(RAMAD1),a		; found, set ram slotid page 1
4635+  59CB 31 00 C2    A59CB:	ld	sp,0C200H		; switch to a temporary stack, just above temp startbuffer
4636+  59CE 3A DA FE    	ld	a,(H.STKE+0)
4637+  59D1 FE C9       	cp	0C9H			; STKE hook set ?
4638+  59D3 28 06       	jr	z,A59DB			; nop, cont
4639+  59D5 DD 21 17 7D 	ld	ix,M7D17
4640+  59D9 18 12       	jr	A59ED			; skip BASIC extension ROMs and transfer control
4641+  59DB             
4642+  59DB 21 C9 FC    A59DB:	ld	hl,SLTATR
4643+  59DE 06 40       	ld	b,040H
4644+  59E0 7E          A59E0:	ld	a,(hl)
4645+  59E1 87          	add	a,a			; TEXT extension ?
4646+  59E2 38 05       	jr	c,A59E9			; yep, start it
4647+  59E4 23          	inc	hl
4648+  59E5 10 F9       	djnz	A59E0
4649+  59E7 18 0A       	jr	A59F3			; no TEXT extension ROM found,
4650+  59E9             
4651+  59E9 DD 21 14 7E A59E9:	ld	ix,M7E14		; start BASIC program in ROM
4652+  59ED CD 16 5C    A59ED:	call	A5C16			; initialize diskbasic
4653+  59F0 C3 59 01    	jp	CALBAS
4654+  59F3             
4655+  59F3 21 3A 5B    A59F3:	ld	hl,A5B3A
4656+  59F6 E5          	push	hl			; if quit anywhere start diskbasic
4657+  59F7 CD E7 5A    	call	A5AE7			; read bootsector
4658+  59FA D8          	ret	c			; failed, start diskbasic
4659+  59FB CD DB 5A    	call	A5ADB			; start bootcode with Cx reset (some disk can take control from here)
4660+  59FE 2A 48 FC    	ld	hl,(BOTTOM)
4661+  5A01 11 00 80    	ld	de,08000H
4662+  5A04 E7          	rst	020H			; check if ram on both page 3 and 2
4663+  5A05 C0          	ret	nz			; nope, start diskbasic
4664+  5A06 21 41 F3    	ld	hl,RAMAD0
4665+  5A09 3A C1 FC    	ld	a,(EXPTBL+0)
4666+  5A0C BE          	cp	(hl)
4667+  5A0D C8          	ret	z			; no ram available on page 0, start diskbasic
4668+  5A0E 23          	inc	hl
4669+  5A0F BE          	cp	(hl)
4670+  5A10 C8          	ret	z			; no ram available on page 1, start diskbasic
4671+  5A11             
4672+  5A11             ; MSXDOS requirement are met, try starting it
4673+  5A11             
4674+  5A11 AF          A5A11:	XOR	A
4675+  5A12 CD 9A 60    	CALL	A609A			; invalidate FAT buffer drive 0
4676+  5A15 2A 49 F3    	LD	HL,(YF349)
4677+  5A18 22 4B F3    	LD	(YF34B),HL		; bottom MSX-DOS system
4678+  5A1B CD E7 5A    	CALL	A5AE7			; try reading bootsector of drive 0
4679+  5A1E DA 3A 5B    	JP	C,A5B3A			; error, start diskbasic
4680+  5A21 32 46 F3    	LD	(YF346),A		; flag bootable disk
4681+  5A24 3A 41 F3    	LD	A,(RAMAD0)
4682+  5A27 26 00       	LD	H,00H
4683+  5A29 CD C2 64    	CALL	C64C2			; calculate masks
4684+  5A2C 37          	SCF
4685+  5A2D F4 A2 64    	CALL	P,C64A2			; primairy slot, change it
4686+  5A30 DC AF 64    	CALL	C,C64AF			; secundairy slot, change it
4687+  5A33 AF          	XOR	A
4688+  5A34 6F          	LD	L,A
4689+  5A35 67          	LD	H,A
4690+  5A36 77          J5A36:	LD	(HL),A
4691+  5A37 2C          	INC	L
4692+  5A38 20 FC       	JR	NZ,J5A36		; clear 0000-00FF
4693+  5A3A 01 26 00    	LD	BC,38			; size of the XFER routine
4694+  5A3D CD AD 5E    	CALL	A5EAD			; allocate MSXDOS memory (halt when error)
4695+  5A40 22 6F F3    	LD	(XFER+1),HL
4696+  5A43 EB          	EX	DE,HL
4697+  5A44 21 7B 63    	LD	HL,I637B
4698+  5A47 ED B0       	LDIR				; install XFER routine
4699+  5A49 01 19 00    	LD	BC,25			; size of the ENARAM and ENAKRN routine
4700+  5A4C CD AD 5E    	CALL	A5EAD			; allocate MSXDOS memory (halt when error)
4701+  5A4F 5D          	LD	E,L
4702+  5A50 54          	LD	D,H
4703+  5A51 22 69 F3    	LD	(XF368+1),HL
4704+  5A54 23          	INC	HL
4705+  5A55 23          	INC	HL
4706+  5A56 22 6C F3    	LD	(XF36B+1),HL
4707+  5A59 21 A1 63    	LD	HL,I63A1
4708+  5A5C ED B0       	LDIR				; install ENAKRN and ENARAM
4709+  5A5E 01 68 01    	LD	BC,360			; size of the slotswitching routines
4710+  5A61 CD AD 5E    	CALL	A5EAD			; allocate MSXDOS memory (halt when error)
4711+  5A64 E5          	PUSH	HL
4712+  5A65 EB          	EX	DE,HL
4713+  5A66 21 F4 63    	LD	HL,C63F4
4714+  5A69 E5          	PUSH	HL
4715+  5A6A ED B0       	LDIR				; install slot switching routines
4716+  5A6C C1          	POP	BC
4717+  5A6D D1          	POP	DE
4718+  5A6E D5          	PUSH	DE
4719+  5A6F 21 17 01    	LD	HL,R0116-C63F4+1
4720+  5A72 19          	ADD	HL,DE
4721+  5A73 36 3B       	LD	(HL),LOW X003B
4722+  5A75 23          	INC	HL
4723+  5A76 36 00       	LD	(HL),HIGH X003B		; change "save and change secundairy slotregister" routine
4724+  5A78 21 BA 63    	LD	HL,T63BA
4725+  5A7B CD 06 63    	CALL	A6306			; relocate
4726+  5A7E 21 0F 5B    	LD	HL,I5B0F
4727+  5A81 AF          	XOR	A
4728+  5A82 47          	LD	B,A
4729+  5A83 57          	LD	D,A
4730+  5A84 5E          J5A84:	LD	E,(HL)
4731+  5A85 BB          	CP	E
4732+  5A86 28 10       	JR	Z,J5A98			; end of table, continue
4733+  5A88 23          	INC	HL
4734+  5A89 4E          	LD	C,(HL)
4735+  5A8A 23          	INC	HL
4736+  5A8B E3          	EX	(SP),HL
4737+  5A8C 09          	ADD	HL,BC
4738+  5A8D EB          	EX	DE,HL
4739+  5A8E 36 C3       	LD	(HL),0C3H
4740+  5A90 23          	INC	HL
4741+  5A91 73          	LD	(HL),E
4742+  5A92 23          	INC	HL
4743+  5A93 72          	LD	(HL),D
4744+  5A94 EB          	EX	DE,HL
4745+  5A95 E3          	EX	(SP),HL
4746+  5A96 18 EC       	JR	J5A84			; make jumptable
4747+  5A98             
4748+  5A98 E1          J5A98:	POP	HL
4749+  5A99 21 5C 65    	LD	HL,C655C
4750+  5A9C 11 3B 00    	LD	DE,X003B
4751+  5A9F 01 1A 00    	LD	BC,26
4752+  5AA2 ED B0       	LDIR				; install slotswitching helper routines
4753+  5AA4 01 45 00    	LD	BC,69			; size of the interrupt routine
4754+  5AA7 CD AD 5E    	CALL	A5EAD			; allocate MSXDOS memory (halt when error)
4755+  5AAA E5          	PUSH	HL
4756+  5AAB EB          	EX	DE,HL
4757+  5AAC 21 36 63    	LD	HL,I6336
4758+  5AAF E5          	PUSH	HL
4759+  5AB0 ED B0       	LDIR				; install interrupt routine
4760+  5AB2 C1          	POP	BC
4761+  5AB3 D1          	POP	DE
4762+  5AB4 D5          	PUSH	DE
4763+  5AB5 21 2E 63    	LD	HL,T632E
4764+  5AB8 CD 06 63    	CALL	A6306			; relocate
4765+  5ABB E1          	POP	HL
4766+  5ABC 3E C3       	LD	A,0C3H
4767+  5ABE 32 38 00    	LD	(KEYINT+0),A
4768+  5AC1 22 39 00    	LD	(KEYINT+1),HL		; KEYINT
4769+  5AC4 11 22 00    	LD	DE,34
4770+  5AC7 19          	ADD	HL,DE
4771+  5AC8 ED 5B 4B F3 	LD	DE,(YF34B)
4772+  5ACC 73          	LD	(HL),E
4773+  5ACD 23          	INC	HL
4774+  5ACE 72          	LD	(HL),D			; start of KEYINT stack
4775+  5ACF 01 A0 00    	LD	BC,160			; size of the KEYINT stack
4776+  5AD2 CD AD 5E    	CALL	A5EAD			; allocate MSXDOS memory (halt when error)
4777+  5AD5 3E C3       	LD	A,0C3H
4778+  5AD7 CD 62 5C    	CALL	A5C62			; enable XFER, ENAKRN and ENARAM routines
4779+  5ADA 37          	SCF
4780+  5ADB 21 23 F3    A5ADB:	LD	HL,YF323		; address diskerror handler pointer
4781+  5ADE 11 68 F3    	LD	DE,XF368		; ENAKRN routine
4782+  5AE1 3A 40 F3    	LD	A,(YF340)		; coldboot flag
4783+  5AE4 C3 1E C0    	JP	YC000+01EH		; start bootloader
4784+  5AE7             
4785+  5AE7             ;	Subroutine	read bootsector of drive 0 and validate
4786+  5AE7             ;	Inputs		________________________
4787+  5AE7             ;	Outputs		________________________
4788+  5AE7             
4789+  5AE7 3A E7 7C    A5AE7:	LD	A,(DEFDPB+1)
4790+  5AEA 4F          	LD	C,A			; default mediadescriptor
4791+  5AEB 06 01       	LD	B,1			; 1 sector
4792+  5AED 2A 51 F3    	LD	HL,(YF351)		; use the dir sectorbuffer
4793+  5AF0 E5          	PUSH	HL
4794+  5AF1 AF          	XOR	A			; drive 0, read
4795+  5AF2 5F          	LD	E,A
4796+  5AF3 57          	LD	D,A			; sector 0
4797+  5AF4 CD 44 01    	CALL	PHYDIO			; read sector
4798+  5AF7 3E FF       	LD	A,0FFH
4799+  5AF9 32 46 F2    	LD	(YF246),A		; dirsector buffer is invalid
4800+  5AFC E1          	POP	HL
4801+  5AFD D8          	RET	C			; error, quit
4802+  5AFE 7E          	LD	A,(HL)
4803+  5AFF 11 00 C0    	LD	DE,YC000
4804+  5B02 01 00 01    	LD	BC,256
4805+  5B05 ED B0       	LDIR				; copy bootloader to C000
4806+  5B07 FE EB       	CP	0EBH
4807+  5B09 C8          	RET	Z			; valid bootloader, quit
4808+  5B0A FE E9       	CP	0E9H
4809+  5B0C C8          	RET	Z			; valid bootloader, quit
4810+  5B0D 37          	SCF
4811+  5B0E C9          	RET
4812+  5B0F             
4813+  5B0F 0C 00       I5B0F:	DEFB	LOW RDSLT,C63F4-C63F4
4814+  5B11 14 21       	DEFB	LOW WRSLT,C6415-C63F4
4815+  5B13 30 2E       	DEFB	LOW CALLF,C6443-C6415
4816+  5B15 1C 12       	DEFB	LOW CALSLT,C6455-C6443
4817+  5B17 24 47       	DEFB	LOW ENASLT,J649C-C6455
4818+  5B19 00          	DEFB	0
4819+  5B1A             
4820+  5B1A             T5B1A:	defb	0,"AUTOEXECBAS",0
4820+  5B1A 004155544F4558454342415300
4821+  5B27             
4822+  5B27             T5B27:	defb	"RUN",34,"AUTOEXEC.BAS",0
4822+  5B27 52554E224155544F455845432E42415300
4823+  5B38             
4824+  5B38 92 5B       T5B38:	defw	A5B92			; start DiskBASIC in direct mode
4825+  5B3A             
4826+  5B3A             ;	Subroutine	Start DiskBASIC
4827+  5B3A             
4828+  5B3A CD 60 5C    A5B3A:	call	A5C60			; disable XFER,ENARAM,ENAKRN routines
4829+  5B3D 21 27 5B    	ld	hl,T5B27
4830+  5B40 11 68 F5    	ld	de,BUF+10
4831+  5B43 01 11 00    	ld	bc,17
4832+  5B46 ED B0       	ldir				; copy RUN"AUTOEXEC.BAS in BUF
4833+  5B48 21 40 F3    	ld	hl,YF340
4834+  5B4B 7E          	ld	a,(hl)
4835+  5B4C A7          	and	a			; is this a warm boot ?
4836+  5B4D 74          	ld	(hl),h			; next boot is a warm boot
4837+  5B4E 20 1E       	jr	nz,A5B6E		; yep, no autoexec.bas but a parameter from MSXDOS ?
4838+  5B50             
4839+  5B50             ;	Subroutine	try to start AUTOEXEC.BAS
4840+  5B50             
4841+  5B50 32 46 F3    	ld	(YF346),a		; flag CALL SYSTEM invalid
4842+  5B53 21 38 5B    	ld	hl,T5B38
4843+  5B56 22 23 F3    	ld	(YF323),hl		; setup disk errorhandler
4844+  5B59 21 1A 5B    	ld	hl,T5B1A
4845+  5B5C 11 79 F5    	ld	de,BUF+10+17
4846+  5B5F 01 25 00    	ld	bc,37
4847+  5B62 D5          	push	de
4848+  5B63 ED B0       	ldir				; setup FCB for autoexec.bas
4849+  5B65 D1          	pop	de
4850+  5B66 CD 62 44    	call	A4462			; open FCB
4851+  5B69 3C          	inc	a
4852+  5B6A 28 26       	jr	z,A5B92			; error, start DiskBASIC in direct mode (with date input)
4853+  5B6C 18 32       	jr	A5BA0			; no error, start DiskBASIC and run AUTOEXEC.BAS
4854+  5B6E             
4855+  5B6E 3A 00 00    A5B6E:	ld	a,(WBOOT)
4856+  5B71 FE C3       	cp	0C3H			; MSXDOS active ?
4857+  5B73 20 27       	jr	nz,A5B9C		; nope, start DiskBASIC in direct mode
4858+  5B75 21 80 00    	ld	hl,00080H
4859+  5B78 46          	ld	b,(hl)
4860+  5B79 04          	inc	b
4861+  5B7A 05          	dec	b
4862+  5B7B 28 1F       	jr	z,A5B9C			; no parameter specified (after the BASIC command), start DiskBASIC in direct mode
4863+  5B7D 23          A5B7D:	inc	hl
4864+  5B7E 7E          	ld	a,(hl)
4865+  5B7F FE 20       	cp	" "
4866+  5B81 20 04       	jr	nz,A5B87
4867+  5B83 10 F8       	djnz	A5B7D			; remove spaces in front
4868+  5B85 18 15       	jr	A5B9C			; no parameter specified, just start diskbasic
4869+  5B87             
4870+  5B87 AF          A5B87:	xor	a
4871+  5B88 48          	ld	c,b
4872+  5B89 47          	ld	b,a
4873+  5B8A 11 6C F5    	ld	de,BUF+14
4874+  5B8D ED B0       	ldir				; copy file name after the RUN" at BUF+10
4875+  5B8F 12          	ld	(de),a			; and a end of line marker
4876+  5B90 18 0E       	jr	A5BA0			; start DiskBASIC and run specified basicfile
4877+  5B92             
4878+  5B92             ;	Subroutine	start DiskBASIC in direct mode (cold boot)
4879+  5B92             
4880+  5B92 31 00 C2    A5B92:	ld	sp,0C200H		; switch to a temporary stack
4881+  5B95 3A 38 F3    	ld	a,(YF338)
4882+  5B98 A7          	and	a
4883+  5B99 CC 3F 5D    	call	z,A5D3F			; no clockchip, ask the date
4884+  5B9C             
4885+  5B9C             ;	Subroutine	start DiskBASIC in direct mode
4886+  5B9C             
4887+  5B9C AF          A5B9C:	xor	a
4888+  5B9D 32 6B F5    	ld	(BUF+13),a		; make it a ordinary RUN at BUF+10
4889+  5BA0             
4890+  5BA0             ;	Subroutine	start DiskBASIC
4891+  5BA0             
4892+  5BA0 31 00 C2    A5BA0:	ld	sp,0C200H		; switch to a temporary stack
4893+  5BA3 3A 43 F3    	ld	a,(RAMAD2)
4894+  5BA6 26 80       	ld	h,080H
4895+  5BA8 CD 24 00    	call	ENASLT			; ram on page 2
4896+  5BAB 3A C1 FC    	ld	a,(EXPTBL+0)
4897+  5BAE 26 00       	ld	h,000H
4898+  5BB0 CD 24 00    	call	ENASLT			; rom-bios on page 0
4899+  5BB3 2A 48 FC    	ld	hl,(BOTTOM)
4900+  5BB6 AF          	xor	a
4901+  5BB7 77          	ld	(hl),a			; before the program always a end of line marker
4902+  5BB8 23          	inc	hl
4903+  5BB9 22 76 F6    	ld	(TXTTAB),hl		; start of basictext space
4904+  5BBC 77          	ld	(hl),a
4905+  5BBD 23          	inc	hl
4906+  5BBE 77          	ld	(hl),a			; end of program marker
4907+  5BBF 23          	inc	hl
4908+  5BC0 22 C2 F6    	ld	(VARTAB),hl		; start of the variablespace
4909+  5BC3 21 FF FF    	ld	hl,0FFFFH
4910+  5BC6 22 1C F4    	ld	(CURLIN),hl		; interpreter in direct mode
4911+  5BC9 CD 16 5C    	call	A5C16			; initialize diskbasic
4912+  5BCC ED 7B 74 F6 	ld	sp,(STKTOP)
4913+  5BD0 3E FF       	ld	a,0FFH
4914+  5BD2 32 DE F3    	ld	(CNSDFG),a		; enable function keys
4915+  5BD5 3E 0C       	ld	a,00CH
4916+  5BD7 DF          	rst	018H			; clear screen
4917+  5BD8 DD 21 31 7D 	ld	ix,M7D31
4918+  5BDC CD 59 01    	call	CALBAS			; display BASIC startscreen
4919+  5BDF CD 86 5F    	call	A5F86
4920+  5BE2 0D 0A       	defb	13,10
4921+  5BE4             	defb	"Disk BASIC version 1.0",13,10
4921+  5BE4 4469736B2042415349432076657273696F6E20312E300D0A
4922+  5BFC 00          	defb	0
4923+  5BFD 21 73 41    	ld	hl,M4173
4924+  5C00 E5          	push	hl			; execute RUN command
4925+  5C01 21 67 F5    	ld	hl,BUF+10-1
4926+  5C04 E5          	push	hl			; basicpointer
4927+  5C05 21 9E F5    	ld	hl,BUF+64
4928+  5C08 E5          	push	hl
4929+  5C09 36 E1       	ld	(hl),0E1H
4930+  5C0B 23          	inc	hl
4931+  5C0C 36 C9       	ld	(hl),0C9H		; pop the basicpointer when returning
4932+  5C0E 3A C1 FC    	ld	a,(EXPTBL+0)
4933+  5C11 26 40       	ld	h,040H
4934+  5C13 C3 24 00    	jp	ENASLT			; enable basic-rom on page 1
4935+  5C16             
4936+  5C16             ;	Subroutine	initialize DiskBASIC environment
4937+  5C16             ;	Inputs		________________________
4938+  5C16             ;	Outputs		________________________
4939+  5C16             
4940+  5C16 21 AE 72    A5C16:	ld	hl,T72AE
4941+  5C19 22 23 F3    	ld	(YF323),hl		; setup diskerror handler
4942+  5C1C 21 6C 5C    	ld	hl,T5C6C
4943+  5C1F 22 25 F3    	ld	(YF325),hl		; setup abort handler
4944+  5C22 2A 49 F3    	ld	hl,(YF349)
4945+  5C25 22 4A FC    	ld	(HIMEM),hl
4946+  5C28 3A 45 F3    	ld	a,(YF345)
4947+  5C2B 4F          	ld	c,a
4948+  5C2C 06 00       	ld	b,0			; number of FCBs
4949+  5C2E 11 25 00    	ld	de,37
4950+  5C31 CD 16 49    	call	A4916			; * 37
4951+  5C34 CD B8 5E    	call	A5EB8			; allocate memory (adjust HIMEM, halt when error)
4952+  5C37 22 53 F3    	ld	(YF353),hl
4953+  5C3A 01 19 00    	ld	bc,25			; size of the BLOAD/BSAVE code
4954+  5C3D CD B8 5E    	call	A5EB8			; allocate memory (adjust HIMEM, halt when error)
4955+  5C40 22 78 F3    	ld	(XF377+1),hl		; setup BLOAD jumpentry
4956+  5C43 EB          	ex	de,hl
4957+  5C44 21 ED 62    	ld	hl,T62ED
4958+  5C47 ED B0       	ldir				; copy bsave/bload patch code
4959+  5C49 21 F5 FF    	ld	hl,0FFF5H
4960+  5C4C 19          	add	hl,de
4961+  5C4D 22 7B F3    	ld	(XF37A+1),hl		; setup BSAVE jumpentry
4962+  5C50 3A 48 F3    	ld	a,(YF348)
4963+  5C53 11 F9 FF    	ld	de,0FFF9H
4964+  5C56 19          	add	hl,de
4965+  5C57 77          	ld	(hl),a
4966+  5C58 11 0E 00    	ld	de,0000EH
4967+  5C5B 19          	add	hl,de
4968+  5C5C 77          	ld	(hl),a
4969+  5C5D CD 5F 5F    	call	A5F5F			; setup i/o channels
4970+  5C60             					; disable XFER..
4971+  5C60 3E C9       A5C60:	ld	a,0C9H
4972+  5C62 32 68 F3    A5C62:	ld	(XF368+0),a
4973+  5C65 32 6B F3    	ld	(XF36B+0),a
4974+  5C68 32 6E F3    	ld	(XFER+0),a
4975+  5C6B C9          	ret
4976+  5C6C             
4977+  5C6C A7 40       T5C6C:	defw	A40A7			; restart basic
4978+  5C6E             
4979+  5C6E             ;	Subroutine	initialize hooks
4980+  5C6E             ;	Inputs		________________________
4981+  5C6E             ;	Outputs		________________________
4982+  5C6E             
4983+  5C6E 21 E8 62    A5C6E:	ld	hl,T62E8
4984+  5C71 11 BC FE    	ld	de,H.POSD
4985+  5C74 01 05 00    	ld	bc,5
4986+  5C77 ED B0       	ldir
4987+  5C79 21 96 5C    	ld	hl,T5C96
4988+  5C7C 5E          A5C7C:	ld	e,(hl)
4989+  5C7D 23          	inc	hl
4990+  5C7E 56          	ld	d,(hl)
4991+  5C7F 23          	inc	hl
4992+  5C80 7B          	ld	a,e
4993+  5C81 B2          	or	d
4994+  5C82 C8          	ret	z
4995+  5C83 EB          	ex	de,hl
4996+  5C84 36 F7       	ld	(hl),0F7H
4997+  5C86 23          	inc	hl
4998+  5C87 3A 48 F3    	ld	a,(YF348)
4999+  5C8A 77          	ld	(hl),a
5000+  5C8B 23          	inc	hl
5001+  5C8C EB          	ex	de,hl
5002+  5C8D ED A0       	ldi
5003+  5C8F ED A0       	ldi
5004+  5C91 3E C9       	ld	a,0C9H
5005+  5C93 12          	ld	(de),a
5006+  5C94 18 E6       	jr	A5C7C
5007+  5C96             
5008+  5C96 EF FD 96 6B T5C96:	defw	H.DSKO,A6B96
5009+  5C9A 17 FE 75 6B 	defw	H.DSKI,A6B75
5010+  5C9E F9 FD 20 6F 	defw	H.NAME,A6F20
5011+  5CA2 FE FD 00 6F 	defw	H.KILL,A6F00
5012+  5CA6 08 FE 7B 70 	defw	H.COPY,A707B
5013+  5CAA 12 FE 61 70 	defw	H.DSKF,A7061
5014+  5CAE 21 FE D7 6C 	defw	H.LSET,A6CD7
5015+  5CB2 26 FE D6 6C 	defw	H.RSET,A6CD6
5016+  5CB6 2B FE 49 6C 	defw	H.FIEL,A6C49
5017+  5CBA 30 FE AF 6D 	defw	H.MKI,A6DAF
5018+  5CBE 35 FE B2 6D 	defw	H.MKS,A6DB2
5019+  5CC2 3A FE B5 6D 	defw	H.MKD,A6DB5
5020+  5CC6 3F FE D7 6D 	defw	H.CVI,A6DD7
5021+  5CCA 44 FE DA 6D 	defw	H.CVS,A6DDA
5022+  5CCE 49 FE DD 6D 	defw	H.CVD,A6DDD
5023+  5CD2 4E FE A4 66 	defw	H.GETP,A66A4
5024+  5CD6 58 FE B3 66 	defw	H.NOFO,A66B3
5025+  5CDA 5D FE FC 66 	defw	H.NULO,A66FC
5026+  5CDE 62 FE D0 68 	defw	H.NTFL,A68D0
5027+  5CE2 71 FE 0E 69 	defw	H.BINS,A690E
5028+  5CE6 76 FE 39 69 	defw	H.BINL,A6939
5029+  5CEA 7B FE 88 6E 	defw	H.FILE,A6E88
5030+  5CEE 80 FE DA 6B 	defw	H.DGET,A6BDA
5031+  5CF2 85 FE 8E 68 	defw	H.FILO,A688E
5032+  5CF6 8A FE 19 68 	defw	H.INDS,A6819
5033+  5CFA 99 FE 0D 70 	defw	H.LOC,A700D
5034+  5CFE 9E FE 09 70 	defw	H.LOF,A7009
5035+  5D02 A3 FE 70 6E 	defw	H.EOF,A6E70
5036+  5D06 AD FE 75 68 	defw	H.BAKU,A6875
5037+  5D0A B2 FE 23 73 	defw	H.PARD,A7323
5038+  5D0E B7 FE 7C 73 	defw	H.NODE,A737C
5039+  5D12 FD FE D3 71 	defw	H.ERRP,A71D3
5040+  5D16 A7 FF 55 60 	defw	H.PHYD,A6055
5041+  5D1A AC FF B0 60 	defw	H.FORM,A60B0
5042+  5D1E 31 F3 D3 56 	defw	XF331,A56D3
5043+  5D22 00 00       	defw	0
5044+  5D24             
5045+  5D24             T5D24:	defb	1,048H,"-",1,041H,"-",1,047H,"):",0
5045+  5D24 01482D01412D0147293A00
5046+  5D2F             T5D2F:	defb	"M-D-Y):",0
5046+  5D2F 4D2D442D59293A00
5047+  5D37             T5D37:	defb	"D-M-Y):",0
5047+  5D37 442D4D2D59293A00
5048+  5D3F             
5049+  5D3F             ;	Subroutine	Ask for systemdate
5050+  5D3F             ;	Inputs		________________________
5051+  5D3F             ;	Outputs		________________________
5052+  5D3F             
5053+  5D3F ED 73 C0 F5 A5D3F:	ld	(BUF+98),sp
5054+  5D43 3E 14       	ld	a,20
5055+  5D45 32 C2 F5    	ld	(BUF+100),a		; size of lineinput buffer
5056+  5D48 CD 86 5F    A5D48:	call	A5F86
5057+  5D4B             	defb	13,10,"Enter date (",0
5057+  5D4B 0D0A456E7465722064617465202800
5058+  5D5A 00          	nop
5059+  5D5B 00          	nop
5060+  5D5C 00          	nop
5061+  5D5D 00          	nop				; room for expansion ??
5062+  5D5E 00          	nop				; extra 5 bytes
5063+  5D5F 3A 0E F3    	ld	a,(YF30E)
5064+  5D62 FE 01       	cp	1
5065+  5D64 21 24 5D    	ld	hl,T5D24
5066+  5D67 38 08       	jr	c,A5D71			; japanese Y-M-D
5067+  5D69 21 2F 5D    	ld	hl,T5D2F
5068+  5D6C 28 03       	jr	z,A5D71			; european D-M-Y
5069+  5D6E 21 37 5D    	ld	hl,T5D37		; american M-D-Y
5070+  5D71 CD 8C 5F    A5D71:	call	A5F8C			; print string
5071+  5D74 21 4B 5E    	ld	hl,T5E4B
5072+  5D77 22 25 F3    	ld	(YF325),hl		; setup abort handler
5073+  5D7A 11 C2 F5    	ld	de,BUF+100
5074+  5D7D CD E0 50    	call	A50E0			; BDOS 0A (buffered console input)
5075+  5D80 21 C4 F5    	ld	hl,BUF+100+2
5076+  5D83 7E          	ld	a,(hl)
5077+  5D84 FE 0D       	cp	00DH
5078+  5D86 C8          	ret	z			; empty input, do not set date, quit
5079+  5D87 3A 0E F3    	ld	a,(YF30E)
5080+  5D8A A7          	and	a
5081+  5D8B 20 12       	jr	nz,A5D9F		; no japanese
5082+  5D8D CD 0D 5E    	call	A5E0D			; get date year
5083+  5D90 CD E9 5D    	call	A5DE9			; check for seperator and get date number (month)
5084+  5D93 51          	ld	d,c
5085+  5D94 7E          	ld	a,(hl)
5086+  5D95 23          	inc	hl
5087+  5D96 B8          	cp	b			; check if same seperator as the first one
5088+  5D97 20 32       	jr	nz,A5DCB		; nope, error
5089+  5D99 CD F8 5D    	call	A5DF8			; get date number (day)
5090+  5D9C 59          	ld	e,c
5091+  5D9D 18 1A       	jr	A5DB9
5092+  5D9F             
5093+  5D9F CD F8 5D    A5D9F:	call	A5DF8			; get date number (day european, month american)
5094+  5DA2 51          	ld	d,c
5095+  5DA3 CD E9 5D    	call	A5DE9			; check for seperator and get date number (month european, day american)
5096+  5DA6 59          	ld	e,c
5097+  5DA7 7E          	ld	a,(hl)
5098+  5DA8 23          	inc	hl
5099+  5DA9 B8          	cp	b			; check if same seperator as the first one
5100+  5DAA 20 05       	jr	nz,A5DB1		; nope, error
5101+  5DAC CD 0D 5E    	call	A5E0D			; get date year
5102+  5DAF 18 08       	jr	A5DB9
5103+  5DB1             
5104+  5DB1 D5          A5DB1:	push	de
5105+  5DB2 CD 3C 55    	call	A553C			; get date
5106+  5DB5 E5          	push	hl
5107+  5DB6 DD E1       	pop	ix
5108+  5DB8 D1          A5DB8:	pop	de
5109+  5DB9 3A 0E F3    A5DB9:	ld	a,(YF30E)
5110+  5DBC FE 02       	cp	002H
5111+  5DBE 38 03       	jr	c,A5DC3			; european or japanese, month already in register D
5112+  5DC0 7B          	ld	a,e
5113+  5DC1 5A          	ld	e,d
5114+  5DC2 57          	ld	d,a			; month in register D, day in register E
5115+  5DC3 DD E5       A5DC3:	push	ix
5116+  5DC5 E1          	pop	hl
5117+  5DC6 CD 52 55    	call	A5552			; set date
5118+  5DC9 B7          	or	a
5119+  5DCA C8          	ret	z			; no error, quit
5120+  5DCB ED 7B C0 F5 A5DCB:	ld	sp,(BUF+98)
5121+  5DCF CD 86 5F    	call	A5F86
5122+  5DD2             	defb	13,10,"Invalid date",0
5122+  5DD2 0D0A496E76616C6964206461746500
5123+  5DE1 00          	nop
5124+  5DE2 00          	nop
5125+  5DE3 00          	nop
5126+  5DE4 00          	nop				; room for expansion ??
5127+  5DE5 00          	nop				; extra 5 bytes
5128+  5DE6 C3 48 5D    	jp	A5D48			; try again
5129+  5DE9             
5130+  5DE9 7E          A5DE9:	ld	a,(hl)
5131+  5DEA 23          	inc	hl
5132+  5DEB 47          	ld	b,a
5133+  5DEC FE 2F       	cp	"/"
5134+  5DEE 28 08       	jr	z,A5DF8
5135+  5DF0 FE 2E       	cp	"."
5136+  5DF2 28 04       	jr	z,A5DF8
5137+  5DF4 FE 2D       	cp	"-"
5138+  5DF6 20 D3       	jr	nz,A5DCB
5139+  5DF8             
5140+  5DF8 CD 41 5E    A5DF8:	call	A5E41			; is digit ?
5141+  5DFB 38 CE       	jr	c,A5DCB			; nope, error
5142+  5DFD 4F          	ld	c,a			; save digit
5143+  5DFE CD 41 5E    	call	A5E41			; is digit ?
5144+  5E01 D8          	ret	c			; nope, quit
5145+  5E02 F5          	push	af
5146+  5E03 79          	ld	a,c
5147+  5E04 87          	add	a,a
5148+  5E05 87          	add	a,a
5149+  5E06 81          	add	a,c
5150+  5E07 87          	add	a,a
5151+  5E08 4F          	ld	c,a			; first digit *10
5152+  5E09 F1          	pop	af
5153+  5E0A 81          	add	a,c
5154+  5E0B 4F          	ld	c,a			; + second digit
5155+  5E0C C9          	ret
5156+  5E0D             
5157+  5E0D CD F8 5D    A5E0D:	call	A5DF8			; get date number
5158+  5E10 41          	ld	b,c
5159+  5E11 CD 41 5E    	call	A5E41			; is digit (is year more as 2 digit number) ?
5160+  5E14 38 16       	jr	c,A5E2C			; nope, make it a 4 digit number
5161+  5E16 2B          	dec	hl
5162+  5E17 CD F8 5D    	call	A5DF8			; get date number
5163+  5E1A E5          	push	hl
5164+  5E1B C5          	push	bc
5165+  5E1C 48          	ld	c,b
5166+  5E1D 06 00       	ld	b,000H
5167+  5E1F D5          	push	de
5168+  5E20 11 64 00    	ld	de,100
5169+  5E23 CD 16 49    	call	A4916			; * 100
5170+  5E26 D1          	pop	de
5171+  5E27 E1          	pop	hl
5172+  5E28 26 00       	ld	h,000H
5173+  5E2A 18 0F       	jr	A5E3B
5174+  5E2C             
5175+  5E2C E5          A5E2C:	push	hl
5176+  5E2D 48          	ld	c,b
5177+  5E2E 06 00       	ld	b,0
5178+  5E30 21 6C 07    	ld	hl,1900
5179+  5E33 79          	ld	a,c
5180+  5E34 FE 50       	cp	80
5181+  5E36 30 03       	jr	nc,A5E3B		; >= 80 means 19xx
5182+  5E38 21 D0 07    	ld	hl,2000			; >80 means 20xx
5183+  5E3B 09          A5E3B:	add	hl,bc
5184+  5E3C E5          	push	hl
5185+  5E3D DD E1       	pop	ix
5186+  5E3F E1          	pop	hl
5187+  5E40 C9          	ret
5188+  5E41             
5189+  5E41 7E          A5E41:	ld	a,(hl)
5190+  5E42 D6 30       	sub	030H
5191+  5E44 D8          	ret	c
5192+  5E45 FE 0A       	cp	00AH
5193+  5E47 3F          	ccf
5194+  5E48 D8          	ret	c
5195+  5E49 23          	inc	hl
5196+  5E4A C9          	ret
5197+  5E4B             
5198+  5E4B 4D 5E       T5E4B:	defw	A5E4D
5199+  5E4D             
5200+  5E4D ED 7B C0 F5 A5E4D:	ld	sp,(BUF+98)
5201+  5E51 C9          	ret
5202+  5E52             
5203+  5E52 21 C1 FC    A5E52:	LD	HL,EXPTBL
5204+  5E55 06 04       	LD	B,4
5205+  5E57 AF          	XOR	A
5206+  5E58 E6 03       J5E58:	AND	03H
5207+  5E5A B6          	OR	(HL)
5208+  5E5B C5          J5E5B:	PUSH	BC
5209+  5E5C E5          	PUSH	HL
5210+  5E5D 61          	LD	H,C
5211+  5E5E 2E 10       J5E5E:	LD	L,10H
5212+  5E60 F5          J5E60:	PUSH	AF
5213+  5E61 CD 0C 00    	CALL	RDSLT
5214+  5E64 2F          	CPL
5215+  5E65 5F          	LD	E,A
5216+  5E66 F1          	POP	AF
5217+  5E67 D5          	PUSH	DE
5218+  5E68 F5          	PUSH	AF
5219+  5E69 CD 14 00    	CALL	WRSLT
5220+  5E6C F1          	POP	AF
5221+  5E6D D1          	POP	DE
5222+  5E6E F5          	PUSH	AF
5223+  5E6F D5          	PUSH	DE
5224+  5E70 CD 0C 00    	CALL	RDSLT
5225+  5E73 C1          	POP	BC
5226+  5E74 47          	LD	B,A
5227+  5E75 79          	LD	A,C
5228+  5E76 2F          	CPL
5229+  5E77 5F          	LD	E,A
5230+  5E78 F1          	POP	AF
5231+  5E79 F5          	PUSH	AF
5232+  5E7A C5          	PUSH	BC
5233+  5E7B CD 14 00    	CALL	WRSLT
5234+  5E7E C1          	POP	BC
5235+  5E7F 79          	LD	A,C
5236+  5E80 B8          	CP	B
5237+  5E81 20 17       	JR	NZ,J5E9A
5238+  5E83 F1          	POP	AF
5239+  5E84 2D          	DEC	L
5240+  5E85 20 D9       	JR	NZ,J5E60
5241+  5E87 24          	INC	H
5242+  5E88 24          	INC	H
5243+  5E89 24          	INC	H
5244+  5E8A 24          	INC	H
5245+  5E8B 4F          	LD	C,A
5246+  5E8C 7C          	LD	A,H
5247+  5E8D FE 40       	CP	40H
5248+  5E8F 28 05       	JR	Z,J5E96
5249+  5E91 FE 80       	CP	80H
5250+  5E93 79          	LD	A,C
5251+  5E94 20 C8       	JR	NZ,J5E5E
5252+  5E96 79          J5E96:	LD	A,C
5253+  5E97 E1          	POP	HL
5254+  5E98 E1          	POP	HL
5255+  5E99 C9          	RET
5256+  5E9A             
5257+  5E9A F1          J5E9A:	POP	AF
5258+  5E9B E1          	POP	HL
5259+  5E9C C1          	POP	BC
5260+  5E9D A7          	AND	A
5261+  5E9E F2 A7 5E    	JP	P,J5EA7
5262+  5EA1 C6 04       	ADD	A,4
5263+  5EA3 FE 90       	CP	90H
5264+  5EA5 38 B4       	JR	C,J5E5B
5265+  5EA7 23          J5EA7:	INC	HL
5266+  5EA8 3C          	INC	A
5267+  5EA9 10 AD       	DJNZ	J5E58
5268+  5EAB 37          	SCF
5269+  5EAC C9          	RET
5270+  5EAD             
5271+  5EAD             ;	Subroutine	allocate MSXDOS memory (halt when error)
5272+  5EAD             ;	Inputs		HL = number of bytes to allocate
5273+  5EAD             ;	Outputs		
5274+  5EAD             
5275+  5EAD 2A 4B F3    A5EAD:	ld	hl,(YF34B)
5276+  5EB0 A7          	and	a
5277+  5EB1 ED 42       	sbc	hl,bc
5278+  5EB3 22 4B F3    	ld	(YF34B),hl		; new top of MSXDOS
5279+  5EB6 18 09       	jr	A5EC1
5280+  5EB8             
5281+  5EB8             ;	Subroutine	allocate memory (adjust HIMEM, halt when error)
5282+  5EB8             ;	Inputs		HL = number of bytes to allocate
5283+  5EB8             ;	Outputs		
5284+  5EB8             
5285+  5EB8 2A 4A FC    A5EB8:	ld	hl,(HIMEM)
5286+  5EBB A7          	and	a
5287+  5EBC ED 42       	sbc	hl,bc
5288+  5EBE 22 4A FC    	ld	(HIMEM),hl		; new top of system
5289+  5EC1 38 09       A5EC1:	jr	c,A5ECC			; new top below zero, halt with error
5290+  5EC3 7C          	ld	a,h
5291+  5EC4 FE C2       	cp	0C2H			; new top below 0C200H ?
5292+  5EC6 18 03       	jr	A5ECB
5293+  5EC8             
5294+  5EC8             ;	Subroutine	allocate memory (adjust BASIC areapointers, halt when error)
5295+  5EC8             ;	Inputs		HL = number of bytes to allocate
5296+  5EC8             ;	Outputs		
5297+  5EC8             
5298+  5EC8 CD E8 5E    A5EC8:	call	A5EE8			; allocate memory (adjust BASIC areapointers)
5299+  5ECB D0          A5ECB:	ret	nc
5300+  5ECC CD 86 5F    A5ECC:	call	A5F86
5301+  5ECF 0C          	defb	12
5302+  5ED0             T5ED0:	defb	"No enough memory",0
5302+  5ED0 4E6F20656E6F756768206D656D6F727900
5303+  5EE1 00          	nop
5304+  5EE2 00          	nop
5305+  5EE3 00          	nop
5306+  5EE4 00          	nop				; room for expansion ??
5307+  5EE5 00          	nop				; extra 5 bytes
5308+  5EE6 F3          	di
5309+  5EE7 76          	halt
5310+  5EE8             
5311+  5EE8             ;	Subroutine	allocate memory (adjust BASIC areapointers)
5312+  5EE8             ;	Inputs		HL = number of bytes to allocate
5313+  5EE8             ;	Outputs		Cx set if out of memory
5314+  5EE8             
5315+  5EE8 7D          A5EE8:	ld	a,l
5316+  5EE9 B4          	or	h			; size = 0 ?
5317+  5EEA C8          	ret	z			; yep, quit
5318+  5EEB AF          	xor	a
5319+  5EEC 95          	sub	l
5320+  5EED 6F          	ld	l,a
5321+  5EEE 3E 00       	ld	a,0
5322+  5EF0 9C          	sbc	a,h
5323+  5EF1 67          	ld	h,a
5324+  5EF2 4D          	ld	c,l
5325+  5EF3 44          	ld	b,h			; - size
5326+  5EF4 39          	add	hl,sp
5327+  5EF5 3F          	ccf
5328+  5EF6 D8          	ret	c			; stack would become below zero, quit
5329+  5EF7 ED 5B 48 FC 	ld	de,(BOTTOM)
5330+  5EFB ED 52       	sbc	hl,de
5331+  5EFD D8          	ret	c			; stack would become below BOTTOM, quit
5332+  5EFE 7C          	ld	a,h
5333+  5EFF FE 02       	cp	HIGH 512
5334+  5F01 D8          	ret	c			; less then 512 bytes for stack, quit
5335+  5F02 C5          	push	bc
5336+  5F03 21 00 00    	ld	hl,0
5337+  5F06 39          	add	hl,sp
5338+  5F07 5D          	ld	e,l
5339+  5F08 54          	ld	d,h			; top of stack
5340+  5F09 09          	add	hl,bc
5341+  5F0A E5          	push	hl			; new top of stack
5342+  5F0B 2A 74 F6    	ld	hl,(STKTOP)
5343+  5F0E A7          	and	a
5344+  5F0F ED 52       	sbc	hl,de
5345+  5F11 4D          	ld	c,l
5346+  5F12 44          	ld	b,h			; size of the stack
5347+  5F13 03          	inc	bc
5348+  5F14 E1          	pop	hl
5349+  5F15 F9          	ld	sp,hl			; new stack
5350+  5F16 EB          	ex	de,hl
5351+  5F17 ED B0       	ldir				; copy stack content to new location
5352+  5F19 C1          	pop	bc
5353+  5F1A 2A 4A FC    	ld	hl,(HIMEM)
5354+  5F1D 09          	add	hl,bc
5355+  5F1E 22 4A FC    	ld	(HIMEM),hl		; adjust HIMEM
5356+  5F21 11 EA FD    	ld	de,-(2*256+2*9+2*2)
5357+  5F24 19          	add	hl,de
5358+  5F25 22 60 F8    	ld	(FILTAB),hl		; 1 user i/o channel + 1 system i/o channel
5359+  5F28 EB          	ex	de,hl
5360+  5F29 2A 72 F6    	ld	hl,(MEMSIZ)
5361+  5F2C 09          	add	hl,bc
5362+  5F2D 22 72 F6    	ld	(MEMSIZ),hl		; adjust MEMSIZ
5363+  5F30 2A 62 F8    	ld	hl,(NULBUF)
5364+  5F33 09          	add	hl,bc
5365+  5F34 22 62 F8    	ld	(NULBUF),hl		; adjust NULBUF
5366+  5F37 2A 74 F6    	ld	hl,(STKTOP)
5367+  5F3A 09          	add	hl,bc			; adjust STKTOP
5368+  5F3B 22 74 F6    A5F3B:	ld	(STKTOP),hl
5369+  5F3E 2B          	dec	hl
5370+  5F3F 2B          	dec	hl
5371+  5F40 22 B1 F6    	ld	(SAVSTK),hl
5372+  5F43 6B          	ld	l,e
5373+  5F44 62          	ld	h,d
5374+  5F45 23          	inc	hl
5375+  5F46 23          	inc	hl
5376+  5F47 23          	inc	hl
5377+  5F48 23          	inc	hl
5378+  5F49 3E 02       	ld	a,2			; 2 i/o channels
5379+  5F4B EB          A5F4B:	ex	de,hl
5380+  5F4C 73          	ld	(hl),e
5381+  5F4D 23          	inc	hl
5382+  5F4E 72          	ld	(hl),d
5383+  5F4F 23          	inc	hl
5384+  5F50 EB          	ex	de,hl
5385+  5F51 01 07 00    	ld	bc,7
5386+  5F54 70          	ld	(hl),b			; i/o channel not open
5387+  5F55 09          	add	hl,bc
5388+  5F56 70          	ld	(hl),b			; clear i/o channel flags
5389+  5F57 01 02 01    	ld	bc,256+9-7
5390+  5F5A 09          	add	hl,bc
5391+  5F5B 3D          	dec	a
5392+  5F5C 20 ED       	jr	nz,A5F4B
5393+  5F5E C9          	ret
5394+  5F5F             
5395+  5F5F 3E 01       A5F5F:	ld	a,1
5396+  5F61 32 5F F8    	ld	(MAXFIL),a
5397+  5F64 2A 4A FC    	ld	hl,(HIMEM)
5398+  5F67 11 EA FD    	ld	de,-(2*256+2*9+2*2)
5399+  5F6A 19          	add	hl,de
5400+  5F6B 22 60 F8    	ld	(FILTAB),hl
5401+  5F6E 5D          	ld	e,l
5402+  5F6F 54          	ld	d,h
5403+  5F70 2B          	dec	hl
5404+  5F71 2B          	dec	hl
5405+  5F72 22 72 F6    	ld	(MEMSIZ),hl
5406+  5F75 01 C8 00    	ld	bc,200
5407+  5F78 A7          	and	a
5408+  5F79 ED 42       	sbc	hl,bc
5409+  5F7B E5          	push	hl
5410+  5F7C 21 0D 00    	ld	hl,2*2+9
5411+  5F7F 19          	add	hl,de
5412+  5F80 22 62 F8    	ld	(NULBUF),hl
5413+  5F83 E1          	pop	hl
5414+  5F84 18 B5       	jr	A5F3B
5415+  5F86             
5416+  5F86 E3          A5F86:	ex	(sp),hl
5417+  5F87 CD 8C 5F    	call	A5F8C			; print string
5418+  5F8A E3          	ex	(sp),hl
5419+  5F8B C9          	ret
5420+  5F8C             
5421+  5F8C 7E          A5F8C:	ld	a,(hl)
5422+  5F8D 23          	inc	hl
5423+  5F8E A7          	and	a
5424+  5F8F C8          	ret	z
5425+  5F90 CD 8F 40    	call	A408F			; output to screen
5426+  5F93 18 F7       	jr	A5F8C
5427+  5F95             
5428+  5F95             ;	Subroutine	get slotid of page 3
5429+  5F95             ;	Inputs		-
5430+  5F95             ;	Outputs		A = slotid
5431+  5F95             
5432+  5F95 06 06       A5F95:	ld	b,6
5433+  5F97 21          	defb	021H			; LD HL,xxxx (skips next instruction)
5434+  5F98             
5435+  5F98             ;	Subroutine	get slotid of page 2
5436+  5F98             ;	Inputs		-
5437+  5F98             ;	Outputs		A = slotid
5438+  5F98             
5439+  5F98 06 04       A5F98:	ld	b,4
5440+  5F9A CD 65 F3    	call	XF365
5441+  5F9D C5          	push	bc
5442+  5F9E 0F          A5F9E:	rrca
5443+  5F9F 10 FD       	djnz	A5F9E
5444+  5FA1 CD EC 5F    	call	A5FEC
5445+  5FA4 C1          	pop	bc
5446+  5FA5 B6          	or	(hl)
5447+  5FA6 4F          	ld	c,a
5448+  5FA7 23          	inc	hl
5449+  5FA8 23          	inc	hl
5450+  5FA9 23          	inc	hl
5451+  5FAA 23          	inc	hl
5452+  5FAB 7E          	ld	a,(hl)
5453+  5FAC 05          	dec	b
5454+  5FAD 05          	dec	b
5455+  5FAE 0F          A5FAE:	rrca
5456+  5FAF 10 FD       	djnz	A5FAE
5457+  5FB1 18 0B       	jr	A5FBE
5458+  5FB3             
5459+  5FB3             ;	Subroutine	get my slotid
5460+  5FB3             ;	Inputs		-
5461+  5FB3             ;	Outputs		A = slotid
5462+  5FB3             
5463+  5FB3 CD E7 5F    A5FB3:	call	A5FE7
5464+  5FB6 B6          	or	(hl)
5465+  5FB7 F0          	ret	p			; non expanded slot, quit
5466+  5FB8 4F          	ld	c,a
5467+  5FB9 23          	inc	hl
5468+  5FBA 23          	inc	hl
5469+  5FBB 23          	inc	hl
5470+  5FBC 23          	inc	hl
5471+  5FBD 7E          	ld	a,(hl)
5472+  5FBE E6 0C       A5FBE:	and	00CH
5473+  5FC0 B1          	or	c
5474+  5FC1 C9          	ret
5475+  5FC2             
5476+  5FC2             ;	Subroutine	get my diskdriver workarea
5477+  5FC2             ;	Inputs		-
5478+  5FC2             ;	Outputs		HL = IX = pointer to workarea
5479+  5FC2             ;	Remark		used by the diskdriver
5480+  5FC2             
5481+  5FC2             GETWRK:
5482+  5FC2 CD CD 5F    A5FC2:	call	A5FCD			; get my SLTWRK entry
5483+  5FC5 7E          	ld	a,(hl)
5484+  5FC6 23          	inc	hl
5485+  5FC7 66          	ld	h,(hl)
5486+  5FC8 6F          	ld	l,a			; pointer to workarea
5487+  5FC9 E5          	push	hl
5488+  5FCA DD E1       	pop	ix
5489+  5FCC C9          	ret
5490+  5FCD             
5491+  5FCD             ;	Subroutine	get my SLTWRK entry
5492+  5FCD             ;	Inputs		-
5493+  5FCD             ;	Outputs		HL = pointer to SLTWRK entry
5494+  5FCD             
5495+  5FCD CD E7 5F    A5FCD:	call	A5FE7			; get my primairy slot
5496+  5FD0 87          	add	a,a
5497+  5FD1 87          	add	a,a
5498+  5FD2 87          	add	a,a
5499+  5FD3 37          	scf
5500+  5FD4 8F          	adc	a,a			; primary slot*4 + 1
5501+  5FD5 4F          	ld	c,a
5502+  5FD6 7E          	ld	a,(hl)
5503+  5FD7 87          	add	a,a
5504+  5FD8 9F          	sbc	a,a
5505+  5FD9 E6 0C       	and	00CH			; 0 for non expanded, 0CH for expanded
5506+  5FDB 23          	inc	hl
5507+  5FDC 23          	inc	hl
5508+  5FDD 23          	inc	hl
5509+  5FDE 23          	inc	hl
5510+  5FDF A6          	and	(hl)
5511+  5FE0 B1          	or	c
5512+  5FE1 87          	add	a,a			; word entries
5513+  5FE2 21 09 FD    	ld	hl,SLTWRK
5514+  5FE5 18 0C       	jr	A5FF3
5515+  5FE7             
5516+  5FE7             ;	Subroutine	get my EXPTBL entry
5517+  5FE7             ;	Inputs		-
5518+  5FE7             ;	Outputs		HL = pointer to SLTWRK entry
5519+  5FE7             
5520+  5FE7 CD 65 F3    A5FE7:	call	XF365
5521+  5FEA 0F          	rrca
5522+  5FEB 0F          	rrca
5523+  5FEC E6 03       A5FEC:	and	003H
5524+  5FEE 21 C1 FC    	ld	hl,EXPTBL
5525+  5FF1 06 00       A5FF1:	ld	b,000H
5526+  5FF3 4F          A5FF3:	ld	c,a
5527+  5FF4 09          	add	hl,bc
5528+  5FF5 C9          	ret
5529+  5FF6             
5530+  5FF6             ;	Subroutine	install my diskdriver interrupt handler
5531+  5FF6             ;	Inputs		HL = pointer to interrupt handler
5532+  5FF6             ;	Outputs		-
5533+  5FF6             ;	Remark		used by the diskdriver
5534+  5FF6             
5535+  5FF6             SETINT:
5536+  5FF6 3A 9F FD    A5FF6:	ld	a,(H.TIMI+0)
5537+  5FF9 FE C9       	cp	0C9H
5538+  5FFB 28 15       	jr	z,A6012			; H.TIMI not hooked, skip saving H.TIMI
5539+  5FFD E5          	push	hl
5540+  5FFE CD 5E 74    	call    GET_DEVICE_FOR_INT  ;ld	a,(DEVICE)		; this diskdriver number
5541+  6001 21 29 FB    	ld	hl,YFB29
5542+  6004 CD F1 5F    	call	A5FF1
5543+  6007 09          	add	hl,bc
5544+  6008 09          	add	hl,bc			; get DRVINT pointer
5545+  6009 EB          	ex	de,hl
5546+  600A 21 A0 FD    	ld	hl,H.TIMI+1
5547+  600D 0E 03       	ld	c,003H
5548+  600F ED B0       	ldir				; save slotid and address (assumes that is hooked by a CALLF!)
5549+  6011 E1          	pop	hl
5550+  6012 F3          A6012:	di
5551+  6013 3E F7       	ld	a,0F7H
5552+  6015 32 9F FD    	ld	(H.TIMI+0),a
5553+  6018 22 A1 FD    	ld	(H.TIMI+2),hl		; diskdriver interrupt handler
5554+  601B 3E C9       	ld	a,0C9H
5555+  601D 32 A3 FD    	ld	(H.TIMI+4),a
5556+  6020 CD 2D 40    	call	A402D
5557+  6023 32 A0 FD    	ld	(H.TIMI+1),a		; slotid of this diskdriver
5558+  6026 C9          	ret
5559+  6027             
5560+  6027             ;	Subroutine	call orginal interrupt handler
5561+  6027             ;	Inputs		-
5562+  6027             ;	Outputs		-
5563+  6027             ;	Remark		used by the diskdriver
5564+  6027             
5565+  6027             PRVINT:
5566+  6027 F5          A6027:	push	af
5567+  6028 CD 2D 40    	call	A402D			; slotid of this diskdriver
5568+  602B 06 04       	ld	b,4
5569+  602D 11 29 FB    	ld	de,YFB29
5570+  6030 21 22 FB    	ld	hl,YFB21+1
5571+  6033 BE          A6033:	cp	(hl)			; is this my DRVTBL entry ?
5572+  6034 28 09       	jr	z,A603F			; yep, get the saved interrupt handler and jump to it
5573+  6036 13          	inc	de
5574+  6037 13          	inc	de
5575+  6038 13          	inc	de
5576+  6039 23          	inc	hl
5577+  603A 23          	inc	hl
5578+  603B 10 F6       	djnz	A6033			; next DRVTBL and DRVINT entry
5579+  603D F1          A603D:	pop	af
5580+  603E C9          	ret				; quit
5581+  603F             
5582+  603F EB          A603F:	ex	de,hl
5583+  6040 7E          	ld	a,(hl)
5584+  6041 A7          	and	a
5585+  6042 28 F9       	jr	z,A603D			; DRVINT entry not used, quit
5586+  6044 F5          	push	af
5587+  6045 FD E1       	pop	iy			; slotid
5588+  6047 23          	inc	hl
5589+  6048 4E          	ld	c,(hl)
5590+  6049 23          	inc	hl
5591+  604A 46          	ld	b,(hl)
5592+  604B C5          	push	bc
5593+  604C DD E1       	pop	ix			; address
5594+  604E F1          	pop	af
5595+  604F C3 1C 00    	jp	CALSLT
5596+  6052             
5597+  6052             ;	Subroutine	read disksector
5598+  6052             ;	Inputs		A = driveid, B = number of sectors, C = mediadescriptor, DE = start sector, HL = transferaddress
5599+  6052             ;	Outputs		-
5600+  6052             
5601+  6052 A7          A6052:	and	a
5602+  6053 38          	defb	038H			; JR C,xx (skips next instruction)
5603+  6054             
5604+  6054             ;	Subroutine	write disksector
5605+  6054             ;	Inputs		A = driveid, B = number of sectors, C = mediadescriptor, DE = start sector, HL = transferaddress
5606+  6054             ;	Outputs		-
5607+  6054             
5608+  6054 37          A6054:	scf
5609+  6055             
5610+  6055             ;	Subroutine	PHYDIO BIOS call (H.PHYD)
5611+  6055             ;	Inputs		A = driveid, B = number of sectors, C = mediadescriptor, DE = start sector, HL = transferaddress
5612+  6055             ;	Outputs		-
5613+  6055             
5614+  6055 DD E5       A6055:	push	ix
5615+  6057 FD E5       	push	iy
5616+  6059 E5          	push	hl
5617+  605A F5          	push	af
5618+  605B CD 86 60    	call	A6086			; get diskdriverparameters
5619+  605E 6F          	ld	l,a
5620+  605F F1          	pop	af			; restore flags (Cx)
5621+  6060 7D          	ld	a,l
5622+  6061 DD 21 10 40 	ld	ix,T4010
5623+  6065 18 14       	jr	A607B
5624+  6067             
5625+  6067 DD E5       A6067:	push	ix
5626+  6069 DD 21 13 40 	ld	ix,T4013
5627+  606D 18 06       	jr	A6075
5628+  606F             
5629+  606F DD E5       A606F:	push	ix
5630+  6071 DD 21 16 40 	ld	ix,T4016
5631+  6075 FD E5       A6075:	push	iy
5632+  6077 E5          	push	hl
5633+  6078 CD 86 60    	call	A6086			; get diskdriverparameters
5634+  607B E1          A607B:	pop	hl
5635+  607C E5          	push	hl
5636+  607D CD 1C 00    	call	CALSLT
5637+  6080 C3 6E 63    	jp	A636E
5638+  6083             
5639+  6083             ; Unused code
5640+  6083             ; looks like the previous jump is a patch, may be the 'ei' instruction at the end of the patch was forgotten ??
5641+  6083             ; patch code does not fit here, 1 byte too less
5642+  6083             
5643+  6083 00          	nop
5644+  6084 00          	nop
5645+  6085 00          	nop
5646+  6086             
5647+  6086             ;	Subroutine	get diskdriverparameters
5648+  6086             ;	Inputs		A=driveid
5649+  6086             ;	Outputs		IYH=slotid diskdriver, H=slotid diskdriver, A=local driveid diskdriver
5650+  6086             
5651+  6086 32 3F F3    A6086:	ld	(YF33F),a		; save driveid (for PROMPT)
5652+  6089 21 21 FB    	ld	hl,YFB21		; diskdriver table
5653+  608C 96          A608C:	sub	(hl)
5654+  608D 38 04       	jr	c,A6093
5655+  608F 23          	inc	hl
5656+  6090 23          	inc	hl
5657+  6091 18 F9       	jr	A608C
5658+  6093             
5659+  6093 86          A6093:	add	a,(hl)			; driveid driver
5660+  6094 23          	inc	hl
5661+  6095 66          	ld	h,(hl)			; slotid driver
5662+  6096 E5          	push	hl
5663+  6097 FD E1       	pop	iy
5664+  6099 C9          	ret
5665+  609A             
5666+  609A             ;	Subroutine	mark FAT buffer as invalid
5667+  609A             ;	Inputs		A=driveid
5668+  609A             ;	Outputs		________________________
5669+  609A             
5670+  609A 21 55 F3    A609A:	ld	hl,YF355
5671+  609D CD F1 5F    	call	A5FF1
5672+  60A0 09          	add	hl,bc
5673+  60A1 5E          	ld	e,(hl)
5674+  60A2 23          	inc	hl
5675+  60A3 56          	ld	d,(hl)			; pointer to DPB
5676+  60A4 21 13 00    	ld	hl,00013H
5677+  60A7 19          	add	hl,de
5678+  60A8 5E          	ld	e,(hl)
5679+  60A9 23          	inc	hl
5680+  60AA 56          	ld	d,(hl)
5681+  60AB 1B          	dec	de
5682+  60AC EB          	ex	de,hl
5683+  60AD 36 FF       	ld	(hl),0FFH
5684+  60AF C9          	ret
5685+  60B0             
5686+  60B0             ;	Subroutine	FORMAT BIOS call (H.FORM)
5687+  60B0             ;	Inputs		
5688+  60B0             ;	Outputs		________________________
5689+  60B0             
5690+  60B0 A7          A60B0:	and	a			; use free BASIC memory as formatbuffer
5691+  60B1             
5692+  60B1             ;	Subroutine	format disk
5693+  60B1             ;	Inputs		Cx reset = use free BASIC memory as formatbuffer, Cx set = use specified buffer, HL = start of buffer, BC = size of buffer
5694+  60B1             ;	Outputs		________________________
5695+  60B1             
5696+  60B1 ED 73 39 F3 A60B1:	ld	(YF339),sp		; save stackpointer for abort
5697+  60B5 D4 D6 62    	call	nc,A62D6		; get formatbuffer in free BASIC memory
5698+  60B8 E5          	push	hl
5699+  60B9 C5          	push	bc
5700+  60BA 3A 47 F3    	ld	a,(YF347)
5701+  60BD 3D          	dec	a			; only 1 diskdrive ?
5702+  60BE 28 41       	jr	z,A6101			; yep, skip drivename input and use driveid 0
5703+  60C0 CD 86 5F    A60C0:	call	A5F86
5704+  60C3             	defb	"Drive name? (",0
5704+  60C3 4472697665206E616D653F202800
5705+  60D1 00          	nop
5706+  60D2 00          	nop
5707+  60D3 00          	nop
5708+  60D4 00          	nop				; room for expansion ??
5709+  60D5 00          	nop				; extra 5 bytes
5710+  60D6 3A 47 F3    	ld	a,(YF347)
5711+  60D9 47          	ld	b,a			; number of diskdrives
5712+  60DA 3E 41       	ld	a,"A"			; starts with "A" drive
5713+  60DC 18 07       	jr	A60E5
5714+  60DE             
5715+  60DE F5          A60DE:	push	af
5716+  60DF 3E 2C       	ld	a,","
5717+  60E1 CD 8F 40    	call	A408F			; output to screen
5718+  60E4 F1          	pop	af
5719+  60E5 CD 8F 40    A60E5:	call	A408F			; output to screen
5720+  60E8 3C          	inc	a
5721+  60E9 10 F3       	djnz	A60DE			; next drive
5722+  60EB CD 86 5F    	call	A5F86
5723+  60EE 29 20 00    	defb	") ",0
5724+  60F1 CD 95 61    	call	A6195			; get fresh consoleinput (CTRL-C aborts)
5725+  60F4 CD C6 62    	call	A62C6			; print input and CR/LF
5726+  60F7 E6 DF       	and	0DFH			; upcase
5727+  60F9 D6 41       	sub	"A"
5728+  60FB 21 47 F3    	ld	hl,YF347
5729+  60FE BE          	cp	(hl)			; driveletter valid ?
5730+  60FF 30 BF       	jr	nc,A60C0		; nope, ask again
5731+  6101 CD 9A 60    A6101:	call	A609A			; mark FAT buffer as invalid
5732+  6104 CD 86 60    	call	A6086			; get diskdriverparameters
5733+  6107 FD E5       	push	iy
5734+  6109 F5          	push	af
5735+  610A FD E5       	push	iy
5736+  610C DD 21 19 40 	ld	ix,T4019
5737+  6110 CD 1C 00    	call	CALSLT			; call CHOICE diskdriver
5738+  6113 7D          	ld	a,l
5739+  6114 B4          	or	h			; choice string ?
5740+  6115 28 27       	jr	z,A613E			; nope, skip choice input and use choice 0 (default format)
5741+  6117 F1          	pop	af
5742+  6118 F5          A6118:	push	af
5743+  6119 CD 0C 00    	call	RDSLT
5744+  611C A7          	and	a
5745+  611D 28 07       	jr	z,A6126
5746+  611F CD 8F 40    	call	A408F			; output to screen
5747+  6122 23          	inc	hl
5748+  6123 F1          	pop	af
5749+  6124 18 F2       	jr	A6118			; print choice string
5750+  6126             
5751+  6126 F1          A6126:	pop	af
5752+  6127 CD 86 5F    	call	A5F86
5753+  612A 3F 20 00    	defb	"? ",0
5754+  612D CD 95 61    A612D:	call	A6195			; get fresh consoleinput (CTRL-C aborts)
5755+  6130 D6 31       	sub	"1"
5756+  6132 FE 09       	cp	009H			; input "1"-"9" ?
5757+  6134 30 F7       	jr	nc,A612D		; nope, ask again
5758+  6136 C6 31       	add	a,"1"
5759+  6138 CD C6 62    A6138:	call	A62C6			; print input and CR/LF
5760+  613B D6 30       	sub	"0"			; choice 1-9
5761+  613D F5          	push	af
5762+  613E CD 74 61    A613E:	call	A6174			; prompt and get fresh consoleinput (CTRL-C aborts)
5763+  6141 F1          	pop	af
5764+  6142 D1          	pop	de
5765+  6143 FD E1       	pop	iy
5766+  6145 C1          	pop	bc
5767+  6146 E1          	pop	hl
5768+  6147 DD 21 1C 40 	ld	ix,T401C
5769+  614B CD 1C 00    	call	CALSLT			; call DSKFMT diskdriver
5770+  614E 21 E0 61    	ld	hl,T61E0
5771+  6151 30 0A       	jr	nc,A615D		; no error, print "format complete" and quit
5772+  6153 21 48 62    	ld	hl,T6248
5773+  6156 CD F1 5F    	call	A5FF1			; get errorstring entry
5774+  6159 7E          	ld	a,(hl)
5775+  615A 23          	inc	hl
5776+  615B 66          	ld	h,(hl)
5777+  615C 6F          	ld	l,a			; pointer to errorstring
5778+  615D CD C9 62    A615D:	call	A62C9			; print CR/LF
5779+  6160 CD 8C 5F    	call	A5F8C			; print string
5780+  6163 C3 C9 62    	jp	A62C9			; print CR/LF
5781+  6166             
5782+  6166             ;	Subroutine	get fresh keyboardinput
5783+  6166             ;	Inputs		
5784+  6166             ;	Outputs		________________________
5785+  6166             
5786+  6166 AF          A6166:	xor	a
5787+  6167 32 36 F3    	ld	(YF336),a		; no saved input
5788+  616A DD 21 56 01 	ld	ix,KILBUF
5789+  616E CD AB 40    	call	A40AB			; KILBUF BIOS call
5790+  6171 C3 78 40    	jp	A4078			; get keyboardinput
5791+  6174             
5792+  6174 CD 86 5F    A6174:	call	A5F86
5793+  6177             	defb	"Strike a key when ready ",0
5793+  6177 537472696B652061206B6579207768656E2072656164792000
5794+  6190 00          	nop
5795+  6191 00          	nop
5796+  6192 00          	nop
5797+  6193 00          	nop				; room for expansion ??
5798+  6194 00          	nop				; extra 5 bytes
5799+  6195 CD 66 61    A6195:	call	A6166			; get fresh keyboardinput
5800+  6198 FE 03       	cp	003H
5801+  619A C0          	ret	nz
5802+  619B ED 7B 39 F3 	ld	sp,(YF339)
5803+  619F CD 86 5F    	call	A5F86
5804+  61A2             	defb	13,10,"Aborted",0
5804+  61A2 0D0A41626F7274656400
5805+  61AC C9          	ret
5806+  61AD             
5807+  61AD             T61AD:	defb	"Write protected",0
5807+  61AD 57726974652070726F74656374656400
5808+  61BD             T61BD:	defb	"Not ready",0
5808+  61BD 4E6F7420726561647900
5809+  61C7             T61C7:	defb	"Disk error",0
5809+  61C7 4469736B206572726F7200
5810+  61D2             T61D2:	defb	"Bad parameter",0
5810+  61D2 42616420706172616D6574657200
5811+  61E0             T61E0:	defb	"Format complete",0
5811+  61E0 466F726D617420636F6D706C65746500
5812+  61F0             
5813+  61F0             ; unused code ??
5814+  61F0             
5815+  61F0 00          	nop
5816+  61F1             
5817+  61F1 11 98 F6    A61F1:	ld	de,TEMPST+30
5818+  61F4 2A 78 F6    	ld	hl,(TEMPPT)
5819+  61F7 22 F8 F7    	ld	(DAC+2),hl
5820+  61FA 3E 03       	ld	a,3
5821+  61FC 32 63 F6    A61FC:	ld	(VALTYP),a
5822+  61FF CD F3 2E    	call	M2EF3			; copy stringdescriptor
5823+  6202 11 9B F6    	ld	de,TEMPST+30+3
5824+  6205 E7          	rst	020H
5825+  6206 22 78 F6    	ld	(TEMPPT),hl
5826+  6209 C0          	ret	nz
5827+  620A C3 F7 72    	jp	A72F7
5828+  620D             
5829+  620D 21 21 FB    A620D:	ld	hl,YFB21
5830+  6210 06 04       	ld	b,004H
5831+  6212 23          A6212:	inc	hl
5832+  6213 7E          	ld	a,(hl)
5833+  6214 F5          	push	af
5834+  6215 FD E1       	pop	iy
5835+  6217 23          	inc	hl
5836+  6218 E5          	push	hl
5837+  6219 C5          	push	bc
5838+  621A 21 1F 40    	ld	hl,T401F
5839+  621D E5          	push	hl
5840+  621E DD E1       	pop	ix
5841+  6220 A7          	and	a
5842+  6221 C4 0C 00    	call	nz,RDSLT
5843+  6224 A7          A6224:	and	a
5844+  6225 C4 1C 00    	call	nz,CALSLT
5845+  6228 C1          	pop	bc
5846+  6229 E1          	pop	hl
5847+  622A 10 E6       	djnz	A6212
5848+  622C C9          	ret
5849+  622D             
5850+  622D 3A D0 FE    A622D:	ld	a,(H.CLEA+0)
5851+  6230 FE C9       	cp	0C9H
5852+  6232 28 11       A6232:	jr	z,A6245
5853+  6234 21 F2 72    A6234:	ld	hl,T72F2
5854+  6237 11 D5 FE    	ld	de,H.LOPD
5855+  623A 01 05 00    	ld	bc,00005H
5856+  623D ED B0       	ldir
5857+  623F CD 2D 40    	call	A402D
5858+  6242 32 D6 FE    	ld	(H.LOPD+1),a
5859+  6245 C3 2D 40    A6245:	jp	A402D
5860+  6248             
5861+  6248 AD 61       T6248:	defw	T61AD		; dskfmt error 0
5862+  624A BD 61       	defw	T61BD		; dskfmt error 2
5863+  624C C7 61       	defw	T61C7		; dskfmt error 4
5864+  624E C7 61       	defw	T61C7		; dskfmt error 6
5865+  6250 C7 61       	defw	T61C7		; dskfmt error 8
5866+  6252 C7 61       	defw	T61C7		; dskfmt error 10
5867+  6254 D2 61       	defw	T61D2		; dskfmt error 12
5868+  6256 D0 5E       	defw	T5ED0		; dskfmt error 14
5869+  6258 C7 61       	defw	T61C7		; dskfmt error 16
5870+  625A             
5871+  625A             PROMPT:
5872+  625A 3A 3F F3    L625A:	ld	a,(YF33F)		; driveid
5873+  625D C6 41       	add	a,"A"
5874+  625F CD 4F F2    	call	XF24F			; PROMPT hook
5875+  6262 F5          	push	af
5876+  6263 CD 86 5F    	call	A5F86
5877+  6266             	defb	13,10,"Insert diskette for drive ",0
5877+  6266 0D0A496E73657274206469736B6574746520666F722064726976652000
5878+  6283 00          	nop
5879+  6284 00          	nop
5880+  6285 00          	nop
5881+  6286 00          	nop
5882+  6287 00          	nop
5883+  6288 00          	nop
5884+  6289 00          	nop
5885+  628A 00          	nop
5886+  628B 00          	nop				; room for expansion
5887+  628C 00          	nop				; extra 10 bytes
5888+  628D F1          	pop	af
5889+  628E CD 8F 40    	call	A408F			; output to screen
5890+  6291 CD 86 5F    	call	A5F86
5891+  6294             	defb	":",13,10,"and strike a key when ready",0
5891+  6294 3A0D0A616E6420737472696B652061206B6579207768656E20726561647900
5892+  62B3 00          	nop
5893+  62B4 00          	nop
5894+  62B5 00          	nop
5895+  62B6 00          	nop
5896+  62B7 00          	nop
5897+  62B8 00          	nop
5898+  62B9 00          	nop
5899+  62BA 00          	nop
5900+  62BB 00          	nop				; room for expansion
5901+  62BC 00          	nop				; extra 10 bytes
5902+  62BD CD 66 61    A62BD:	call	A6166			; get fresh keyboardinput
5903+  62C0 FE 03       	cp	003H
5904+  62C2 28 F9       	jr	z,A62BD
5905+  62C4 18 03       	jr	A62C9			; print CR/LF
5906+  62C6             
5907+  62C6 CD 8F 40    A62C6:	call	A408F			; output to screen
5908+  62C9 F5          A62C9:	push	af
5909+  62CA 3E 0D       	ld	a,00DH
5910+  62CC CD 8F 40    	call	A408F			; output to screen
5911+  62CF 3E 0A       	ld	a,00AH
5912+  62D1 CD 8F 40    	call	A408F			; output to screen
5913+  62D4 F1          A62D4:	pop	af
5914+  62D5 C9          	ret
5915+  62D6             
5916+  62D6 21 00 FF    A62D6:	ld	hl,0FF00H
5917+  62D9 39          	add	hl,sp			; leave room for the stack
5918+  62DA ED 5B C6 F6 	ld	de,(STREND)		; end of used BASIC memory
5919+  62DE AF          	xor	a
5920+  62DF ED 52       	sbc	hl,de
5921+  62E1 4D          	ld	c,l
5922+  62E2 44          	ld	b,h			; size of buffer
5923+  62E3 EB          	ex	de,hl			; start of buffer
5924+  62E4 D0          	ret	nc
5925+  62E5 4F          	ld	c,a
5926+  62E6 47          	ld	b,a			; not enough room, size=0
5927+  62E7 C9          	ret
5928+  62E8             
5929+  62E8             ;	Subroutine	first character filespecifier is 000H-039H (H.POSD)
5930+  62E8             ;	Inputs		
5931+  62E8             ;	Outputs		________________________
5932+  62E8             
5933+  62E8 33          T62E8:	inc	sp
5934+  62E9 33          	inc	sp
5935+  62EA C3 1D 6F    	jp	M6F1D			; skip strong cassette devicecheck
5936+  62ED             
5937+  62ED 7A          T62ED:	ld	a,d
5938+  62EE FE 09       	cp	9			; diskdevice ?
5939+  62F0 D2 C9 6E    	jp	nc,M6EC6+3		; nope, resume BLOAD
5940+  62F3 F7          	rst	030H
5941+  62F4 00          	defb	000H
5942+  62F5 A7 6A       	defw	A6AA7			; call BLOAD for diskdevice
5943+  62F7 E5          	push	hl
5944+  62F8 C3 F4 6E    	jp	M6EF4			; finish BLOAD
5945+  62FB             
5946+  62FB 7A          	ld	a,d
5947+  62FC FE 09       	cp	9			; diskdevice ?
5948+  62FE D2 95 6E    	jp	nc,M6E92+3		; nope, resume BSAVE
5949+  6301 F7          	rst	030H
5950+  6302 00          	defb	000H
5951+  6303 E7 69       	defw	A69E7
5952+  6305 C9          	ret
5953+  6306             
5954+  6306 D5          A6306:	PUSH	DE
5955+  6307 EB          	EX	DE,HL
5956+  6308 A7          	AND	A
5957+  6309 ED 42       	SBC	HL,BC
5958+  630B E5          	PUSH	HL
5959+  630C DD E1       	POP	IX
5960+  630E EB          	EX	DE,HL
5961+  630F D1          	POP	DE
5962+  6310 4E          J6310:	LD	C,(HL)
5963+  6311 23          	INC	HL
5964+  6312 46          	LD	B,(HL)
5965+  6313 23          	INC	HL
5966+  6314 79          	LD	A,C
5967+  6315 A0          	AND	B
5968+  6316 3C          	INC	A
5969+  6317 C8          	RET	Z
5970+  6318 D5          	PUSH	DE
5971+  6319 EB          	EX	DE,HL
5972+  631A 09          	ADD	HL,BC
5973+  631B 23          	INC	HL
5974+  631C 4E          	LD	C,(HL)
5975+  631D 23          	INC	HL
5976+  631E 46          	LD	B,(HL)
5977+  631F E5          	PUSH	HL
5978+  6320 DD E5       	PUSH	IX
5979+  6322 E1          	POP	HL
5980+  6323 09          	ADD	HL,BC
5981+  6324 4D          	LD	C,L
5982+  6325 44          	LD	B,H
5983+  6326 E1          	POP	HL
5984+  6327 70          	LD	(HL),B
5985+  6328 2B          	DEC	HL
5986+  6329 71          	LD	(HL),C
5987+  632A EB          	EX	DE,HL
5988+  632B D1          	POP	DE
5989+  632C 18 E2       	JR	J6310
5990+  632E             
5991+  632E 0C 00       T632E:	DEFW	R000C-I6336
5992+  6330 1E 00       	DEFW	R001E+1-I6336
5993+  6332 2F 00       	DEFW	R002F-I6336
5994+  6334 FF FF       	DEFW	0FFFFH
5995+  6336             
5996+  6336 DD E5       I6336:	PUSH	IX
5997+  6338 FD E5       	PUSH	IY
5998+  633A E5          	PUSH	HL
5999+  633B D5          	PUSH	DE
6000+  633C C5          	PUSH	BC
6001+  633D F5          	PUSH	AF
6002+  633E D9          	EXX
6003+  633F 08          	EX	AF,AF'
6004+  6340 F5          	PUSH	AF
6005+  6341 E5          	PUSH	HL
6006+  6342 2A 5F 63    R000C:	LD	HL,(D635E+1)
6007+  6345 7D          	LD	A,L
6008+  6346 B4          	OR	H
6009+  6347 E1          	POP	HL
6010+  6348 DD 21 38 00 	LD	IX,KEYINT
6011+  634C FD 2A C0 FC 	LD	IY,(EXPTBL+0-1)
6012+  6350 20 23       	JR	NZ,J6375
6013+  6352 F1          	POP	AF
6014+  6353 ED 73 5F 63 R001E:	LD	(D635E+1),SP
6015+  6357 31 00 00    	LD	SP,0
6016+  635A CD 1C 00    	CALL	CALSLT
6017+  635D F3          	DI
6018+  635E 31 00 00    D635E:	LD	SP,0
6019+  6361 E5          	PUSH	HL
6020+  6362 21 00 00    	LD	HL,0
6021+  6365 22 5F 63    R002F:	LD	(D635E+1),HL
6022+  6368 E1          	POP	HL
6023+  6369 08          J6369:	EX	AF,AF'
6024+  636A D9          	EXX
6025+  636B F1          	POP	AF
6026+  636C C1          	POP	BC
6027+  636D D1          	POP	DE
6028+  636E E1          A636E:	POP	HL
6029+  636F FD E1       	POP	IY
6030+  6371 DD E1       	POP	IX
6031+  6373 FB          	EI
6032+  6374 C9          	RET
6033+  6375             
6034+  6375 F1          J6375:	POP	AF
6035+  6376 CD 1C 00    	CALL	CALSLT
6036+  6379 18 EE       	JR	J6369
6037+  637B             
6038+  637B F5          I637B:	PUSH	AF
6039+  637C E5          	PUSH	HL
6040+  637D D5          	PUSH	DE
6041+  637E C5          	PUSH	BC
6042+  637F CD 2D 40    	CALL	A402D
6043+  6382 F5          	PUSH	AF
6044+  6383 26 40       	LD	H,40H
6045+  6385 3A 42 F3    	LD	A,(RAMAD1)
6046+  6388 CD 24 00    	CALL	ENASLT
6047+  638B F1          	POP	AF
6048+  638C C1          	POP	BC
6049+  638D D1          	POP	DE
6050+  638E E1          	POP	HL
6051+  638F ED B0       	LDIR
6052+  6391 E5          	PUSH	HL
6053+  6392 D5          	PUSH	DE
6054+  6393 C5          	PUSH	BC
6055+  6394 CD 68 F3    	CALL	XF368
6056+  6397 26 40       	LD	H,40H
6057+  6399 CD 24 00    	CALL	ENASLT
6058+  639C C1          	POP	BC
6059+  639D D1          	POP	DE
6060+  639E E1          	POP	HL
6061+  639F F1          	POP	AF
6062+  63A0 C9          	RET
6063+  63A1             
6064+  63A1 18 06       I63A1:	JR	J63A9
6065+  63A3             
6066+  63A3 F5          U63A3:	PUSH	AF
6067+  63A4 3A 42 F3    	LD	A,(RAMAD1)
6068+  63A7 18 04       	JR	J63AD
6069+  63A9             
6070+  63A9 F5          J63A9:	PUSH	AF
6071+  63AA 3A 48 F3    	LD	A,(YF348)
6072+  63AD E5          J63AD:	PUSH	HL
6073+  63AE D5          	PUSH	DE
6074+  63AF C5          	PUSH	BC
6075+  63B0 26 40       	LD	H,40H
6076+  63B2 CD 24 00    	CALL	ENASLT
6077+  63B5 C1          	POP	BC
6078+  63B6 D1          	POP	DE
6079+  63B7 E1          	POP	HL
6080+  63B8 F1          	POP	AF
6081+  63B9 C9          	RET
6082+  63BA             
6083+  63BA 00 00       T63BA:	DEFW	C63F4-C63F4
6084+  63BC 03 00       	DEFW	R0003-C63F4
6085+  63BE 17 00       	DEFW	R0017-C63F4
6086+  63C0 1C 00       	DEFW	R001C-C63F4
6087+  63C2 22 00       	DEFW	R0022-C63F4
6088+  63C4 25 00       	DEFW	R0025-C63F4
6089+  63C6 39 00       	DEFW	R0039-C63F4
6090+  63C8 3F 00       	DEFW	R003F-C63F4
6091+  63CA 69 00       	DEFW	R0069-C63F4
6092+  63CC 6C 00       	DEFW	R006C-C63F4
6093+  63CE 7E 00       	DEFW	R007E-C63F4
6094+  63D0 94 00       	DEFW	R0094-C63F4
6095+  63D2 A8 00       	DEFW	J649C-C63F4
6096+  63D4 AB 00       	DEFW	R00AB-C63F4
6097+  63D6 BC 00       	DEFW	R00BC-C63F4
6098+  63D8 10 00       	DEFW	J6404-C63F4
6099+  63DA 13 00       	DEFW	R0013-C63F4
6100+  63DC 31 00       	DEFW	J6425-C63F4
6101+  63DE 34 00       	DEFW	R0034-C63F4
6102+  63E0 78 00       	DEFW	J646C-C63F4
6103+  63E2 7B 00       	DEFW	R007B-C63F4
6104+  63E4 B5 00       	DEFW	J64A9-C63F4
6105+  63E6 B8 00       	DEFW	R00B8-C63F4
6106+  63E8 2A 01       	DEFW	J651E-C63F4
6107+  63EA 31 01       	DEFW	R0131-C63F4
6108+  63EC 38 01       	DEFW	J652C-C63F4
6109+  63EE 45 01       	DEFW	R0145-C63F4
6110+  63F0 4D 01       	DEFW	C6541-C63F4
6111+  63F2 FF FF       	DEFW	0FFFFH
6112+  63F4             
6113+  63F4             
6114+  63F4             ;	Subroutine	__________________________
6115+  63F4             ;	Inputs		________________________
6116+  63F4             ;	Outputs		________________________
6117+  63F4             
6118+  63F4 CD C2 64    C63F4:	CALL	C64C2
6119+  63F7 FA 04 64    R0003:	JP	M,J6404
6120+  63FA DB A8       	IN	A,(0A8H)
6121+  63FC 57          	LD	D,A
6122+  63FD A1          	AND	C
6123+  63FE B0          	OR	B
6124+  63FF CD 80 F3    	CALL	RDPRIM
6125+  6402 7B          	LD	A,E
6126+  6403 C9          	RET
6127+  6404             
6128+  6404 CD 11 65    J6404:	CALL	C6511
6129+  6407 CA 1E 65    R0013:	JP	Z,J651E
6130+  640A E5          	PUSH	HL
6131+  640B CD E7 64    R0017:	CALL	C64E7
6132+  640E E3          	EX	(SP),HL
6133+  640F C5          	PUSH	BC
6134+  6410 CD F4 63    R001C:	CALL	C63F4
6135+  6413 18 21       	JR	J6436
6136+  6415             
6137+  6415             ;	Subroutine	__________________________
6138+  6415             ;	Inputs		________________________
6139+  6415             ;	Outputs		________________________
6140+  6415             
6141+  6415 D5          C6415:	PUSH	DE
6142+  6416 CD C2 64    R0022:	CALL	C64C2
6143+  6419 FA 25 64    R0025:	JP	M,J6425
6144+  641C D1          	POP	DE
6145+  641D DB A8       	IN	A,(0A8H)
6146+  641F 57          	LD	D,A
6147+  6420 A1          	AND	C
6148+  6421 B0          	OR	B
6149+  6422 C3 85 F3    	JP	WRPRIM
6150+  6425             
6151+  6425 CD 11 65    J6425:	CALL	C6511
6152+  6428 CA 24 65    R0034:	JP	Z,J6524
6153+  642B E3          	EX	(SP),HL
6154+  642C E5          	PUSH	HL
6155+  642D CD E7 64    R0039:	CALL	C64E7
6156+  6430 D1          	POP	DE
6157+  6431 E3          	EX	(SP),HL
6158+  6432 C5          	PUSH	BC
6159+  6433 CD 15 64    R003F:	CALL	C6415
6160+  6436 C1          J6436:	POP	BC
6161+  6437 E3          	EX	(SP),HL
6162+  6438 F5          	PUSH	AF
6163+  6439 78          	LD	A,B
6164+  643A E6 3F       	AND	3FH
6165+  643C B1          	OR	C
6166+  643D CD 46 00    	CALL	X0046
6167+  6440 F1          	POP	AF
6168+  6441 E1          	POP	HL
6169+  6442 C9          	RET
6170+  6443             
6171+  6443 E3          C6443:	EX	(SP),HL
6172+  6444 F5          	PUSH	AF
6173+  6445 D5          	PUSH	DE
6174+  6446 7E          	LD	A,(HL)
6175+  6447 F5          	PUSH	AF
6176+  6448 FD E1       	POP	IY
6177+  644A 23          	INC	HL
6178+  644B 5E          	LD	E,(HL)
6179+  644C 23          	INC	HL
6180+  644D 56          	LD	D,(HL)
6181+  644E 23          	INC	HL
6182+  644F D5          	PUSH	DE
6183+  6450 DD E1       	POP	IX
6184+  6452 D1          	POP	DE
6185+  6453 F1          	POP	AF
6186+  6454 E3          	EX	(SP),HL
6187+  6455             
6188+  6455             ;	Subroutine	__________________________
6189+  6455             ;	Inputs		________________________
6190+  6455             ;	Outputs		________________________
6191+  6455             
6192+  6455 D9          C6455:	EXX
6193+  6456 08          	EX	AF,AF'
6194+  6457 FD E5       	PUSH	IY
6195+  6459 F1          	POP	AF
6196+  645A DD E5       	PUSH	IX
6197+  645C E1          	POP	HL
6198+  645D CD C2 64    R0069:	CALL	C64C2
6199+  6460 FA 6C 64    R006C:	JP	M,J646C
6200+  6463 DB A8       	IN	A,(0A8H)
6201+  6465 F5          	PUSH	AF
6202+  6466 A1          	AND	C
6203+  6467 B0          	OR	B
6204+  6468 D9          	EXX
6205+  6469 C3 8C F3    	JP	CLPRIM
6206+  646C             
6207+  646C CD 11 65    J646C:	CALL	C6511
6208+  646F CA 2C 65    R007B:	JP	Z,J652C
6209+  6472 CD E7 64    R007E:	CALL	C64E7
6210+  6475 F5          	PUSH	AF
6211+  6476 FD E1       	POP	IY
6212+  6478 E5          	PUSH	HL
6213+  6479 C5          	PUSH	BC
6214+  647A 4F          	LD	C,A
6215+  647B 06 00       	LD	B,00H
6216+  647D 7D          	LD	A,L
6217+  647E A4          	AND	H
6218+  647F B2          	OR	D
6219+  6480 21 C5 FC    	LD	HL,SLTTBL
6220+  6483 09          	ADD	HL,BC
6221+  6484 77          	LD	(HL),A
6222+  6485 E5          	PUSH	HL
6223+  6486 08          	EX	AF,AF'
6224+  6487 D9          	EXX
6225+  6488 CD 55 64    R0094:	CALL	C6455
6226+  648B D9          	EXX
6227+  648C 08          	EX	AF,AF'
6228+  648D E1          	POP	HL
6229+  648E C1          	POP	BC
6230+  648F D1          	POP	DE
6231+  6490 78          	LD	A,B
6232+  6491 E6 3F       	AND	3FH
6233+  6493 B1          	OR	C
6234+  6494 F3          	DI
6235+  6495 CD 4B 00    	CALL	X004B
6236+  6498 73          	LD	(HL),E
6237+  6499 08          	EX	AF,AF'
6238+  649A D9          	EXX
6239+  649B C9          	RET
6240+  649C             
6241+  649C CD C2 64    J649C:	CALL	C64C2
6242+  649F FA A9 64    R00AB:	JP	M,J64A9
6243+  64A2 DB A8       C64A2:	IN	A,(0A8H)
6244+  64A4 A1          	AND	C
6245+  64A5 B0          	OR	B
6246+  64A6 D3 A8       	OUT	(0A8H),A
6247+  64A8 C9          	RET
6248+  64A9             
6249+  64A9 CD 11 65    J64A9:	CALL	C6511
6250+  64AC CA 41 65    R00B8:	JP	Z,C6541
6251+  64AF E5          C64AF:	PUSH	HL
6252+  64B0 CD E7 64    R00BC:	CALL	C64E7
6253+  64B3 4F          	LD	C,A
6254+  64B4 06 00       	LD	B,00H
6255+  64B6 7D          	LD	A,L
6256+  64B7 A4          	AND	H
6257+  64B8 B2          	OR	D
6258+  64B9 21 C5 FC    	LD	HL,SLTTBL
6259+  64BC 09          	ADD	HL,BC
6260+  64BD 77          	LD	(HL),A
6261+  64BE E1          	POP	HL
6262+  64BF 79          	LD	A,C
6263+  64C0 18 DA       	JR	J649C
6264+  64C2             
6265+  64C2             ;	Subroutine	__________________________
6266+  64C2             ;	Inputs		________________________
6267+  64C2             ;	Outputs		________________________
6268+  64C2             
6269+  64C2 F3          C64C2:	DI
6270+  64C3 F5          	PUSH	AF
6271+  64C4 7C          	LD	A,H
6272+  64C5 07          	RLCA
6273+  64C6 07          	RLCA
6274+  64C7 E6 03       	AND	03H
6275+  64C9 5F          	LD	E,A
6276+  64CA 1C          	INC	E
6277+  64CB 3E C0       	LD	A,0C0H
6278+  64CD 07          J64CD:	RLCA
6279+  64CE 07          	RLCA
6280+  64CF 1D          	DEC	E
6281+  64D0 20 FB       	JR	NZ,J64CD
6282+  64D2 5F          	LD	E,A
6283+  64D3 2F          	CPL
6284+  64D4 4F          	LD	C,A
6285+  64D5 F1          	POP	AF
6286+  64D6 F5          	PUSH	AF
6287+  64D7 E6 03       	AND	03H
6288+  64D9 47          	LD	B,A
6289+  64DA 04          	INC	B
6290+  64DB 3E AB       	LD	A,0ABH
6291+  64DD C6 55       J64DD:	ADD	A,55H
6292+  64DF 10 FC       	DJNZ	J64DD
6293+  64E1 57          	LD	D,A
6294+  64E2 A3          	AND	E
6295+  64E3 47          	LD	B,A
6296+  64E4 F1          	POP	AF
6297+  64E5 A7          	AND	A
6298+  64E6 C9          	RET
6299+  64E7             
6300+  64E7             ;	Subroutine	__________________________
6301+  64E7             ;	Inputs		________________________
6302+  64E7             ;	Outputs		________________________
6303+  64E7             
6304+  64E7 F5          C64E7:	PUSH	AF
6305+  64E8 7A          	LD	A,D
6306+  64E9 E6 C0       	AND	0C0H
6307+  64EB 4F          	LD	C,A
6308+  64EC F1          	POP	AF
6309+  64ED F5          	PUSH	AF
6310+  64EE 57          	LD	D,A
6311+  64EF DB A8       	IN	A,(0A8H)
6312+  64F1 47          	LD	B,A
6313+  64F2 E6 3F       	AND	3FH
6314+  64F4 B1          	OR	C
6315+  64F5 F5          	PUSH	AF
6316+  64F6 7A          	LD	A,D
6317+  64F7 0F          	RRCA
6318+  64F8 0F          	RRCA
6319+  64F9 E6 03       	AND	03H
6320+  64FB 57          	LD	D,A
6321+  64FC 14          	INC	D
6322+  64FD 3E AB       	LD	A,0ABH
6323+  64FF C6 55       J64FF:	ADD	A,55H
6324+  6501 15          	DEC	D
6325+  6502 20 FB       	JR	NZ,J64FF
6326+  6504 A3          	AND	E
6327+  6505 57          	LD	D,A
6328+  6506 7B          	LD	A,E
6329+  6507 2F          	CPL
6330+  6508 67          	LD	H,A
6331+  6509 F1          	POP	AF
6332+  650A CD 5C 65    R0116:	CALL	C655C		; save and change secundair slotregister
6333+  650D F1          	POP	AF
6334+  650E E6 03       	AND	03H
6335+  6510 C9          	RET
6336+  6511             
6337+  6511             ;	Subroutine	__________________________
6338+  6511             ;	Inputs		________________________
6339+  6511             ;	Outputs		________________________
6340+  6511             
6341+  6511 4F          C6511:	LD	C,A
6342+  6512 7B          	LD	A,E
6343+  6513 FE 03       	CP	03H
6344+  6515 79          	LD	A,C
6345+  6516 C0          	RET	NZ		; not page 0, quit
6346+  6517 3A 41 F3    	LD	A,(RAMAD0)
6347+  651A A3          	AND	E		; primary slot of the helper routines
6348+  651B B8          	CP	B		; same as requested ?
6349+  651C 79          	LD	A,C
6350+  651D C9          	RET
6351+  651E             
6352+  651E CD 49 65    J651E:	CALL	C6549
6353+  6521 5E          	LD	E,(HL)
6354+  6522 18 05       	JR	C6529
6355+  6524             
6356+  6524 D1          J6524:	POP	DE
6357+  6525 CD 49 65    R0131:	CALL	C6549
6358+  6528 73          	LD	(HL),E
6359+  6529             
6360+  6529             ;	Subroutine	__________________________
6361+  6529             ;	Inputs		________________________
6362+  6529             ;	Outputs		________________________
6363+  6529             
6364+  6529 78          C6529:	LD	A,B
6365+  652A 18 2B       	JR	J6557
6366+  652C             
6367+  652C CD 41 65    J652C:	CALL	C6541
6368+  652F E5          	PUSH	HL
6369+  6530 C5          	PUSH	BC
6370+  6531 08          	EX	AF,AF'
6371+  6532 D9          	EXX
6372+  6533 CD 98 F3    	CALL	CLPRM1
6373+  6536 D9          	EXX
6374+  6537 08          	EX	AF,AF'
6375+  6538 C1          	POP	BC
6376+  6539 CD 29 65    R0145:	CALL	C6529
6377+  653C E1          	POP	HL
6378+  653D 70          	LD	(HL),B
6379+  653E 08          	EX	AF,AF'
6380+  653F D9          	EXX
6381+  6540 C9          	RET
6382+  6541             
6383+  6541             ;	Subroutine	__________________________
6384+  6541             ;	Inputs		________________________
6385+  6541             ;	Outputs		________________________
6386+  6541             
6387+  6541 CD 49 65    C6541:	CALL	C6549
6388+  6544 21 C5 FC    	LD	HL,SLTTBL
6389+  6547 72          	LD	(HL),D
6390+  6548 C9          	RET
6391+  6549             
6392+  6549             ;	Subroutine	__________________________
6393+  6549             ;	Inputs		________________________
6394+  6549             ;	Outputs		________________________
6395+  6549             
6396+  6549 0F          C6549:	RRCA
6397+  654A 0F          	RRCA
6398+  654B E6 03       	AND	03H
6399+  654D 57          	LD	D,A
6400+  654E 3A FF FF    	LD	A,(YFFFF)
6401+  6551 2F          	CPL
6402+  6552 47          	LD	B,A
6403+  6553 E6 FC       	AND	0FCH
6404+  6555 B2          	OR	D
6405+  6556 57          	LD	D,A
6406+  6557 32 FF FF    J6557:	LD	(YFFFF),A
6407+  655A 7B          	LD	A,E
6408+  655B C9          	RET
6409+  655C             
6410+  655C             ;	Subroutine	__________________________
6411+  655C             ;	Inputs		________________________
6412+  655C             ;	Outputs		________________________
6413+  655C             
6414+  655C D3 A8       C655C:	OUT	(0A8H),A
6415+  655E 3A FF FF    	LD	A,(YFFFF)
6416+  6561 2F          	CPL
6417+  6562 6F          	LD	L,A
6418+  6563 A4          	AND	H
6419+  6564 B2          	OR	D
6420+  6565 18 08       	JR	J656F
6421+  6567             
6422+  6567 D3 A8       U6567:	OUT	(0A8H),A
6423+  6569 7D          	LD	A,L
6424+  656A 18 03       	JR	J656F
6425+  656C             
6426+  656C D3 A8       U656C:	OUT	(0A8H),A
6427+  656E 7B          	LD	A,E
6428+  656F 32 FF FF    J656F:	LD	(YFFFF),A
6429+  6572 78          	LD	A,B
6430+  6573 D3 A8       	OUT	(0A8H),A
6431+  6575 C9          	RET
6432+  6576             
6433+  6576 3A 4E FE    A6576: ld	a,(H.GETP+0)
6434+  6579 FE C9       	cp	0C9H
6435+  657B 37          	scf
6436+  657C C8          	ret	z
6437+  657D E5          	push	hl
6438+  657E CD 2D 40    	call	A402D
6439+  6581 21 48 F3    	ld	hl,YF348
6440+  6584 BE          	cp	(hl)
6441+  6585 20 26       	jr	nz,A65AD
6442+  6587 21 B1 65    	ld	hl,T65B1
6443+  658A 11 89 FD    A658A:	ld	de,PROCNM
6444+  658D 1A          A658D:	ld	a,(de)
6445+  658E BE          	cp	(hl)
6446+  658F 13          	inc	de
6447+  6590 23          	inc	hl
6448+  6591 20 10       	jr	nz,A65A3
6449+  6593 A7          	and	a
6450+  6594 20 F7       	jr	nz,A658D
6451+  6596 7E          	ld	a,(hl)
6452+  6597 23          	inc	hl
6453+  6598 66          	ld	h,(hl)
6454+  6599 6F          	ld	l,a
6455+  659A E3          	ex	(sp),hl
6456+  659B CD DA 72    	call	A72DA			;
6457+  659E 37          	scf
6458+  659F 3F          	ccf
6459+  65A0 C9          	ret
6460+  65A1             
6461+  65A1 23          A65A1:	inc	hl
6462+  65A2 7E          	ld	a,(hl)
6463+  65A3 A7          A65A3:	and	a
6464+  65A4 20 FB       	jr	nz,A65A1
6465+  65A6 23          	inc	hl
6466+  65A7 23          	inc	hl
6467+  65A8 23          	inc	hl
6468+  65A9 7E          	ld	a,(hl)
6469+  65AA A7          	and	a
6470+  65AB 20 DD       	jr	nz,A658A
6471+  65AD E1          A65AD:	pop	hl
6472+  65AE C3 3A 75    	jp	OEMSTA
6473+  65B1             
6474+  65B1             T65B1:	defb	"SYSTEM",0
6474+  65B1 53595354454D00
6475+  65B8 C4 65       	defw	A65C4
6476+  65BA             	defb	"FORMAT",0
6476+  65BA 464F524D415400
6477+  65C1 DC 65       	defw	A65DC
6478+  65C3 00          	defb	0
6479+  65C4             
6480+  65C4 C0          A65C4:	ret	nz
6481+  65C5 3A 46 F3    	ld	a,(YF346)
6482+  65C8 A7          	and	a
6483+  65C9 CA 15 73    	jp	z,A7315
6484+  65CC DD 21 1C 6C 	ld	ix,M6C1C
6485+  65D0 CD 1E 73    	call	A731E			; close all i/o channels
6486+  65D3 CD D2 00    	call	TOTEXT
6487+  65D6 CD CC 00    	call	ERAFNK
6488+  65D9 C3 11 5A    	jp	A5A11			; start MSXDOS
6489+  65DC             
6490+  65DC E5          A65DC:	push	hl
6491+  65DD CC B1 60    	call	z,A60B1
6492+  65E0 E1          	pop	hl
6493+  65E1 A7          	and	a
6494+  65E2 C9          	ret
6495+  65E3             
6496+  65E3 7A          A65E3:	ld	a,d
6497+  65E4 3D          A65E4:	dec	a
6498+  65E5 F0          	ret	p
6499+  65E6 3A 47 F2    	ld	a,(YF247)
6500+  65E9 C9          	ret
6501+  65EA             
6502+  65EA E5          A65EA:	push	hl
6503+  65EB D5          	push	de
6504+  65EC C5          	push	bc
6505+  65ED CD E3 65    	call	A65E3			; convert to driveid
6506+  65F0 4F          	ld	c,a
6507+  65F1 2A 60 F8    	ld	hl,(FILTAB)		; I/O channel pointer table
6508+  65F4 3A 5F F8    	ld	a,(MAXFIL)		; number of I/O channels
6509+  65F7 F5          A65F7:	push	af
6510+  65F8 5E          	ld	e,(hl)
6511+  65F9 23          	inc	hl
6512+  65FA 56          	ld	d,(hl)
6513+  65FB 23          	inc	hl
6514+  65FC E5          	push	hl
6515+  65FD EB          	ex	de,hl			; pointer to I/O channel
6516+  65FE 7E          	ld	a,(hl)
6517+  65FF A7          	and	a			; channel in use ?
6518+  6600 28 2C       	jr	z,A662E			; nope, check next
6519+  6602 23          	inc	hl
6520+  6603 23          	inc	hl
6521+  6604 23          	inc	hl
6522+  6605 23          	inc	hl
6523+  6606 7E          	ld	a,(hl)
6524+  6607 FE 09       	cp	9			; channel in use by a disk device ?
6525+  6609 30 23       	jr	nc,A662E		; nope, check next
6526+  660B 2B          	dec	hl
6527+  660C 2B          	dec	hl
6528+  660D 56          	ld	d,(hl)
6529+  660E 2B          	dec	hl
6530+  660F 5E          	ld	e,(hl)			; pointer to FCB
6531+  6610 1A          	ld	a,(de)			; DR byte of FCB
6532+  6611 CD E4 65    	call	A65E4			; convert to driveid
6533+  6614 B9          	cp	c			; same as the requested one ?
6534+  6615 20 17       	jr	nz,A662E		; nope, check next
6535+  6617 13          	inc	de
6536+  6618 EB          	ex	de,hl
6537+  6619 11 66 F8    	ld	de,FILNAM
6538+  661C 06 0B       	ld	b,11
6539+  661E 1A          A661E:	ld	a,(de)
6540+  661F FE 3F       	cp	"?"
6541+  6621 28 03       	jr	z,A6626			; wildcard, treat as equal
6542+  6623 BE          	cp	(hl)
6543+  6624 20 08       	jr	nz,A662E		; filename not equal, check next
6544+  6626 13          A6626:	inc	de
6545+  6627 23          	inc	hl
6546+  6628 10 F4       	djnz	A661E			; next char
6547+  662A E1          	pop	hl
6548+  662B E1          	pop	hl
6549+  662C 18 72       	jr	A66A0			; quit with Zx set (file open)
6550+  662E             
6551+  662E E1          A662E:	pop	hl
6552+  662F F1          	pop	af
6553+  6630 3D          	dec	a
6554+  6631 F2 F7 65    	jp	p,A65F7			; next channel
6555+  6634 18 6A       	jr	A66A0			; quit with Zx reset (file not open)
6556+  6636             
6557+  6636 E5          A6636:	push	hl
6558+  6637 D5          	push	de
6559+  6638 C5          	push	bc
6560+  6639 7A          	ld	a,d
6561+  663A 32 68 F5    	ld	(BUF+10),a
6562+  663D CD 57 66    	call	A6657			; copy FILNAM to FCB
6563+  6640 CD 45 66    	call	A6645			; search file
6564+  6643 18 5B       	jr	A66A0
6565+  6645             
6566+  6645 21 B2 F5    A6645:	ld	hl,BUF+84
6567+  6648 22 3D F2    	ld	(YF23D),hl		; transferaddress in BUF
6568+  664B 11 68 F5    	ld	de,BUF+10
6569+  664E AF          	xor	a
6570+  664F 32 74 F5    	ld	(BUF+10+12),a		; clear EX byte of FCB
6571+  6652 CD B8 4F    D6652:	call	A4FB8			; search for first
6572+  6655 3C          	inc	a
6573+  6656 C9          	ret
6574+  6657             
6575+  6657 11 69 F5    A6657:	ld	de,BUF+10+1
6576+  665A 21 66 F8    A665A:	ld	hl,FILNAM
6577+  665D 01 0B 00    	ld	bc,11
6578+  6660 ED B0       	ldir
6579+  6662 C9          	ret
6580+  6663             
6581+  6663             ;	Subroutine	take control from caller (move parameters on stack)
6582+  6663             ;	Inputs		IX = returnaddress replacement, IYH = number of bytes to move
6583+  6663             ;	Outputs		________________________
6584+  6663             
6585+  6663             ;	This is what the stack looks like at entry:
6586+  6663             ;
6587+  6663             ;	prim	exp
6588+  6663             ;	+0	+0	returnaddress A6663 caller
6589+  6663             ;	+2	+2	callf BIOS registers
6590+  6663             ;	+6	+14	returnaddress CALLF caller
6591+  6663             ;	+8	+16	returnaddress hook caller
6592+  6663             
6593+  6663             
6594+  6663 FB          A6663:	ei
6595+  6664 E5          	push	hl
6596+  6665 D5          	push	de
6597+  6666 C5          	push	bc
6598+  6667 F5          	push	af
6599+  6668 3A 48 F3    	ld	a,(YF348)
6600+  666B 87          	add	a,a
6601+  666C 21 10 00    	ld	hl,16
6602+  666F 30 02       	jr	nc,A6673
6603+  6671 2E 18       	ld	l,16+8
6604+  6673 39          A6673:	add	hl,sp
6605+  6674 DD E5       	push	ix
6606+  6676 C1          	pop	bc
6607+  6677 71          	ld	(hl),c
6608+  6678 23          	inc	hl
6609+  6679 70          	ld	(hl),b
6610+  667A 21 0A 00    	ld	hl,10
6611+  667D 39          	add	hl,sp
6612+  667E EB          	ex	de,hl
6613+  667F 18 0C       	jr	A668D
6614+  6681             
6615+  6681 FD E5       A6681:	push	iy
6616+  6683 C1          	pop	bc
6617+  6684 4E          A6684:	ld	c,(hl)
6618+  6685 1A          	ld	a,(de)
6619+  6686 77          	ld	(hl),a
6620+  6687 79          	ld	a,c
6621+  6688 12          	ld	(de),a
6622+  6689 23          	inc	hl
6623+  668A 13          	inc	de
6624+  668B 10 F7       	djnz	A6684
6625+  668D 3A 48 F3    A668D:	ld	a,(YF348)
6626+  6690 87          	add	a,a
6627+  6691 21 12 00    	ld	hl,18
6628+  6694 30 02       	jr	nc,A6698
6629+  6696 2E 1A       	ld	l,18+8
6630+  6698 39          A6698:	add	hl,sp
6631+  6699 7B          	ld	a,e
6632+  669A 95          	sub	l
6633+  669B 7A          	ld	a,d
6634+  669C 9C          	sbc	a,h
6635+  669D 38 E2       	jr	c,A6681
6636+  669F F1          A669F:	pop	af
6637+  66A0 C1          A66A0:	pop	bc
6638+  66A1 D1          	pop	de
6639+  66A2 E1          	pop	hl
6640+  66A3 C9          	ret
6641+  66A4             
6642+  66A4             ;	Subroutine	get pointer to i/o channel (H.GETP)
6643+  66A4             ;	Inputs		
6644+  66A4             ;	Outputs		________________________
6645+  66A4             
6646+  66A4 DD 21 8B F3 A66A4:	ld	ix,RETRTN
6647+  66A8 FD 21 00 02 	ld	iy,00200H
6648+  66AC CD 63 66    	call	A6663			; take control from caller (move parameters on stack)
6649+  66AF E1          	pop	hl
6650+  66B0 7E          	ld	a,(hl)
6651+  66B1 A7          	and	a
6652+  66B2 C9          	ret
6653+  66B3             
6654+  66B3             ;	Subroutine	OPEN statement expander (H.NOFO)
6655+  66B3             ;	Inputs		
6656+  66B3             ;	Outputs		________________________
6657+  66B3             
6658+  66B3 FB          A66B3:	ei
6659+  66B4 01 00 01    	ld	bc,256
6660+  66B7 ED 43 3D F3 	ld	(YF33D),bc		; default recordsize 256
6661+  66BB CD DA 72    	call	A72DA			; at end of statement ?
6662+  66BE 7B          	ld	a,e
6663+  66BF C8          	ret	z			; yes, quit
6664+  66C0 F5          	push	af
6665+  66C1 E5          	push	hl
6666+  66C2 3A 48 F3    	ld	a,(YF348)
6667+  66C5 87          	add	a,a
6668+  66C6 21 0C 00    	ld	hl,12
6669+  66C9 30 02       	jr	nc,A66CD
6670+  66CB 2E 14       	ld	l,12+8
6671+  66CD 39          A66CD:	add	hl,sp
6672+  66CE 7E          	ld	a,(hl)
6673+  66CF FE 04       	cp	4			; random mode ?
6674+  66D1 C2 18 73    	jp	nz,A7318		; nope,
6675+  66D4 23          	inc	hl
6676+  66D5 7E          	ld	a,(hl)
6677+  66D6 FE 09       	cp	9			; disk device ?
6678+  66D8 D2 18 73    	jp	nc,A7318		; nope,
6679+  66DB E1          	pop	hl
6680+  66DC CD D0 72    	call	A72D0
6681+  66DF FF          	defb	0FFH
6682+  66E0 CD D0 72    	call	A72D0
6683+  66E3 92          	defb	092H
6684+  66E4 CD D0 72    	call	A72D0
6685+  66E7 EF          	defb	0EFH			; check for LEN=
6686+  66E8 DD 21 56 47 	ld	ix,M4756
6687+  66EC CD 1E 73    	call	A731E			; evaluate word operand and check for 0-32767 range
6688+  66EF 1B          	dec	de
6689+  66F0 14          	inc	d
6690+  66F1 15          	dec	d			; should be 1-256
6691+  66F2 C2 15 73    	jp	nz,A7315		; nope,
6692+  66F5 13          	inc	de
6693+  66F6 ED 53 3D F3 	ld	(YF33D),de		; recordsize
6694+  66FA F1          	pop	af
6695+  66FB C9          	ret
6696+  66FC             
6697+  66FC             ;	Subroutine	open i/o channel (H.NULO)
6698+  66FC             ;	Inputs		
6699+  66FC             ;	Outputs		________________________
6700+  66FC             
6701+  66FC FB          A66FC:	ei
6702+  66FD D0          	ret	nc			; not for a disk device, return control
6703+  66FE DD 21 8B F3 	ld	ix,RETRTN
6704+  6702 FD 21 00 04 	ld	iy,00400H
6705+  6706 CD 63 66    	call	A6663			; take control from caller (move parameters on stack)
6706+  6709 CD A9 6F    	call	A6FA9			; validate filename
6707+  670C CD EA 65    	call	A65EA			; is file already open in one of the I/O channels ?
6708+  670F CA 09 73    	jp	z,A7309			; yep, error
6709+  6712 22 64 F8    	ld	(PTRFIL),hl
6710+  6715 7B          	ld	a,e
6711+  6716 FE 04       	cp	4
6712+  6718 28 07       	jr	z,A6721			; random mode, recordsize already set
6713+  671A 01 01 00    	ld	bc,1
6714+  671D ED 43 3D F3 	ld	(YF33D),bc		; all others use recordsize 1
6715+  6721 F1          A6721:	pop	af
6716+  6722 F5          	push	af			; I/O channel number
6717+  6723 E5          	push	hl
6718+  6724 D5          	push	de
6719+  6725 21 45 F3    	ld	hl,YF345
6720+  6728 BE          	cp	(hl)			; do I have a FCB for this channel ?
6721+  6729 D2 0C 73    	jp	nc,A730C		; nope,
6722+  672C 01 25 00    	ld	bc,37
6723+  672F 5F          	ld	e,a
6724+  6730 50          	ld	d,b
6725+  6731 2A 53 F3    	ld	hl,(YF353)		; base of the FCB's
6726+  6734 CD 1C 49    	call	A491C			; base + 37 * channelnumber
6727+  6737 AF          	xor	a
6728+  6738 21 0C 00    	ld	hl,12
6729+  673B 09          	add	hl,bc
6730+  673C 77          	ld	(hl),a			; reset EX byte of FCB
6731+  673D D1          	pop	de
6732+  673E E1          	pop	hl
6733+  673F 23          	inc	hl
6734+  6740 71          	ld	(hl),c
6735+  6741 23          	inc	hl
6736+  6742 70          	ld	(hl),b			; pointer to FCB
6737+  6743 23          	inc	hl
6738+  6744 77          	ld	(hl),a			; no backup char
6739+  6745 23          	inc	hl
6740+  6746 72          	ld	(hl),d			; devicenumber
6741+  6747 23          	inc	hl
6742+  6748 23          	inc	hl
6743+  6749 77          	ld	(hl),a			; current bufferoffset = 0
6744+  674A CD 36 66    	call	A6636			; search file
6745+  674D C5          	push	bc
6746+  674E D5          	push	de
6747+  674F 7A          	ld	a,d
6748+  6750 02          	ld	(bc),a			; devicenumber
6749+  6751 59          	ld	e,c
6750+  6752 50          	ld	d,b
6751+  6753 13          	inc	de
6752+  6754 CD 5A 66    	call	A665A			; copy FILNAM to FCB
6753+  6757 D1          	pop	de
6754+  6758 C1          	pop	bc
6755+  6759 7B          	ld	a,e
6756+  675A 20 1C       	jr	nz,A6778		; file exists,
6757+  675C E6 86       	and	086H			; file not exists and not binsav, random or output mode ?
6758+  675E CA 12 73    	jp	z,A7312			; yep, error
6759+  6761 D5          A6761:	push	de
6760+  6762 C5          	push	bc
6761+  6763 59          	ld	e,c
6762+  6764 50          	ld	d,b
6763+  6765 CD 1D 46    	call	A461D			; create file
6764+  6768 A7          	and	a
6765+  6769 C2 AB 71    	jp	nz,A71AB		; failed, error
6766+  676C E1          	pop	hl
6767+  676D CD FE 67    	call	A67FE			; setup FCB fields
6768+  6770 D1          	pop	de
6769+  6771 2A 64 F8    	ld	hl,(PTRFIL)
6770+  6774 73          	ld	(hl),e			; filemode, I/O channel open
6771+  6775 F1          A6775:	pop	af
6772+  6776 E1          	pop	hl
6773+  6777 C9          	ret
6774+  6778             
6775+  6778 FE 08       A6778:	cp	8
6776+  677A 28 45       	jr	z,A67C1			; append mode,
6777+  677C FE 02       	cp	2
6778+  677E 28 E1       	jr	z,A6761			; output mode, create file (overwrites!)
6779+  6780 FE 80       	cp	080H
6780+  6782 28 DD       	jr	z,A6761			; binsav mode, create file (overwrites!)
6781+  6784 D5          	push	de
6782+  6785 C5          	push	bc
6783+  6786 59          	ld	e,c
6784+  6787 50          	ld	d,b
6785+  6788 CD 62 44    	call	A4462			; open fcb
6786+  678B E1          	pop	hl
6787+  678C CD FE 67    	call	A67FE			; setup FCB fields
6788+  678F D1          	pop	de
6789+  6790 2A 64 F8    	ld	hl,(PTRFIL)
6790+  6793 73          	ld	(hl),e			; filemode, I/O channel open
6791+  6794 7B          	ld	a,e
6792+  6795 FE 04       	cp	4			; random mode ?
6793+  6797 28 DC       	jr	z,A6775			; yep, quit
6794+  6799 E5          	push	hl
6795+  679A 21 AE FC    	ld	hl,FLBMEM
6796+  679D AF          	xor	a
6797+  679E BE          	cp	(hl)			; in raw mode ?
6798+  679F 77          	ld	(hl),a
6799+  67A0 E1          	pop	hl
6800+  67A1 20 D2       	jr	nz,A6775		; yep, quit
6801+  67A3 01 06 00    	ld	bc,6
6802+  67A6 09          	add	hl,bc
6803+  67A7 E5          	push	hl
6804+  67A8 36 FF       	ld	(hl),0FFH		; position 255, so next get char fills buffer
6805+  67AA 2A 64 F8    	ld	hl,(PTRFIL)
6806+  67AD CD 2A 68    	call	A682A			; get char from I/O channel
6807+  67B0 E1          	pop	hl
6808+  67B1 2B          	dec	hl
6809+  67B2 2B          	dec	hl
6810+  67B3 2B          	dec	hl
6811+  67B4 77          	ld	(hl),a
6812+  67B5 FE FF       	cp	0FFH
6813+  67B7 20 BC       	jr	nz,A6775		; yep, quit
6814+  67B9 23          	inc	hl
6815+  67BA 23          	inc	hl
6816+  67BB 23          	inc	hl
6817+  67BC 23          	inc	hl
6818+  67BD 36 80       	ld	(hl),080H
6819+  67BF 18 B4       A67BF:	jr	A6775			; quit
6820+  67C1             
6821+  67C1 C5          A67C1:	push	bc
6822+  67C2 59          	ld	e,c
6823+  67C3 50          	ld	d,b
6824+  67C4 CD 62 44    	call	A4462			; open fcb
6825+  67C7 E1          	pop	hl
6826+  67C8 E5          	push	hl
6827+  67C9 CD FE 67    	call	A67FE			; setup FCB fields
6828+  67CC 2A 64 F8    	ld	hl,(PTRFIL)
6829+  67CF 36 01       	ld	(hl),1			; first in input mode
6830+  67D1 01 06 00    	ld	bc,6
6831+  67D4 09          	add	hl,bc
6832+  67D5 36 FF       	ld	(hl),0FFH		; position 255, so next get char fills buffer
6833+  67D7 2A 64 F8    	ld	hl,(PTRFIL)
6834+  67DA E5          A67DA:	push	hl
6835+  67DB CD 2A 68    	call	A682A			; get char from I/O channel
6836+  67DE E1          	pop	hl
6837+  67DF 30 F9       	jr	nc,A67DA		; not at the end of file, continue
6838+  67E1 36 02       	ld	(hl),2			; continue in output mode
6839+  67E3 E1          	pop	hl
6840+  67E4 01 21 00    	ld	bc,00021H
6841+  67E7 09          	add	hl,bc			; to the Rx field
6842+  67E8 0E 04       	ld	c,004H
6843+  67EA E5          	push	hl
6844+  67EB 37          	scf
6845+  67EC 7E          A67EC:	ld	a,(hl)
6846+  67ED 98          	sbc	a,b
6847+  67EE 77          	ld	(hl),a
6848+  67EF 23          	inc	hl
6849+  67F0 0D          	dec	c
6850+  67F1 20 F9       	jr	nz,A67EC		; decrease by 1
6851+  67F3 E1          	pop	hl
6852+  67F4 0C          	inc	c
6853+  67F5 30 02       	jr	nc,A67F9		; Make Rx a multiply of 256
6854+  67F7 0E 04       	ld	c,004H			; Rx = 0
6855+  67F9 CD 13 68    A67F9:	call	A6813
6856+  67FC 18 C1       	jr	A67BF			; quit
6857+  67FE             
6858+  67FE 01 0C 00    A67FE:	ld	bc,0000CH
6859+  6801 09          	add	hl,bc
6860+  6802 70          	ld	(hl),b			; clear EX byte
6861+  6803 23          	inc	hl
6862+  6804 70          	ld	(hl),b			; clear S1 byte
6863+  6805 23          	inc	hl
6864+  6806 ED 4B 3D F3 	ld	bc,(YF33D)
6865+  680A 71          	ld	(hl),c
6866+  680B 23          	inc	hl
6867+  680C 70          	ld	(hl),b			; user recordsize = recordsize
6868+  680D 01 11 00    	ld	bc,00011H
6869+  6810 09          	add	hl,bc
6870+  6811 0E 05       	ld	c,005H
6871+  6813 70          A6813:	ld	(hl),b
6872+  6814 23          	inc	hl
6873+  6815 0D          	dec	c
6874+  6816 20 FB       	jr	nz,A6813		; clear CR byte and Rx bytes
6875+  6818 C9          	ret
6876+  6819             
6877+  6819             ;	Subroutine	input from i/o channel (H.INDS)
6878+  6819             ;	Inputs		
6879+  6819             ;	Outputs		________________________
6880+  6819             
6881+  6819 DD 21 8B F3 A6819:	ld	ix,RETRTN
6882+  681D FD 21 00 06 	ld	iy,00600H
6883+  6821 CD 63 66    	call	A6663			; take control from caller (move parameters on stack)
6884+  6824 CD 2A 68    	call	A682A			; get char from I/O channel
6885+  6827 C3 A0 66    	jp	A66A0			; quit
6886+  682A             
6887+  682A E5          A682A:	push	hl
6888+  682B 7E          	ld	a,(hl)
6889+  682C FE 01       	cp	1			; input mode ?
6890+  682E C2 99 71    	jp	nz,A7199		; nope, error
6891+  6831 5D          	ld	e,l
6892+  6832 54          	ld	d,h
6893+  6833 23          	inc	hl
6894+  6834 23          	inc	hl
6895+  6835 23          	inc	hl
6896+  6836 7E          	ld	a,(hl)
6897+  6837 A7          	and	a			; backup char ?
6898+  6838 20 2C       	jr	nz,A6866		; yep, use that
6899+  683A 23          	inc	hl
6900+  683B 23          	inc	hl
6901+  683C 23          	inc	hl
6902+  683D 34          	inc	(hl)			; update counter
6903+  683E 7E          	ld	a,(hl)
6904+  683F 23          	inc	hl
6905+  6840 23          	inc	hl
6906+  6841 23          	inc	hl			; to the buffer
6907+  6842 20 1D       	jr	nz,A6861		; still characters left, use them
6908+  6844 E5          	push	hl
6909+  6845 22 3D F2    	ld	(YF23D),hl		; transferaddress is I/O channel buffer
6910+  6848 EB          	ex	de,hl
6911+  6849 23          	inc	hl
6912+  684A 5E          	ld	e,(hl)
6913+  684B 23          	inc	hl
6914+  684C 56          	ld	d,(hl)			; pointer to FCB
6915+  684D 21 00 01    	ld	hl,256
6916+  6850 CD B2 47    	call	A47B2			; random block read
6917+  6853 5D          	ld	e,l
6918+  6854 54          	ld	d,h
6919+  6855 25          	dec	h
6920+  6856 7D          	ld	a,l
6921+  6857 B4          	or	h			; have read 256 records ?
6922+  6858 E1          	pop	hl
6923+  6859 28 06       	jr	z,A6861			; yep, then not at end of file
6924+  685B E5          	push	hl
6925+  685C 19          	add	hl,de
6926+  685D 36 1A       	ld	(hl),01AH		; put a CTRL-Z at the end
6927+  685F E1          	pop	hl
6928+  6860 AF          	xor	a
6929+  6861 4F          A6861:	ld	c,a
6930+  6862 06 00       	ld	b,0
6931+  6864 09          	add	hl,bc
6932+  6865 7E          	ld	a,(hl)			; get char
6933+  6866 47          A6866:	ld	b,a
6934+  6867 D6 1A       	sub	01AH
6935+  6869 D6 01       	sub	001H
6936+  686B 78          	ld	a,b
6937+  686C E1          	pop	hl
6938+  686D 23          	inc	hl
6939+  686E 23          	inc	hl
6940+  686F 23          	inc	hl
6941+  6870 36 00       	ld	(hl),0			; no backup char
6942+  6872 D0          	ret	nc			; no CTRL-Z, quit
6943+  6873 77          	ld	(hl),a			; CTRL-Z as backup char, so it is always read again
6944+  6874 C9          	ret
6945+  6875             
6946+  6875             ;	Subroutine	putback for diskdevices (H.BAKU)
6947+  6875             ;	Inputs		
6948+  6875             ;	Outputs		________________________
6949+  6875             
6950+  6875 FB          A6875:	ei
6951+  6876 E5          	push	hl
6952+  6877 3A 48 F3    	ld	a,(YF348)
6953+  687A 87          	add	a,a
6954+  687B 21 08 00    	ld	hl,8
6955+  687E 30 02       	jr	nc,A6882
6956+  6880 2E 10       	ld	l,8+8
6957+  6882 39          A6882:	add	hl,sp
6958+  6883 36 41       	ld	(hl),LOW M6E41
6959+  6885 23          	inc	hl
6960+  6886 36 6E       	ld	(hl),HIGH M6E41		; resume character putback
6961+  6888 E1          	pop	hl
6962+  6889 23          	inc	hl
6963+  688A 23          	inc	hl
6964+  688B 23          	inc	hl
6965+  688C 71          	ld	(hl),c
6966+  688D C9          	ret
6967+  688E             
6968+  688E             ;	Subroutine	output to i/o channel (H.FILO)
6969+  688E             ;	Inputs		
6970+  688E             ;	Outputs		________________________
6971+  688E             
6972+  688E DD 21 8B F3 A688E:	ld	ix,RETRTN
6973+  6892 FD 21 00 08 	ld	iy,00800H
6974+  6896 CD 63 66    	call	A6663			; take control from caller (move parameters on stack)
6975+  6899 7E          	ld	a,(hl)
6976+  689A FE 02       	cp	2			; output mode ?
6977+  689C C2 99 71    	jp	nz,A7199		; nope, error
6978+  689F F1          	pop	af
6979+  68A0 F5          	push	af
6980+  68A1 CD A7 68    	call	A68A7			; write char to I/O channel
6981+  68A4 C3 9F 66    	jp	A669F			; quit
6982+  68A7             
6983+  68A7 E5          A68A7:	push	hl
6984+  68A8 01 06 00    	ld	bc,6
6985+  68AB 09          	add	hl,bc
6986+  68AC 4E          	ld	c,(hl)			; position
6987+  68AD 34          	inc	(hl)			; update
6988+  68AE 23          	inc	hl
6989+  68AF 23          	inc	hl
6990+  68B0 23          	inc	hl			; to buffer
6991+  68B1 09          	add	hl,bc
6992+  68B2 77          	ld	(hl),a			; put char in buffer
6993+  68B3 E1          	pop	hl
6994+  68B4 C0          	ret	nz			; buffer not full, quit
6995+  68B5 E5          A68B5:	push	hl
6996+  68B6 23          	inc	hl
6997+  68B7 5E          	ld	e,(hl)
6998+  68B8 23          	inc	hl
6999+  68B9 56          	ld	d,(hl)			; pointer to FCB
7000+  68BA 01 04 00    	ld	bc,4
7001+  68BD 09          	add	hl,bc
7002+  68BE 7E          	ld	a,(hl)			; position
7003+  68BF 23          	inc	hl
7004+  68C0 23          	inc	hl
7005+  68C1 23          	inc	hl
7006+  68C2 22 3D F2    	ld	(YF23D),hl		; transferaddress
7007+  68C5 A7          	and	a
7008+  68C6 6F          	ld	l,a
7009+  68C7 60          	ld	h,b
7010+  68C8 20 01       	jr	nz,A68CB		; not a complete buffer, only the used part
7011+  68CA 24          	inc	h			; 256
7012+  68CB CD 8F 71    A68CB:	call	A718F			; random block write
7013+  68CE E1          	pop	hl
7014+  68CF C9          	ret
7015+  68D0             
7016+  68D0             ;	Subroutine	close i/o channel for diskdevices (H.NTFL)
7017+  68D0             ;	Inputs		
7018+  68D0             ;	Outputs		________________________
7019+  68D0             
7020+  68D0 DD 21 8B F3 A68D0:	ld	ix,RETRTN
7021+  68D4 FD 21 00 04 	ld	iy,00400H
7022+  68D8 CD 63 66    	call	A6663			; take control from caller (move parameters on stack)
7023+  68DB E1          	pop	hl
7024+  68DC 7E          	ld	a,(hl)
7025+  68DD D6 02       	sub	2			; output mode ?
7026+  68DF 20 13       	jr	nz,A68F4		; nope,
7027+  68E1 E5          	push	hl
7028+  68E2 21 AE FC    	ld	hl,FLBMEM
7029+  68E5 BE          	cp	(hl)			; raw mode ?
7030+  68E6 77          	ld	(hl),a
7031+  68E7 E1          	pop	hl
7032+  68E8 20 0A       	jr	nz,A68F4		; yep, skip CTRL-Z
7033+  68EA 36 04       	ld	(hl),4			; switch to random mode
7034+  68EC 3E 1A       	ld	a,01AH			; CTRL-Z
7035+  68EE CD A7 68    	call	A68A7			; write char to I/O channel
7036+  68F1 C4 B5 68    	call	nz,A68B5		; buffer not empty, write remaining I/O channel buffer
7037+  68F4 E5          A68F4:	push	hl
7038+  68F5 23          	inc	hl
7039+  68F6 5E          	ld	e,(hl)
7040+  68F7 23          	inc	hl
7041+  68F8 56          	ld	d,(hl)			; pointer to FCB
7042+  68F9 CD 6F 45    	call	A456F			; close fcb
7043+  68FC E1          	pop	hl
7044+  68FD E5          	push	hl
7045+  68FE 11 07 00    	ld	de,7
7046+  6901 19          	add	hl,de
7047+  6902 72          	ld	(hl),d
7048+  6903 6A          	ld	l,d
7049+  6904 62          	ld	h,d
7050+  6905 22 64 F8    	ld	(PTRFIL),hl
7051+  6908 E1          	pop	hl
7052+  6909 34          	inc	(hl)
7053+  690A 35          	dec	(hl)
7054+  690B 72          	ld	(hl),d
7055+  690C E1          	pop	hl
7056+  690D C9          	ret
7057+  690E             
7058+  690E             ;	Subroutine	Binary Save  (H.BINS)
7059+  690E             ;	Inputs		
7060+  690E             ;	Outputs		________________________
7061+  690E             
7062+  690E CD 80 73    A690E:	call	A7380			; take control from caller
7063+  6911 E5          	push	hl
7064+  6912 DD 21 F7 54 	ld	ix,M54F7
7065+  6916 CD 1E 73    	call	A731E			; convert linepointers to linenumbers
7066+  6919 3E FF       	ld	a,0FFH
7067+  691B CD C7 69    	call	A69C7			; write byte to FCB (binairy basicfile id)
7068+  691E 2A 76 F6    	ld	hl,(TXTTAB)
7069+  6921 22 3D F2    	ld	(YF23D),hl		; transferaddress
7070+  6924 EB          	ex	de,hl
7071+  6925 2A C2 F6    	ld	hl,(VARTAB)
7072+  6928 A7          	and	a
7073+  6929 ED 52       	sbc	hl,de
7074+  692B CD 8B 71    	call	A718B
7075+  692E 32 7C F8    	ld	(NLONLY),a		; not loading basic program, close i/o channels when requested
7076+  6931 E1          	pop	hl
7077+  6932 DD 21 24 6B 	ld	ix,M6B24
7078+  6936 C3 1E 73    	jp	A731E			; close i/o channel
7079+  6939             
7080+  6939             ;	Subroutine	Binary Load  (H.BINL)
7081+  6939             ;	Inputs		
7082+  6939             ;	Outputs		________________________
7083+  6939             
7084+  6939 DD 21 9A 73 A6939:	ld	ix,M739A		; quit loading & start (headloop/executing)
7085+  693D FD 21 00 02 	ld	iy,00200H
7086+  6941 CD 63 66    	call	A6663			; take control from caller (move parameters on stack)
7087+  6944 F1          	pop	af
7088+  6945 CA 99 71    	jp	z,A7199
7089+  6948 DD 21 1C 6C 	ld	ix,M6C1C
7090+  694C CD 1E 73    	call	A731E			; close all i/o channels
7091+  694F 2A 53 F3    	ld	hl,(YF353)
7092+  6952 E5          	push	hl
7093+  6953 CD FE 67    	call	A67FE
7094+  6956 E1          	pop	hl
7095+  6957 E5          	push	hl
7096+  6958 01 13 00    	ld	bc,00013H
7097+  695B 09          	add	hl,bc
7098+  695C 7E          	ld	a,(hl)
7099+  695D A7          	and	a
7100+  695E C2 FD 72    	jp	nz,A72FD
7101+  6961 2B          	dec	hl
7102+  6962 B6          	or	(hl)
7103+  6963 C2 FD 72    	jp	nz,A72FD
7104+  6966 2B          	dec	hl
7105+  6967 56          	ld	d,(hl)
7106+  6968 2B          	dec	hl
7107+  6969 5E          	ld	e,(hl)
7108+  696A 2A 76 F6    	ld	hl,(TXTTAB)
7109+  696D 19          	add	hl,de
7110+  696E DA FD 72    	jp	c,A72FD
7111+  6971 01 93 00    	ld	bc,00093H
7112+  6974 09          	add	hl,bc
7113+  6975 DA FD 72    	jp	c,A72FD
7114+  6978 ED 72       	sbc	hl,sp
7115+  697A D2 FD 72    	jp	nc,A72FD
7116+  697D EB          	ex	de,hl
7117+  697E E3          	ex	(sp),hl
7118+  697F EB          	ex	de,hl
7119+  6980 CD D0 69    	call	A69D0			; read byte from FCB
7120+  6983 2A 76 F6    	ld	hl,(TXTTAB)
7121+  6986 22 3D F2    	ld	(YF23D),hl		; transferaddresss
7122+  6989 E1          	pop	hl
7123+  698A 2B          	dec	hl
7124+  698B CD B2 47    	call	A47B2			; random block read
7125+  698E ED 5B 76 F6 	ld	de,(TXTTAB)
7126+  6992 19          	add	hl,de
7127+  6993 22 C2 F6    	ld	(VARTAB),hl
7128+  6996 DD 21 53 42 	ld	ix,M4253
7129+  699A CD 1E 73    	call	A731E			; recalculate linepointers
7130+  699D 3A 66 F8    	ld	a,(FILNAM+0)
7131+  69A0 A7          	and	a
7132+  69A1 C0          	ret	nz
7133+  69A2 32 7C F8    	ld	(NLONLY),a		; not loading basic program, close i/o channels when requested
7134+  69A5 21 B9 69    	ld	hl,T69B9
7135+  69A8 11 68 F5    	ld	de,BUF+10
7136+  69AB 01 05 00    	ld	bc,5
7137+  69AE D5          	push	de
7138+  69AF ED B0       	ldir
7139+  69B1 E1          	pop	hl			; basicpointer
7140+  69B2 DD 21 01 46 	ld	ix,M4601
7141+  69B6 C3 1E 73    	jp	A731E			; continue in the execution loop
7142+  69B9             
7143+  69B9 3A92000000  T69B9:	defb	":",092H,0,0,0		; :RUN
7144+  69BE             
7145+  69BE E5          A69BE:	push	hl
7146+  69BF 7D          	ld	a,l
7147+  69C0 CD CB 69    	call	A69CB			; write byte to FCB
7148+  69C3 E1          	pop	hl
7149+  69C4 7C          	ld	a,h
7150+  69C5 18 04       	jr	A69CB			; write byte to FCB
7151+  69C7             
7152+  69C7 ED 5B 53 F3 A69C7:	ld	de,(YF353)
7153+  69CB 01 BE 47    A69CB:	ld	bc,A47BE		; random block write
7154+  69CE 18 03       	jr	A69D3
7155+  69D0             
7156+  69D0 01 B2 47    A69D0:	ld	bc,A47B2		; random block read
7157+  69D3 F5          A69D3:	push	af
7158+  69D4 21 01 00    	ld	hl,1
7159+  69D7 39          	add	hl,sp
7160+  69D8 22 3D F2    	ld	(YF23D),hl		; transferaddress
7161+  69DB D5          	push	de
7162+  69DC CD E2 69    	call	A69E2
7163+  69DF D1          	pop	de
7164+  69E0 F1          	pop	af
7165+  69E1 C9          	ret
7166+  69E2             
7167+  69E2 21 01 00    A69E2:	ld	hl,00001H
7168+  69E5 C5          	push	bc
7169+  69E6 C9          	ret
7170+  69E7             
7171+  69E7             ;	Subroutine	BSAVE for diskdevices
7172+  69E7             ;	Inputs		
7173+  69E7             ;	Outputs		________________________
7174+  69E7             
7175+  69E7 D5          A69E7:	push	de
7176+  69E8 CD 6A 6B    	call	A6B6A
7177+  69EB ED 53 BF FC 	ld	(SAVENT),de
7178+  69EF D5          	push	de
7179+  69F0 CD 6A 6B    	call	A6B6A
7180+  69F3 ED 53 7D F8 	ld	(SAVEND),de
7181+  69F7 E3          	ex	(sp),hl
7182+  69F8 EB          	ex	de,hl
7183+  69F9 E7          	rst	020H
7184+  69FA DA 15 73    	jp	c,A7315
7185+  69FD EB          	ex	de,hl
7186+  69FE E3          	ex	(sp),hl
7187+  69FF CD DA 72    	call	A72DA			; at end of statement ?
7188+  6A02 37          	scf
7189+  6A03 28 16       	jr	z,A6A1B			; yep,
7190+  6A05 CD D0 72    	call	A72D0
7191+  6A08 2C          	defb	","			; check for ","
7192+  6A09 FE 53       	cp	"S"
7193+  6A0B 20 06       	jr	nz,A6A13
7194+  6A0D CD DB 72    	call	A72DB			; get basic character
7195+  6A10 A7          	and	a
7196+  6A11 18 08       	jr	A6A1B
7197+  6A13             
7198+  6A13 CD 6E 6B    A6A13:	call	A6B6E
7199+  6A16 ED 53 BF FC 	ld	(SAVENT),de
7200+  6A1A 37          	scf
7201+  6A1B C1          A6A1B:	pop	bc
7202+  6A1C 30 05       	jr	nc,A6A23
7203+  6A1E 04          	inc	b
7204+  6A1F 05          	dec	b
7205+  6A20 F2 15 73    	jp	p,A7315
7206+  6A23 D1          A6A23:	pop	de
7207+  6A24 E5          	push	hl
7208+  6A25 C5          	push	bc
7209+  6A26 F5          	push	af
7210+  6A27 AF          	xor	a			; i/o channel 0
7211+  6A28 1E 02       	ld	e,2			; output mode
7212+  6A2A DD 21 FA 6A 	ld	ix,M6AFA
7213+  6A2E CD 1E 73    	call	A731E			; open i/o channel
7214+  6A31 3E FE       	ld	a,0FEH
7215+  6A33 CD C7 69    	call	A69C7			; write byte to FCB (bsave file id)
7216+  6A36 F1          	pop	af
7217+  6A37 E1          	pop	hl
7218+  6A38 E5          	push	hl
7219+  6A39 F5          	push	af
7220+  6A3A CD BE 69    	call	A69BE			; write word to FCB
7221+  6A3D 2A 7D F8    	ld	hl,(SAVEND)
7222+  6A40 CD BE 69    	call	A69BE			; write word to FCB
7223+  6A43 2A BF FC    	ld	hl,(SAVENT)
7224+  6A46 CD BE 69    	call	A69BE			; write word to FCB
7225+  6A49 F1          	pop	af
7226+  6A4A C1          	pop	bc
7227+  6A4B F5          	push	af
7228+  6A4C ED 43 3D F2 	ld	(YF23D),bc		; transferaddress
7229+  6A50 2A 7D F8    	ld	hl,(SAVEND)
7230+  6A53 A7          	and	a
7231+  6A54 ED 42       	sbc	hl,bc
7232+  6A56 23          	inc	hl
7233+  6A57 F1          	pop	af
7234+  6A58 30 13       	jr	nc,A6A6D
7235+  6A5A CD 8B 71    	call	A718B
7236+  6A5D 3E FF       A6A5D:	ld	a,0FFH
7237+  6A5F 32 AE FC    	ld	(FLBMEM),a		; raw mode
7238+  6A62 AF          	xor	a
7239+  6A63 DD 21 24 6B 	ld	ix,M6B24
7240+  6A67 CD 1E 73    	call	A731E			; close i/o channel
7241+  6A6A C3 F8 6E    	jp	A6EF8
7242+  6A6D             
7243+  6A6D CD 65 71    A6A6D:	call	A7165
7244+  6A70 E5          A6A70:	push	hl
7245+  6A71 ED 5B BF FC 	ld	de,(SAVENT)
7246+  6A75 E7          	rst	020H
7247+  6A76 F5          	push	af
7248+  6A77 4D          	ld	c,l
7249+  6A78 44          	ld	b,h
7250+  6A79 2A 7D F8    	ld	hl,(SAVEND)
7251+  6A7C E5          	push	hl
7252+  6A7D 09          	add	hl,bc
7253+  6A7E 22 7D F8    	ld	(SAVEND),hl
7254+  6A81 E1          	pop	hl
7255+  6A82 ED 5B 3D F2 	ld	de,(YF23D)		; transferaddress
7256+  6A86 CD 59 00    	call	LDIRMV
7257+  6A89 F1          	pop	af
7258+  6A8A 30 12       	jr	nc,A6A9E
7259+  6A8C E1          	pop	hl
7260+  6A8D E5          	push	hl
7261+  6A8E CD 8B 71    	call	A718B
7262+  6A91 2A BF FC    	ld	hl,(SAVENT)
7263+  6A94 D1          	pop	de
7264+  6A95 A7          	and	a
7265+  6A96 ED 52       	sbc	hl,de
7266+  6A98 22 BF FC    	ld	(SAVENT),hl
7267+  6A9B EB          	ex	de,hl
7268+  6A9C 18 D2       	jr	A6A70
7269+  6A9E             
7270+  6A9E E1          A6A9E:	pop	hl
7271+  6A9F 2A BF FC    	ld	hl,(SAVENT)
7272+  6AA2 CD 8B 71    	call	A718B
7273+  6AA5 18 B6       	jr	A6A5D
7274+  6AA7             
7275+  6AA7             ;	Subroutine	BLOAD for diskdevices
7276+  6AA7             ;	Inputs		
7277+  6AA7             ;	Outputs		________________________
7278+  6AA7             
7279+  6AA7 D5          A6AA7:	push	de
7280+  6AA8 AF          	xor	a
7281+  6AA9 32 BE FC    	ld	(RUNBNF),a		; assume no autostart, no vram
7282+  6AAC 4F          	ld	c,a
7283+  6AAD 47          	ld	b,a			; assume offset 0
7284+  6AAE CD DA 72    	call	A72DA			; at end of statement ?
7285+  6AB1 28 1D       	jr	z,A6AD0			; yep,
7286+  6AB3 CD D0 72    	call	A72D0
7287+  6AB6 2C          	defb	","			; check for ","
7288+  6AB7 FE 52       	cp	"R"			; autorun specified ?
7289+  6AB9 28 04       	jr	z,A6ABF			; yep, set autorun
7290+  6ABB FE 53       	cp	"S"			; vram specified ?
7291+  6ABD 20 0C       	jr	nz,A6ACB		; nope, then it must be a offset
7292+  6ABF 32 BE FC    A6ABF:	ld	(RUNBNF),a
7293+  6AC2 CD DB 72    	call	A72DB			; get basic character
7294+  6AC5 28 09       	jr	z,A6AD0			; end of statement, skip offset
7295+  6AC7 CD D0 72    	call	A72D0
7296+  6ACA 2C          	defb	","			; check for ","
7297+  6ACB CD 6E 6B    A6ACB:	call	A6B6E
7298+  6ACE 42          	ld	b,d
7299+  6ACF 4B          	ld	c,e			; offset
7300+  6AD0 D1          A6AD0:	pop	de
7301+  6AD1 E5          	push	hl
7302+  6AD2 C5          	push	bc
7303+  6AD3 3E FF       	ld	a,0FFH
7304+  6AD5 32 AE FC    	ld	(FLBMEM),a		; raw mode
7305+  6AD8 AF          	xor	a			; i/o channel 0
7306+  6AD9 1E 01       	ld	e,1			; input mode
7307+  6ADB DD 21 FA 6A 	ld	ix,M6AFA
7308+  6ADF CD 1E 73    	call	A731E			; open i/o channel
7309+  6AE2 ED 5B 53 F3 	ld	de,(YF353)
7310+  6AE6 CD D0 69    	call	A69D0			; read byte from FCB
7311+  6AE9 FE FE       	cp	0FEH
7312+  6AEB C2 99 71    	jp	nz,A7199
7313+  6AEE C1          	pop	bc
7314+  6AEF CD 5C 6B    	call	A6B5C			; read word from FCB and add offset
7315+  6AF2 E5          	push	hl
7316+  6AF3 CD 5C 6B    	call	A6B5C			; read word from FCB and add offset
7317+  6AF6 E5          	push	hl
7318+  6AF7 CD 5C 6B    	call	A6B5C			; read word from FCB and add offset
7319+  6AFA 22 BF FC    	ld	(SAVENT),hl
7320+  6AFD E1          	pop	hl
7321+  6AFE C1          	pop	bc
7322+  6AFF A7          	and	a
7323+  6B00 ED 42       	sbc	hl,bc			; end address - start address
7324+  6B02 23          	inc	hl
7325+  6B03 ED 43 3D F2 	ld	(YF23D),bc		; transferaddress
7326+  6B07 3A BE FC    	ld	a,(RUNBNF)
7327+  6B0A FE 53       	cp	"S"			; vram load ?
7328+  6B0C 28 0C       	jr	z,A6B1A			; yep,
7329+  6B0E CD B2 47    	call	A47B2			; random block read
7330+  6B11 DD 21 FF 4A A6B11:	ld	ix,M4AFF
7331+  6B15 CD 1E 73    	call	A731E			; output back to screen
7332+  6B18 E1          	pop	hl
7333+  6B19 C9          	ret
7334+  6B1A             
7335+  6B1A CD 65 71    A6B1A:	call	A7165
7336+  6B1D E5          A6B1D:	push	hl
7337+  6B1E ED 5B BF FC 	ld	de,(SAVENT)
7338+  6B22 E7          	rst	020H
7339+  6B23 F5          	push	af
7340+  6B24 ED 5B 53 F3 	ld	de,(YF353)
7341+  6B28 CD B2 47    	call	A47B2			; random block read
7342+  6B2B F1          	pop	af
7343+  6B2C C1          	pop	bc
7344+  6B2D C5          	push	bc
7345+  6B2E F5          	push	af
7346+  6B2F 2A 7D F8    	ld	hl,(SAVEND)
7347+  6B32 E5          	push	hl
7348+  6B33 09          	add	hl,bc
7349+  6B34 22 7D F8    	ld	(SAVEND),hl
7350+  6B37 D1          	pop	de
7351+  6B38 2A 3D F2    	ld	hl,(YF23D)		; transferaddress
7352+  6B3B F1          	pop	af
7353+  6B3C 30 10       	jr	nc,A6B4E
7354+  6B3E CD 5C 00    	call	LDIRVM
7355+  6B41 2A BF FC    	ld	hl,(SAVENT)
7356+  6B44 D1          	pop	de
7357+  6B45 A7          	and	a
7358+  6B46 ED 52       	sbc	hl,de
7359+  6B48 22 BF FC    	ld	(SAVENT),hl
7360+  6B4B EB          	ex	de,hl
7361+  6B4C 18 CF       	jr	A6B1D
7362+  6B4E             
7363+  6B4E C1          A6B4E:	pop	bc
7364+  6B4F ED 4B BF FC 	ld	bc,(SAVENT)
7365+  6B53 CD 5C 00    	call	LDIRVM
7366+  6B56 AF          	xor	a
7367+  6B57 32 BE FC    	ld	(RUNBNF),a
7368+  6B5A 18 B5       	jr	A6B11
7369+  6B5C             
7370+  6B5C C5          A6B5C:	push	bc
7371+  6B5D CD D0 69    	call	A69D0			; read byte from FCB
7372+  6B60 F5          	push	af
7373+  6B61 CD D0 69    	call	A69D0			; read byte from FCB
7374+  6B64 67          	ld	h,a
7375+  6B65 F1          	pop	af
7376+  6B66 6F          	ld	l,a
7377+  6B67 C1          	pop	bc
7378+  6B68 09          	add	hl,bc
7379+  6B69 C9          	ret
7380+  6B6A             
7381+  6B6A CD D0 72    A6B6A:	call	A72D0
7382+  6B6D 2C          	defb	","			; check for ","
7383+  6B6E DD 21 0B 6F A6B6E:	ld	ix,M6F0B
7384+  6B72 C3 1E 73    	jp	A731E			; evaluate address operand (BLOAD/SAVE)
7385+  6B75             
7386+  6B75             ;	Subroutine	DSKI$ function (H.DSKI)
7387+  6B75             ;	Inputs		
7388+  6B75             ;	Outputs		________________________
7389+  6B75             
7390+  6B75 CD 80 73    A6B75:	call	A7380			; take control from caller
7391+  6B78 CD DB 72    	call	A72DB			; get basic character
7392+  6B7B CD D0 72    	call	A72D0
7393+  6B7E 28          	defb	"("			; check for "("
7394+  6B7F CD C5 6B    	call	A6BC5
7395+  6B82 CD D0 72    	call	A72D0
7396+  6B85 29          	defb	")"			; check for ")"
7397+  6B86 E5          	push	hl
7398+  6B87 21 D6 3F    	ld	hl,M3FD6
7399+  6B8A 22 F8 F7    	ld	(DAC+2),hl
7400+  6B8D E1          	pop	hl
7401+  6B8E 3E 03       	ld	a,3
7402+  6B90 32 63 F6    	ld	(VALTYP),a
7403+  6B93 A7          	and	a
7404+  6B94 18 0B       	jr	A6BA1
7405+  6B96             
7406+  6B96             ;	Subroutine	DSKO statement (H.DSKO)
7407+  6B96             ;	Inputs		
7408+  6B96             ;	Outputs
7409+  6B96             
7410+  6B96 CD 80 73    A6B96:	call	A7380			; take control from caller
7411+  6B99 CD C5 6B    	call	A6BC5
7412+  6B9C CD DA 72    	call	A72DA			; at end of statement ?
7413+  6B9F C0          	ret	nz			; nope, quit
7414+  6BA0 37          	scf
7415+  6BA1 F5          A6BA1:	push	af
7416+  6BA2 E5          	push	hl
7417+  6BA3 D5          	push	de
7418+  6BA4 59          	ld	e,c
7419+  6BA5 CD 5D 50    	call	A505D
7420+  6BA8 3C          	inc	a
7421+  6BA9 CA 9C 71    	jp	z,A719C
7422+  6BAC D1          	pop	de
7423+  6BAD E1          	pop	hl
7424+  6BAE F1          	pop	af
7425+  6BAF E5          	push	hl
7426+  6BB0 3E FF       	ld	a,0FFH
7427+  6BB2 32 46 F2    	ld	(YF246),a		; invalid dirsector buffer
7428+  6BB5 DD 7E 00    	ld	a,(ix+0)		; driveid
7429+  6BB8 06 01       	ld	b,001H
7430+  6BBA DD 4E 01    	ld	c,(ix+1)		; mediadescriptor
7431+  6BBD 2A 51 F3    	ld	hl,(YF351)		; temporary use dirsector buffer
7432+  6BC0 CD 44 01    	call	PHYDIO
7433+  6BC3 E1          	pop	hl
7434+  6BC4 C9          	ret
7435+  6BC5             
7436+  6BC5 DD 21 1C 52 A6BC5:	ld	ix,M521C
7437+  6BC9 CD 1E 73    	call	A731E			; evaluate byte operand
7438+  6BCC D5          	push	de
7439+  6BCD CD D0 72    	call	A72D0
7440+  6BD0 2C          	defb	","			; check for ","
7441+  6BD1 DD 21 2F 54 	ld	ix,M542F
7442+  6BD5 CD 1E 73    	call	A731E			; evaluate address operand
7443+  6BD8 C1          	pop	bc
7444+  6BD9 C9          	ret
7445+  6BDA             
7446+  6BDA             ;	Subroutine	GET/PUT statement (H.DGET)
7447+  6BDA             ;	Inputs		
7448+  6BDA             ;	Outputs		________________________
7449+  6BDA             
7450+  6BDA DD 21 8B F3 A6BDA:	ld	ix,RETRTN
7451+  6BDE FD 21 00 04 	ld	iy,00400H
7452+  6BE2 CD 63 66    	call	A6663			; take control from caller (move parameters on stack)
7453+  6BE5 7E          	ld	a,(hl)
7454+  6BE6 FE 04       	cp	4			; random mode ?
7455+  6BE8 C2 99 71    	jp	nz,A7199		; nope,
7456+  6BEB 23          	inc	hl
7457+  6BEC 5E          	ld	e,(hl)
7458+  6BED 23          	inc	hl
7459+  6BEE 56          	ld	d,(hl)			; pointer to FCB
7460+  6BEF 01 07 00    	ld	bc,7
7461+  6BF2 09          	add	hl,bc
7462+  6BF3 E3          	ex	(sp),hl
7463+  6BF4 CD DA 72    	call	A72DA			; at end of statement ?
7464+  6BF7 28 30       	jr	z,A6C29			; yep,
7465+  6BF9 D5          	push	de
7466+  6BFA CD D0 72    	call	A72D0
7467+  6BFD 2C          	defb	","			; check for ","
7468+  6BFE DD 21 64 4C 	ld	ix,M4C64
7469+  6C02 CD 1E 73    	call	A731E			; evaluate expression
7470+  6C05 E5          	push	hl
7471+  6C06 CD FB 6D    	call	A6DFB
7472+  6C09 79          	ld	a,c
7473+  6C0A B0          	or	b
7474+  6C0B B5          	or	l
7475+  6C0C B4          	or	h
7476+  6C0D CA 15 73    	jp	z,A7315
7477+  6C10 79          	ld	a,c
7478+  6C11 B0          	or	b
7479+  6C12 0B          	dec	bc
7480+  6C13 20 01       	jr	nz,A6C16
7481+  6C15 2B          	dec	hl
7482+  6C16 EB          A6C16:	ex	de,hl
7483+  6C17 E1          	pop	hl
7484+  6C18 E3          	ex	(sp),hl
7485+  6C19 E5          	push	hl
7486+  6C1A D5          	push	de
7487+  6C1B 11 21 00    	ld	de,00021H
7488+  6C1E 19          	add	hl,de
7489+  6C1F D1          	pop	de
7490+  6C20 71          	ld	(hl),c
7491+  6C21 23          	inc	hl
7492+  6C22 70          	ld	(hl),b
7493+  6C23 23          	inc	hl
7494+  6C24 73          	ld	(hl),e
7495+  6C25 23          	inc	hl
7496+  6C26 72          	ld	(hl),d
7497+  6C27 D1          	pop	de
7498+  6C28 E1          	pop	hl
7499+  6C29 E3          A6C29:	ex	(sp),hl
7500+  6C2A 22 3D F2    	ld	(YF23D),hl		; transferaddress
7501+  6C2D E1          	pop	hl
7502+  6C2E F1          	pop	af
7503+  6C2F E5          	push	hl
7504+  6C30 A7          	and	a
7505+  6C31 21 03 73    	ld	hl,A7303
7506+  6C34 01 B2 47    	ld	bc,A47B2		; random block read
7507+  6C37 28 06       	jr	z,A6C3F
7508+  6C39 21 A8 71    	ld	hl,A71A8
7509+  6C3C 01 BE 47    	ld	bc,A47BE		; random block write
7510+  6C3F E5          A6C3F:	push	hl
7511+  6C40 CD E2 69    	call	A69E2
7512+  6C43 A7          	and	a
7513+  6C44 C0          	ret	nz
7514+  6C45 E1          	pop	hl
7515+  6C46 C3 F8 6E    	jp	A6EF8
7516+  6C49             
7517+  6C49             ;	Subroutine	FIELD statement (H.FIEL)
7518+  6C49             ;	Inputs		
7519+  6C49             ;	Outputs		________________________
7520+  6C49             
7521+  6C49 CD 80 73    A6C49:	call	A7380			; take control from caller
7522+  6C4C FE 23       	cp	"#"
7523+  6C4E CC DB 72    	call	z,A72DB			; get basic character
7524+  6C51 DD 21 1C 52 	ld	ix,M521C
7525+  6C55 CD 1E 73    	call	A731E			; evaluate byte operand
7526+  6C58 CA 18 73    	jp	z,A7318
7527+  6C5B E5          	push	hl
7528+  6C5C DD 21 6D 6A 	ld	ix,M6A6D
7529+  6C60 CD 1E 73    	call	A731E			; get i/o channel pointer
7530+  6C63 5D          	ld	e,l
7531+  6C64 54          	ld	d,h
7532+  6C65 CA 00 73    	jp	z,A7300
7533+  6C68 DA 15 73    	jp	c,A7315
7534+  6C6B 7E          	ld	a,(hl)
7535+  6C6C FE 04       	cp	004H
7536+  6C6E C2 99 71    	jp	nz,A7199
7537+  6C71 23          	inc	hl
7538+  6C72 7E          	ld	a,(hl)
7539+  6C73 23          	inc	hl
7540+  6C74 66          	ld	h,(hl)
7541+  6C75 6F          	ld	l,a
7542+  6C76 01 0E 00    	ld	bc,0000EH
7543+  6C79 09          	add	hl,bc
7544+  6C7A 4E          	ld	c,(hl)
7545+  6C7B 23          	inc	hl
7546+  6C7C 46          	ld	b,(hl)
7547+  6C7D ED 43 68 F5 	ld	(BUF+10),bc
7548+  6C81 21 00 00    	ld	hl,00000H
7549+  6C84 22 6A F5    	ld	(BUF+12),hl
7550+  6C87 01 09 00    	ld	bc,00009H
7551+  6C8A E1          	pop	hl
7552+  6C8B EB          A6C8B:	ex	de,hl
7553+  6C8C 09          	add	hl,bc
7554+  6C8D EB          	ex	de,hl
7555+  6C8E 7E          	ld	a,(hl)
7556+  6C8F FE 2C       	cp	","
7557+  6C91 C0          	ret	nz
7558+  6C92 D5          	push	de
7559+  6C93 DD 21 1B 52 	ld	ix,M521B
7560+  6C97 CD 1E 73    	call	A731E			; skip basic char and evaluate byte operand
7561+  6C9A F5          	push	af
7562+  6C9B CD D0 72    	call	A72D0
7563+  6C9E 41          	defb	"A"
7564+  6C9F CD D0 72    	call	A72D0
7565+  6CA2 53          	defb	"S"			; check for "AS"
7566+  6CA3 DD 21 A4 5E 	ld	ix,M5EA4
7567+  6CA7 CD 1E 73    	call	A731E			; get address of variable
7568+  6CAA DD 21 97 55 	ld	ix,M5597
7569+  6CAE CD 1E 73    	call	A731E			; GETYPR
7570+  6CB1 C2 FA 72    	jp	nz,A72FA
7571+  6CB4 F1          	pop	af
7572+  6CB5 E3          	ex	(sp),hl
7573+  6CB6 D5          	push	de
7574+  6CB7 E5          	push	hl
7575+  6CB8 2A 6A F5    	ld	hl,(BUF+12)
7576+  6CBB 4F          	ld	c,a
7577+  6CBC 06 00       	ld	b,000H
7578+  6CBE 09          	add	hl,bc
7579+  6CBF 22 6A F5    	ld	(BUF+12),hl
7580+  6CC2 EB          	ex	de,hl
7581+  6CC3 2A 68 F5    	ld	hl,(BUF+10)
7582+  6CC6 E7          	rst	020H
7583+  6CC7 DA 06 73    	jp	c,A7306
7584+  6CCA D1          	pop	de
7585+  6CCB E1          	pop	hl
7586+  6CCC 71          	ld	(hl),c
7587+  6CCD 23          	inc	hl
7588+  6CCE 73          	ld	(hl),e
7589+  6CCF 23          	inc	hl
7590+  6CD0 72          	ld	(hl),d
7591+  6CD1 06 00       	ld	b,000H
7592+  6CD3 E1          	pop	hl
7593+  6CD4 18 B5       	jr	A6C8B
7594+  6CD6             
7595+  6CD6             ;	Subroutine	RSET statement (H.RSET)
7596+  6CD6             ;	Inputs		
7597+  6CD6             ;	Outputs		________________________
7598+  6CD6             
7599+  6CD6 F6          A6CD6:	defb	0F6H
7600+  6CD7             
7601+  6CD7             ;	Subroutine	LSET statement (H.LSET)
7602+  6CD7             ;	Inputs		
7603+  6CD7             ;	Outputs		________________________
7604+  6CD7             
7605+  6CD7 37          A6CD7:	scf
7606+  6CD8 CD 80 73    	call	A7380			; take control from caller
7607+  6CDB F5          	push	af
7608+  6CDC DD 21 A4 5E 	ld	ix,M5EA4
7609+  6CE0 CD 1E 73    	call	A731E			; get address of variable
7610+  6CE3 DD 21 97 55 	ld	ix,M5597
7611+  6CE7 CD 1E 73    	call	A731E			; GETYPR
7612+  6CEA C2 FA 72    	jp	nz,A72FA
7613+  6CED D5          	push	de
7614+  6CEE DD 21 5F 4C 	ld	ix,M4C5F
7615+  6CF2 CD 1E 73    	call	A731E			; evaluate =expression
7616+  6CF5 C1          	pop	bc
7617+  6CF6 E3          	ex	(sp),hl
7618+  6CF7 E5          	push	hl
7619+  6CF8 C5          	push	bc
7620+  6CF9 DD 21 D0 67 	ld	ix,M67D0
7621+  6CFD CD 1E 73    	call	A731E			; free temporary string
7622+  6D00 46          	ld	b,(hl)
7623+  6D01 E3          	ex	(sp),hl
7624+  6D02 7E          	ld	a,(hl)
7625+  6D03 4F          	ld	c,a
7626+  6D04 C5          	push	bc
7627+  6D05 E5          	push	hl
7628+  6D06 F5          	push	af
7629+  6D07 23          	inc	hl
7630+  6D08 5E          	ld	e,(hl)
7631+  6D09 23          	inc	hl
7632+  6D0A 56          	ld	d,(hl)
7633+  6D0B B7          	or	a
7634+  6D0C 28 5C       	jr	z,A6D6A
7635+  6D0E 2A 62 F8    	ld	hl,(NULBUF)
7636+  6D11 2B          	dec	hl
7637+  6D12 E7          	rst	020H
7638+  6D13 38 33       	jr	c,A6D48
7639+  6D15 2A C2 F6    	ld	hl,(VARTAB)
7640+  6D18 E7          	rst	020H
7641+  6D19 38 2D       	jr	c,A6D48
7642+  6D1B 59          	ld	e,c
7643+  6D1C 16 00       	ld	d,000H
7644+  6D1E 2A 74 F6    	ld	hl,(STKTOP)
7645+  6D21 19          	add	hl,de
7646+  6D22 EB          	ex	de,hl
7647+  6D23 2A 9B F6    	ld	hl,(FRETOP)
7648+  6D26 E7          	rst	020H
7649+  6D27 38 54       	jr	c,A6D7D
7650+  6D29 F1          	pop	af
7651+  6D2A 79          A6D2A:	ld	a,c
7652+  6D2B DD 21 8E 66 	ld	ix,M668E
7653+  6D2F CD 1E 73    	call	A731E			; allocate stringspace
7654+  6D32 E1          	pop	hl
7655+  6D33 C1          	pop	bc
7656+  6D34 E3          	ex	(sp),hl
7657+  6D35 D5          	push	de
7658+  6D36 C5          	push	bc
7659+  6D37 DD 21 D0 67 	ld	ix,M67D0
7660+  6D3B CD 1E 73    	call	A731E			; free temporary string
7661+  6D3E C1          	pop	bc
7662+  6D3F D1          	pop	de
7663+  6D40 E3          	ex	(sp),hl
7664+  6D41 C5          	push	bc
7665+  6D42 E5          	push	hl
7666+  6D43 23          	inc	hl
7667+  6D44 F5          	push	af
7668+  6D45 73          	ld	(hl),e
7669+  6D46 23          	inc	hl
7670+  6D47 72          	ld	(hl),d
7671+  6D48 F1          A6D48:	pop	af
7672+  6D49 E1          	pop	hl
7673+  6D4A 23          	inc	hl
7674+  6D4B 5E          	ld	e,(hl)
7675+  6D4C 23          	inc	hl
7676+  6D4D 56          	ld	d,(hl)
7677+  6D4E C1          	pop	bc
7678+  6D4F E1          	pop	hl
7679+  6D50 23          	inc	hl
7680+  6D51 7E          	ld	a,(hl)
7681+  6D52 23          	inc	hl
7682+  6D53 66          	ld	h,(hl)
7683+  6D54 6F          	ld	l,a
7684+  6D55 79          	ld	a,c
7685+  6D56 B8          	cp	b
7686+  6D57 30 01       	jr	nc,A6D5A
7687+  6D59 47          	ld	b,a
7688+  6D5A 90          A6D5A:	sub	b
7689+  6D5B 4F          	ld	c,a
7690+  6D5C F1          	pop	af
7691+  6D5D D4 74 6D    	call	nc,A6D74
7692+  6D60 04          	inc	b
7693+  6D61 05          A6D61:	dec	b
7694+  6D62 28 0B       	jr	z,A6D6F
7695+  6D64 7E          	ld	a,(hl)
7696+  6D65 12          	ld	(de),a
7697+  6D66 23          	inc	hl
7698+  6D67 13          	inc	de
7699+  6D68 18 F7       	jr	A6D61
7700+  6D6A             
7701+  6D6A C1          A6D6A:	pop	bc
7702+  6D6B C1          	pop	bc
7703+  6D6C C1          	pop	bc
7704+  6D6D C1          	pop	bc
7705+  6D6E C1          	pop	bc
7706+  6D6F DC 74 6D    A6D6F:	call	c,A6D74
7707+  6D72 E1          	pop	hl
7708+  6D73 C9          	ret
7709+  6D74             
7710+  6D74 3E 20       A6D74:	ld	a,020H
7711+  6D76 0C          	inc	c
7712+  6D77 0D          A6D77:	dec	c
7713+  6D78 C8          	ret	z
7714+  6D79 12          	ld	(de),a
7715+  6D7A 13          	inc	de
7716+  6D7B 18 FA       	jr	A6D77
7717+  6D7D             
7718+  6D7D F1          A6D7D:	pop	af
7719+  6D7E E1          	pop	hl
7720+  6D7F C1          	pop	bc
7721+  6D80 E3          	ex	(sp),hl
7722+  6D81 EB          	ex	de,hl
7723+  6D82 20 25       	jr	nz,A6DA9
7724+  6D84 C5          	push	bc
7725+  6D85 78          	ld	a,b
7726+  6D86 DD 21 27 66 	ld	ix,M6627
7727+  6D8A CD 1E 73    	call	A731E			; allocate temporary string
7728+  6D8D 11 98 F6    	ld	de,TEMPST+30
7729+  6D90 2A 78 F6    	ld	hl,(TEMPPT)
7730+  6D93 22 F8 F7    	ld	(DAC+2),hl
7731+  6D96 3E 03       	ld	a,3
7732+  6D98 32 63 F6    	ld	(VALTYP),a
7733+  6D9B CD F3 2E    	call	M2EF3			; copy stringdescriptor
7734+  6D9E 11 9B F6    	ld	de,TEMPST+30+3
7735+  6DA1 E7          	rst	020H
7736+  6DA2 22 78 F6    	ld	(TEMPPT),hl
7737+  6DA5 CA F7 72    	jp	z,A72F7
7738+  6DA8 C1          	pop	bc
7739+  6DA9 E3          A6DA9:	ex	(sp),hl
7740+  6DAA C5          	push	bc
7741+  6DAB E5          	push	hl
7742+  6DAC C3 2A 6D    	jp	A6D2A
7743+  6DAF             
7744+  6DAF             ;	Subroutine	MKI$ function (H.MKI$)
7745+  6DAF             ;	Inputs		
7746+  6DAF             ;	Outputs		________________________
7747+  6DAF             
7748+  6DAF 3E 02       A6DAF:	ld	a,2
7749+  6DB1 01          	defb	001H
7750+  6DB2             
7751+  6DB2             ;	Subroutine	MKS$ function (H.MKS$)
7752+  6DB2             ;	Inputs		
7753+  6DB2             ;	Outputs		________________________
7754+  6DB2             
7755+  6DB2 3E 04       A6DB2:	ld	a,4
7756+  6DB4 01          	defb	001H
7757+  6DB5             
7758+  6DB5             ;	Subroutine	MKD$ function (H.MKD$)
7759+  6DB5             ;	Inputs		
7760+  6DB5             ;	Outputs		________________________
7761+  6DB5             
7762+  6DB5 3E 08       A6DB5:	ld	a,8
7763+  6DB7 CD 80 73    	call	A7380			; take control from caller
7764+  6DBA F5          	push	af
7765+  6DBB DD 21 7A 51 	ld	ix,M517A
7766+  6DBF CD 1E 73    	call	A731E			; convert DAC
7767+  6DC2 F1          	pop	af
7768+  6DC3 DD 21 27 66 	ld	ix,M6627
7769+  6DC7 CD 1E 73    	call	A731E			; allocate temporary string
7770+  6DCA 2A 99 F6    	ld	hl,(DSCTMP+1)
7771+  6DCD CD 10 2F    	call	M2F10			; copy variable content from DAC
7772+  6DD0 C3 F1 61    	jp	A61F1
7773+  6DD3             
7774+  6DD3             ; Unused code, patched code ??
7775+  6DD3             
7776+  6DD3 00          	nop
7777+  6DD4 00          	nop
7778+  6DD5 00          	nop
7779+  6DD6 00          	nop
7780+  6DD7             
7781+  6DD7             ;	Subroutine	CVI function (H.CVI)
7782+  6DD7             ;	Inputs		
7783+  6DD7             ;	Outputs		________________________
7784+  6DD7             
7785+  6DD7 3E 01       A6DD7:	ld	a,2-1
7786+  6DD9 01          	defb	001H
7787+  6DDA             
7788+  6DDA             ;	Subroutine	CVS function (H.CVS)
7789+  6DDA             ;	Inputs		
7790+  6DDA             ;	Outputs		________________________
7791+  6DDA             
7792+  6DDA 3E 03       A6DDA:	ld	a,4-1
7793+  6DDC 01          	defb	001H
7794+  6DDD             
7795+  6DDD             ;	Subroutine	CVD function (H.CVD)
7796+  6DDD             ;	Inputs		
7797+  6DDD             ;	Outputs		________________________
7798+  6DDD             
7799+  6DDD 3E 07       A6DDD:	ld	a,8-1
7800+  6DDF CD 80 73    	call	A7380			; take control from caller
7801+  6DE2 F5          	push	af
7802+  6DE3 DD 21 D0 67 	ld	ix,M67D0
7803+  6DE7 CD 1E 73    	call	A731E			; free temporary string
7804+  6DEA F1          	pop	af
7805+  6DEB BE          	cp	(hl)
7806+  6DEC D2 15 73    	jp	nc,A7315
7807+  6DEF 3C          	inc	a
7808+  6DF0 23          	inc	hl
7809+  6DF1 4E          	ld	c,(hl)
7810+  6DF2 23          	inc	hl
7811+  6DF3 66          	ld	h,(hl)
7812+  6DF4 69          	ld	l,c
7813+  6DF5 32 63 F6    	ld	(VALTYP),a
7814+  6DF8 C3 08 2F    	jp	M2F08			; copy variable content to DAC
7815+  6DFB             
7816+  6DFB DD 21 97 55 A6DFB:	ld	ix,M5597
7817+  6DFF CD 1E 73    	call	A731E			; GETYPR
7818+  6E02 ED 4B F8 F7 	ld	bc,(DAC+2)
7819+  6E06 21 00 00    	ld	hl,0
7820+  6E09 F8          	ret	m
7821+  6E0A CA FA 72    	jp	z,A72FA
7822+  6E0D 21 F6 F7    	ld	hl,DAC
7823+  6E10 11 FC F5    	ld	de,BUF+158
7824+  6E13 01 08 00    	ld	bc,8
7825+  6E16 ED B0       	ldir
7826+  6E18 21 68 6E    	ld	hl,T6E68
7827+  6E1B 11 47 F8    	ld	de,ARG
7828+  6E1E 0E 08       	ld	c,8
7829+  6E20 ED B0       	ldir
7830+  6E22 CD 9F 28    	call	M289F			; dbl divide
7831+  6E25 A7          	and	a
7832+  6E26 CD D1 30    	call	M30D1			; dbl to integer
7833+  6E29 DD 21 32 54 	ld	ix,M5432
7834+  6E2D CD 1E 73    	call	A731E			; convert address to integer
7835+  6E30 D5          	push	de
7836+  6E31 EB          	ex	de,hl
7837+  6E32 DD 21 FF 46 	ld	ix,M46FF
7838+  6E36 CD 1E 73    	call	A731E			; convert integer to sgn in DAC
7839+  6E39 CD 42 30    	call	M3042			; convert DAC from sgn to dbl
7840+  6E3C 01 45 65    	ld	bc,06545H
7841+  6E3F 11 53 60    	ld	de,06053H
7842+  6E42 CD 5C 32    	call	M325C			; sgn multiply
7843+  6E45 21 F6 F7    	ld	hl,DAC
7844+  6E48 11 47 F8    	ld	de,ARG
7845+  6E4B 01 08 00    	ld	bc,8
7846+  6E4E ED B0       	ldir
7847+  6E50 21 FC F5    	ld	hl,BUF+158
7848+  6E53 11 F6 F7    	ld	de,DAC
7849+  6E56 0E 08       	ld	c,8
7850+  6E58 ED B0       	ldir
7851+  6E5A CD 8C 26    	call	M268C			; dbl subtract
7852+  6E5D DD 21 32 54 	ld	ix,M5432
7853+  6E61 CD 1E 73    	call	A731E			; convert address to integer
7854+  6E64 4B          	ld	c,e
7855+  6E65 42          	ld	b,d
7856+  6E66 E1          	pop	hl
7857+  6E67 C9          	ret
7858+  6E68             
7859+  6E68             T6E68:	defb	045H,065H,053H,060H,000H,000H,000H,000H
7859+  6E68 4565536000000000
7860+  6E70             
7861+  6E70             ;	Subroutine	 (H.EOF)
7862+  6E70             ;	Inputs		
7863+  6E70             ;	Outputs		________________________
7864+  6E70             
7865+  6E70 CD 80 73    A6E70:	call	A7380			; take control from caller
7866+  6E73 E5          	push	hl
7867+  6E74 CD 2A 68    	call	A682A			; get char from I/O channel
7868+  6E77 21 00 00    	ld	hl,0
7869+  6E7A 30 01       	jr	nc,A6E7D
7870+  6E7C 2B          	dec	hl
7871+  6E7D F5          A6E7D:	push	af
7872+  6E7E CD 99 2F    	call	M2F99			; integer to DAC
7873+  6E81 F1          	pop	af
7874+  6E82 E1          	pop	hl
7875+  6E83 23          	inc	hl
7876+  6E84 23          	inc	hl
7877+  6E85 23          	inc	hl
7878+  6E86 77          	ld	(hl),a
7879+  6E87 C9          	ret
7880+  6E88             
7881+  6E88             ;	Subroutine	FILES/LFILES statement (H.FILE)
7882+  6E88             ;	Inputs		
7883+  6E88             ;	Outputs		________________________
7884+  6E88             
7885+  6E88 CD 80 73    A6E88:	call	A7380			; take control from caller
7886+  6E8B 16 00       	ld	d,000H
7887+  6E8D 28 06       	jr	z,A6E95
7888+  6E8F CD 80 6F    	call	A6F80
7889+  6E92 E5          	push	hl
7890+  6E93 18 04       	jr	A6E99
7891+  6E95             
7892+  6E95 E5          A6E95:	push	hl
7893+  6E96 CD FE 6F    	call	A6FFE
7894+  6E99 CD 63 6F    A6E99:	call	A6F63
7895+  6E9C 3A 16 F4    	ld	a,(PRTFLG)
7896+  6E9F A7          	and	a			; output to printer ?
7897+  6EA0 F5          	push	af
7898+  6EA1 CD 45 66    	call	A6645
7899+  6EA4 CA 12 73    	jp	z,A7312
7900+  6EA7 DD 21 23 73 	ld	ix,M7323
7901+  6EAB CD 1E 73    	call	A731E			; newline to OUTDO if not at start of line
7902+  6EAE 21 B3 F5    A6EAE:	ld	hl,BUF+85
7903+  6EB1 06 0B       	ld	b,11
7904+  6EB3 7E          A6EB3:	ld	a,(hl)
7905+  6EB4 23          	inc	hl
7906+  6EB5 DF          	rst	018H
7907+  6EB6 78          	ld	a,b
7908+  6EB7 FE 04       	cp	004H
7909+  6EB9 20 08       	jr	nz,A6EC3
7910+  6EBB 7E          	ld	a,(hl)
7911+  6EBC FE 20       	cp	" "
7912+  6EBE 28 02       	jr	z,A6EC2
7913+  6EC0 3E 2E       	ld	a,"."
7914+  6EC2 DF          A6EC2:	rst	018H
7915+  6EC3 10 EE       A6EC3:	djnz	A6EB3
7916+  6EC5 CD BD 00    	call	CKCNTC
7917+  6EC8 F1          	pop	af			; output to printer ?
7918+  6EC9 F5          	push	af
7919+  6ECA 3A B0 F3    	ld	a,(LINLEN)
7920+  6ECD 47          	ld	b,a			; screenwidth
7921+  6ECE 3A 61 F6    	ld	a,(TTYPOS)		; screenpos
7922+  6ED1 28 05       	jr	z,A6ED8			; nope, use screen
7923+  6ED3 06 50       	ld	b,80			; printerwidth
7924+  6ED5 3A 15 F4    	ld	a,(LPTPOS)		; printerpos
7925+  6ED8 A7          A6ED8:	and	a			; at start of line ?
7926+  6ED9 28 0F       	jr	z,A6EEA			; yep, no newline
7927+  6EDB C6 0C       	add	a,00CH
7928+  6EDD B8          	cp	b
7929+  6EDE 30 03       	jr	nc,A6EE3
7930+  6EE0 3E 20       	ld	a," "
7931+  6EE2 DF          	rst	018H
7932+  6EE3 DD 21 28 73 A6EE3:	ld	ix,M7328
7933+  6EE7 D4 1E 73    	call	nc,A731E		; yep, newline to OUTDO
7934+  6EEA 11 68 F5    A6EEA:	ld	de,BUF+10
7935+  6EED AF          	xor	a
7936+  6EEE 32 74 F5    	ld	(BUF+22),a
7937+  6EF1 CD 06 50    	call	A5006			; search for next
7938+  6EF4 3C          	inc	a
7939+  6EF5 20 B7       	jr	nz,A6EAE
7940+  6EF7 F1          	pop	af
7941+  6EF8 E1          A6EF8:	pop	hl
7942+  6EF9 DD 21 FF 4A 	ld	ix,M4AFF
7943+  6EFD C3 1E 73    	jp	A731E			; output back to screen and quit
7944+  6F00             
7945+  6F00             ;	Subroutine	KILL statement (H.KILL)
7946+  6F00             ;	Inputs		
7947+  6F00             ;	Outputs		________________________
7948+  6F00             
7949+  6F00 CD 80 73    A6F00:	call	A7380			; take control from caller
7950+  6F03 CD 96 6F    	call	A6F96
7951+  6F06 CD DA 72    	call	A72DA			; at end of statement ?
7952+  6F09 C0          	ret	nz			; nope, quit
7953+  6F0A CD EA 65    	call	A65EA			; is file already open in one of the I/O channels ?
7954+  6F0D CA A2 71    	jp	z,A71A2
7955+  6F10 CD 63 6F    	call	A6F63
7956+  6F13 E5          	push	hl
7957+  6F14 11 68 F5    	ld	de,BUF+10
7958+  6F17 CD 6C 43    	call	A436C			; delete file
7959+  6F1A A7          	and	a
7960+  6F1B C2 12 73    	jp	nz,A7312
7961+  6F1E E1          	pop	hl
7962+  6F1F C9          	ret
7963+  6F20             
7964+  6F20             ;	Subroutine	NAME statement (H.NAME)
7965+  6F20             ;	Inputs		
7966+  6F20             ;	Outputs		________________________
7967+  6F20             
7968+  6F20 CD 80 73    A6F20:	call	A7380			; take control from caller
7969+  6F23 CD 96 6F    	call	A6F96
7970+  6F26 CD EA 65    	call	A65EA			; is file already open in one of the I/O channels ?
7971+  6F29 CA A2 71    	jp	z,A71A2
7972+  6F2C CD 63 6F    	call	A6F63
7973+  6F2F E5          	push	hl
7974+  6F30 CD 45 66    	call	A6645
7975+  6F33 CA 12 73    	jp	z,A7312
7976+  6F36 E1          	pop	hl
7977+  6F37 CD D0 72    	call	A72D0
7978+  6F3A 41          	defb	"A"
7979+  6F3B CD D0 72    	call	A72D0
7980+  6F3E 53          	defb	"S"			; check for "AS"
7981+  6F3F CD 96 6F    	call	A6F96
7982+  6F42 7A          	ld	a,d
7983+  6F43 32 78 F5    	ld	(BUF+26),a
7984+  6F46 E5          	push	hl
7985+  6F47 2A 68 F5    	ld	hl,(BUF+10)
7986+  6F4A A7          	and	a
7987+  6F4B 28 04       	jr	z,A6F51
7988+  6F4D BD          	cp	l
7989+  6F4E C2 B7 71    	jp	nz,A71B7
7990+  6F51 11 79 F5    A6F51:	ld	de,BUF+27
7991+  6F54 CD 5A 66    	call	A665A
7992+  6F57 11 68 F5    	ld	de,BUF+10
7993+  6F5A CD 92 43    	call	A4392			; rename file
7994+  6F5D A7          	and	a
7995+  6F5E C2 A5 71    	jp	nz,A71A5
7996+  6F61 E1          	pop	hl
7997+  6F62 C9          	ret
7998+  6F63             
7999+  6F63 CD E3 65    A6F63:	call	A65E3
8000+  6F66 3C          	inc	a
8001+  6F67 32 68 F5    	ld	(BUF+10),a
8002+  6F6A E5          	push	hl
8003+  6F6B D5          	push	de
8004+  6F6C CD 57 66    	call	A6657
8005+  6F6F D1          	pop	de
8006+  6F70 E1          	pop	hl
8007+  6F71 C9          	ret
8008+  6F72             
8009+  6F72 DD 21 0E 6A A6F72:	ld	ix,M6A0E
8010+  6F76 CD 1E 73    	call	A731E			; evaluate filespecification
8011+  6F79 7A          	ld	a,d
8012+  6F7A FE 09       	cp	009H
8013+  6F7C D8          	ret	c
8014+  6F7D C3 9C 71    	jp	A719C
8015+  6F80 CD 72 6F    A6F80:	call	A6F72
8016+  6F83 E5          	push	hl
8017+  6F84 21 66 F8    	ld	hl,FILNAM
8018+  6F87 06 0B       	ld	b,00BH
8019+  6F89 7E          A6F89:	ld	a,(hl)
8020+  6F8A 23          	inc	hl
8021+  6F8B FE 20       	cp	" "
8022+  6F8D 20 0B       	jr	nz,A6F9A
8023+  6F8F 10 F8       	djnz	A6F89
8024+  6F91 CD FE 6F    	call	A6FFE
8025+  6F94 18 04       	jr	A6F9A
8026+  6F96             
8027+  6F96 CD 72 6F    A6F96:	call	A6F72
8028+  6F99 E5          	push	hl
8029+  6F9A 21 66 F8    A6F9A:	ld	hl,FILNAM
8030+  6F9D 06 08       	ld	b,008H
8031+  6F9F CD F5 6F    	call	A6FF5
8032+  6FA2 06 03       	ld	b,003H
8033+  6FA4 CD F5 6F    	call	A6FF5
8034+  6FA7 E1          	pop	hl
8035+  6FA8 F6          	defb	0F6H
8036+  6FA9 37          A6FA9:	scf
8037+  6FAA D5          	push	de
8038+  6FAB E5          	push	hl
8039+  6FAC 11 66 F8    	ld	de,FILNAM
8040+  6FAF D5          	push	de
8041+  6FB0 06 0B       	ld	b,11
8042+  6FB2 C5          A6FB2:	push	bc
8043+  6FB3 1A          	ld	a,(de)
8044+  6FB4 21 CC 6F    	ld	hl,T6FCC
8045+  6FB7 01 0D 00    	ld	bc,0000DH
8046+  6FBA 38 01       	jr	c,A6FBD
8047+  6FBC 0B          	dec	bc
8048+  6FBD ED B1       A6FBD:	cpir
8049+  6FBF 28 31       	jr	z,A6FF2
8050+  6FC1 C1          	pop	bc
8051+  6FC2 13          	inc	de
8052+  6FC3 10 ED       	djnz	A6FB2
8053+  6FC5 E1          	pop	hl
8054+  6FC6 CD D9 6F    	call	A6FD9
8055+  6FC9 E1          	pop	hl
8056+  6FCA D1          	pop	de
8057+  6FCB C9          	ret
8058+  6FCC             
8059+  6FCC             T6FCC:	defb	".",34,"/\\[]:+=;,*?"
8059+  6FCC 2E222F5C5B5D3A2B3D3B2C2A3F
8060+  6FD9             
8061+  6FD9 3E 20       A6FD9:	ld	a," "
8062+  6FDB BE          	cp	(hl)
8063+  6FDC 28 14       	jr	z,A6FF2
8064+  6FDE 06 07       	ld	b,007H
8065+  6FE0 CD E5 6F    	call	A6FE5
8066+  6FE3 06 03       	ld	b,003H
8067+  6FE5 23          A6FE5:	inc	hl
8068+  6FE6 BE          	cp	(hl)
8069+  6FE7 28 03       	jr	z,A6FEC
8070+  6FE9 10 FA       	djnz	A6FE5
8071+  6FEB C9          	ret
8072+  6FEC             
8073+  6FEC 05          A6FEC:	dec	b
8074+  6FED C8          	ret	z
8075+  6FEE 23          	inc	hl
8076+  6FEF BE          	cp	(hl)
8077+  6FF0 28 FA       	jr	z,A6FEC
8078+  6FF2 C3 0F 73    A6FF2:	jp	A730F
8079+  6FF5             
8080+  6FF5 7E          A6FF5:	ld	a,(hl)
8081+  6FF6 FE 2A       	cp	"*"
8082+  6FF8 28 09       	jr	z,A7003
8083+  6FFA 23          	inc	hl
8084+  6FFB 10 F8       	djnz	A6FF5
8085+  6FFD C9          	ret
8086+  6FFE             
8087+  6FFE 21 66 F8    A6FFE:	ld	hl,FILNAM
8088+  7001 06 0B       	ld	b,00BH
8089+  7003 36 3F       A7003:	ld	(hl),"?"
8090+  7005 23          	inc	hl
8091+  7006 10 FB       	djnz	A7003
8092+  7008 C9          	ret
8093+  7009             
8094+  7009             ;	Subroutine	 (H.LOF)
8095+  7009             ;	Inputs		
8096+  7009             ;	Outputs		________________________
8097+  7009             
8098+  7009 01 10 00    A7009:	ld	bc,00010H
8099+  700C 11          	defb	011H
8100+  700D             
8101+  700D             ;	Subroutine	 (H.LOC)
8102+  700D             ;	Inputs		
8103+  700D             ;	Outputs		________________________
8104+  700D             
8105+  700D 01 21 00    A700D:	ld	bc,00021H
8106+  7010 CD 80 73    	call	A7380			; take control from caller
8107+  7013 C5          	push	bc
8108+  7014 DD 21 1F 52 	ld	ix,M521F
8109+  7018 CD 1E 73    	call	A731E			; convert to byte
8110+  701B DD 21 6D 6A 	ld	ix,M6A6D
8111+  701F CD 1E 73    	call	A731E			; get i/o channel pointer
8112+  7022 DA 15 73    	jp	c,A7315
8113+  7025 CA 00 73    	jp	z,A7300
8114+  7028 C1          	pop	bc
8115+  7029 23          	inc	hl
8116+  702A 5E          	ld	e,(hl)
8117+  702B 23          	inc	hl
8118+  702C 56          	ld	d,(hl)
8119+  702D EB          	ex	de,hl
8120+  702E 09          	add	hl,bc
8121+  702F 4E          	ld	c,(hl)
8122+  7030 23          	inc	hl
8123+  7031 46          	ld	b,(hl)
8124+  7032 23          	inc	hl
8125+  7033 5E          	ld	e,(hl)
8126+  7034 23          	inc	hl
8127+  7035 56          	ld	d,(hl)
8128+  7036 EB          	ex	de,hl
8129+  7037 C5          	push	bc
8130+  7038 DD 21 FF 46 	ld	ix,M46FF
8131+  703C CD 1E 73    	call	A731E			; convert integer to sgn in DAC
8132+  703F 01 45 65    	ld	bc,06545H
8133+  7042 11 53 60    	ld	de,06053H
8134+  7045 CD 5C 32    	call	M325C			; sgn multiply
8135+  7048 21 F6 F7    	ld	hl,DAC
8136+  704B 11 47 F8    	ld	de,ARG
8137+  704E 01 08 00    	ld	bc,8
8138+  7051 ED B0       	ldir
8139+  7053 E1          	pop	hl
8140+  7054 DD 21 FF 46 	ld	ix,M46FF
8141+  7058 CD 1E 73    	call	A731E			; convert integer to sgn in DAC
8142+  705B CD 42 30    	call	M3042			; convert DAC from sgn to dbl
8143+  705E C3 9A 26    	jp	M269A			; dbl add
8144+  7061             
8145+  7061             ;	Subroutine	DSKF function (H.DSKF)
8146+  7061             ;	Inputs		
8147+  7061             ;	Outputs		________________________
8148+  7061             
8149+  7061 CD 80 73    A7061:	call	A7380			; take control from caller
8150+  7064 DD 21 1F 52 	ld	ix,M521F
8151+  7068 CD 1E 73    	call	A731E			; convert to byte
8152+  706B 21 47 F3    	ld	hl,YF347
8153+  706E BE          	cp	(hl)
8154+  706F 28 03       	jr	z,A7074
8155+  7071 D2 9C 71    	jp	nc,A719C
8156+  7074 5F          A7074:	ld	e,a
8157+  7075 CD 5D 50    	call	A505D
8158+  7078 C3 99 2F    	jp	M2F99			; integer to DAC
8159+  707B             
8160+  707B             ;	Subroutine	COPY statement (H.COPY)
8161+  707B             ;	Inputs		
8162+  707B             ;	Outputs		________________________
8163+  707B             
8164+  707B CD 80 73    A707B:	call	A7380			; take control from caller
8165+  707E CD 80 6F    	call	A6F80
8166+  7081 CD EA 65    	call	A65EA			; is file already open in one of the I/O channels ?
8167+  7084 CA A2 71    	jp	z,A71A2
8168+  7087 CD 63 6F    	call	A6F63
8169+  708A E5          	push	hl
8170+  708B 3A 47 F2    	ld	a,(YF247)
8171+  708E 3C          	inc	a
8172+  708F 32 8D F5    	ld	(BUF+47),a
8173+  7092 21 69 F5    	ld	hl,BUF+11
8174+  7095 11 8E F5    	ld	de,BUF+48
8175+  7098 01 24 00    	ld	bc,00024H
8176+  709B ED B0       	ldir
8177+  709D E1          	pop	hl
8178+  709E CD DA 72    	call	A72DA			; at end of statement ?
8179+  70A1 28 20       	jr	z,A70C3			; yep,
8180+  70A3 CD D0 72    	call	A72D0
8181+  70A6 D9          	defb	0D9H			; check for TO token
8182+  70A7 CD 80 6F    	call	A6F80
8183+  70AA CD EA 65    	call	A65EA			; is file already open in one of the I/O channels ?
8184+  70AD CA A2 71    	jp	z,A71A2
8185+  70B0 CD E3 65    	call	A65E3
8186+  70B3 3C          	inc	a
8187+  70B4 32 8D F5    	ld	(BUF+47),a
8188+  70B7 E5          	push	hl
8189+  70B8 11 8E F5    	ld	de,BUF+48
8190+  70BB CD 5A 66    	call	A665A
8191+  70BE E1          	pop	hl
8192+  70BF CD DA 72    	call	A72DA			; at end of statement ?
8193+  70C2 C0          	ret	nz			; nope, quit
8194+  70C3 E5          A70C3:	push	hl
8195+  70C4 CD 45 66    	call	A6645
8196+  70C7 CA 12 73    	jp	z,A7312
8197+  70CA CD BD 00    A70CA:	call	CKCNTC
8198+  70CD 01 8D F5    	ld	bc,BUF+47
8199+  70D0 11 D7 F5    	ld	de,BUF+121
8200+  70D3 21 B2 F5    	ld	hl,BUF+84
8201+  70D6 3E 0C       	ld	a,00CH
8202+  70D8 F5          A70D8:	push	af
8203+  70D9 0A          	ld	a,(bc)
8204+  70DA FE 3F       	cp	"?"
8205+  70DC 20 01       	jr	nz,A70DF
8206+  70DE 7E          	ld	a,(hl)
8207+  70DF 12          A70DF:	ld	(de),a
8208+  70E0 03          	inc	bc
8209+  70E1 13          	inc	de
8210+  70E2 23          	inc	hl
8211+  70E3 F1          	pop	af
8212+  70E4 3D          	dec	a
8213+  70E5 20 F1       	jr	nz,A70D8
8214+  70E7 21 B2 F5    	ld	hl,BUF+84
8215+  70EA 11 D7 F5    	ld	de,BUF+121
8216+  70ED 06 0C       	ld	b,00CH
8217+  70EF 1A          A70EF:	ld	a,(de)
8218+  70F0 BE          	cp	(hl)
8219+  70F1 20 07       	jr	nz,A70FA
8220+  70F3 23          	inc	hl
8221+  70F4 13          	inc	de
8222+  70F5 10 F8       	djnz	A70EF
8223+  70F7 C3 15 73    	jp	A7315
8224+  70FA             
8225+  70FA CD 6C 71    A70FA:	call	A716C
8226+  70FD E5          	push	hl
8227+  70FE AF          	xor	a
8228+  70FF 32 BE F5    	ld	(BUF+96),a
8229+  7102 11 B2 F5    	ld	de,BUF+84
8230+  7105 CD 62 44    	call	A4462			; open fcb
8231+  7108 11 D7 F5    	ld	de,BUF+121
8232+  710B CD 1D 46    	call	A461D			; create file
8233+  710E A7          	and	a
8234+  710F C2 AB 71    	jp	nz,A71AB
8235+  7112 6F          	ld	l,a
8236+  7113 67          	ld	h,a
8237+  7114 22 D3 F5    	ld	(BUF+117),hl
8238+  7117 22 D5 F5    	ld	(BUF+119),hl
8239+  711A 22 F8 F5    	ld	(BUF+154),hl
8240+  711D 22 FA F5    	ld	(BUF+156),hl
8241+  7120 23          	inc	hl
8242+  7121 22 C0 F5    	ld	(BUF+98),hl
8243+  7124 22 E5 F5    	ld	(BUF+135),hl
8244+  7127 E1          	pop	hl
8245+  7128 E5          A7128:	push	hl
8246+  7129 11 B2 F5    	ld	de,BUF+84
8247+  712C CD B2 47    	call	A47B2			; random block read
8248+  712F 7D          	ld	a,l
8249+  7130 B4          	or	h
8250+  7131 28 09       	jr	z,A713C
8251+  7133 11 D7 F5    	ld	de,BUF+121
8252+  7136 CD 8F 71    	call	A718F			; random block write
8253+  7139 E1          	pop	hl
8254+  713A 18 EC       	jr	A7128
8255+  713C             
8256+  713C E1          A713C:	pop	hl
8257+  713D 2A C6 F5    	ld	hl,(BUF+104)
8258+  7140 22 EB F5    	ld	(BUF+141),hl
8259+  7143 2A C8 F5    	ld	hl,(BUF+106)
8260+  7146 22 ED F5    	ld	(BUF+143),hl
8261+  7149 11 D7 F5    	ld	de,BUF+121
8262+  714C CD 6F 45    	call	A456F			; close fcb
8263+  714F 21 B2 F5    	ld	hl,BUF+84
8264+  7152 22 3D F2    	ld	(YF23D),hl		; transferaddress
8265+  7155 11 68 F5    	ld	de,BUF+10
8266+  7158 AF          	xor	a
8267+  7159 32 74 F5    	ld	(BUF+22),a
8268+  715C CD 06 50    	call	A5006			; search for next
8269+  715F 3C          	inc	a
8270+  7160 C2 CA 70    	jp	nz,A70CA
8271+  7163 E1          	pop	hl
8272+  7164 C9          	ret
8273+  7165             
8274+  7165 22 BF FC    A7165:	ld	(SAVENT),hl
8275+  7168 ED 43 7D F8 	ld	(SAVEND),bc
8276+  716C 21 00 FE    A716C:	ld	hl,0FE00H
8277+  716F 39          	add	hl,sp
8278+  7170 30 0D       	jr	nc,A717F
8279+  7172 ED 5B C6 F6 	ld	de,(STREND)
8280+  7176 A7          	and	a
8281+  7177 ED 52       	sbc	hl,de
8282+  7179 38 04       	jr	c,A717F
8283+  717B 7C          	ld	a,h
8284+  717C A7          	and	a
8285+  717D 20 07       	jr	nz,A7186
8286+  717F ED 5B 62 F8 A717F:	ld	de,(NULBUF)
8287+  7183 21 00 01    	ld	hl,256
8288+  7186 ED 53 3D F2 A7186:	ld	(YF23D),de		; transferaddress
8289+  718A C9          	ret
8290+  718B             
8291+  718B ED 5B 53 F3 A718B:	ld	de,(YF353)
8292+  718F CD BE 47    A718F:	call	A47BE			; random block write
8293+  7192 A7          	and	a
8294+  7193 C8          	ret	z
8295+  7194 18 12       	jr	A71A8
8296+  7196             
8297+  7196 1E 3C       A7196:	ld	e,03CH
8298+  7198 01          	defb	001H
8299+  7199 1E 3D       A7199:	ld	e,03DH
8300+  719B 01          	defb	001H
8301+  719C 1E 3E       A719C:	ld	e,03EH
8302+  719E 01          	defb	001H
8303+  719F 1E 3F       	ld	e,03FH
8304+  71A1 01          	defb	001H
8305+  71A2 1E 40       A71A2:	ld	e,040H
8306+  71A4 01          	defb	001H
8307+  71A5 1E 41       A71A5:	ld	e,041H
8308+  71A7 01          	defb	001H
8309+  71A8 1E 42       A71A8:	ld	e,042H
8310+  71AA 01          	defb	001H
8311+  71AB 1E 43       A71AB:	ld	e,043H
8312+  71AD 01          	defb	001H
8313+  71AE 1E 44       A71AE:	ld	e,044H
8314+  71B0 01          	defb	001H
8315+  71B1 1E 45       A71B1:	ld	e,045H
8316+  71B3 01          	defb	001H
8317+  71B4 1E 46       A71B4:	ld	e,046H
8318+  71B6 01          	defb	001H
8319+  71B7 1E 47       A71B7:	ld	e,047H
8320+  71B9 01 00 00    	ld	bc,00000H
8321+  71BC AF          	xor	a
8322+  71BD 32 7C F8    	ld	(NLONLY),a		; not loading basic program, close i/o channels when requested
8323+  71C0 32 AE FC    	ld	(FLBMEM),a		; ascii mode
8324+  71C3 D5          	push	de
8325+  71C4 DD 21 24 6B 	ld	ix,M6B24
8326+  71C8 CD 1E 73    	call	A731E			; close i/o channel
8327+  71CB D1          	pop	de
8328+  71CC DD 21 6F 40 	ld	ix,M406F		; BASIC error
8329+  71D0 C3 1E 73    	jp	A731E
8330+  71D3             
8331+  71D3             ;	Subroutine	expand errormessages (H.ERRP)
8332+  71D3             ;	Inputs		
8333+  71D3             ;	Outputs		________________________
8334+  71D3             
8335+  71D3 7B          A71D3:	ld	a,e
8336+  71D4 FE 3C       	cp	03CH			; normal BASIC error ?
8337+  71D6 D8          	ret	c			; yep, quit
8338+  71D7 FE 48       	cp	048H			; DiskBASIC error ?
8339+  71D9 D0          	ret	nc			; nope, quit
8340+  71DA D6 3B       	sub	03BH
8341+  71DC 47          	ld	b,a			; 1 based offset
8342+  71DD 21 F5 71    	ld	hl,T71F5
8343+  71E0 7E          A71E0:	ld	a,(hl)
8344+  71E1 A7          	and	a
8345+  71E2 23          	inc	hl
8346+  71E3 20 FB       	jr	nz,A71E0
8347+  71E5 10 F9       	djnz	A71E0			; next errormessage
8348+  71E7 2B          	dec	hl			; include trailing zero
8349+  71E8 11 04 F6    	ld	de,BUF+166
8350+  71EB D5          	push	de
8351+  71EC 01 16 00    	ld	bc,22
8352+  71EF ED B0       	ldir				; copy errormessage to temporary place
8353+  71F1 1E 01       	ld	e,1			; erroroffset 1
8354+  71F3 E1          	pop	hl
8355+  71F4 C9          	ret
8356+  71F5             
8357+  71F5 00          T71F5:	defb	0
8358+  71F6             	defb	"Bad FAT",0
8358+  71F6 4261642046415400
8359+  71FE             	defb	"Bad file mode",0
8359+  71FE 4261642066696C65206D6F646500
8360+  720C             	defb	"Bad drive name",0
8360+  720C 426164206472697665206E616D6500
8361+  721B             	defb	"Bad sector number",0
8361+  721B 42616420736563746F72206E756D62657200
8362+  722D             	defb	"File still open",0
8362+  722D 46696C65207374696C6C206F70656E00
8363+  723D             	defb	"File already exists",0
8363+  723D 46696C6520616C72656164792065786973747300
8364+  7251             	defb	"Disk full",0
8364+  7251 4469736B2066756C6C00
8365+  725B             	defb	"Too many files",0
8365+  725B 546F6F206D616E792066696C657300
8366+  726A             	defb	"Disk write protected",0
8366+  726A 4469736B2077726974652070726F74656374656400
8367+  727F             	defb	"Disk I/O error",0
8367+  727F 4469736B20492F4F206572726F7200
8368+  728E             	defb	"Disk offline",0
8368+  728E 4469736B206F66666C696E6500
8369+  729B             	defb	"Rename across disk",0
8369+  729B 52656E616D65206163726F7373206469736B00
8370+  72AE             
8371+  72AE             
8372+  72AE B0 72       T72AE:	defw	A72B0			; pointer to the default diskerror handler for DiskBASIC
8373+  72B0             
8374+  72B0             ;	Subroutine	diskerror handler for DiskBASIC
8375+  72B0             ;	Inputs		________________________
8376+  72B0             ;	Outputs		________________________
8377+  72B0             
8378+  72B0 CB 79       A72B0:	bit	7,c			; FAT error ?
8379+  72B2 C2 96 71    	jp	nz,A7196		; yep, bad fat error
8380+  72B5 CB 81       	res	0,c
8381+  72B7 06 00       	ld	b,0
8382+  72B9 21 C2 72    	ld	hl,T72C2
8383+  72BC 09          	add	hl,bc
8384+  72BD 7E          A72BD:	ld	a,(hl)
8385+  72BE 23          	inc	hl
8386+  72BF 66          	ld	h,(hl)
8387+  72C0 6F          	ld	l,a
8388+  72C1 E9          	jp	(hl)
8389+  72C2             
8390+  72C2 AE 71       T72C2:	defw	A71AE			; Write Protect error, disk write protect error
8391+  72C4 B4 71       	defw	A71B4			; Not Ready error, disk offline error
8392+  72C6 B1 71       	defw	A71B1			; Data/CRC error, disk i/o error
8393+  72C8 B1 71       	defw	A71B1			; Seek error, disk i/o error
8394+  72CA B1 71       	defw	A71B1			; Record not found error, disk i/o error
8395+  72CC B1 71       	defw	A71B1			; Write fault error, disk i/o error
8396+  72CE B1 71       	defw	A71B1			; Other error, disk i/o error
8397+  72D0             
8398+  72D0             ;	Subroutine	check for BASIC character
8399+  72D0             ;	Inputs		HL = BASIC pointer
8400+  72D0             ;	Outputs		________________________
8401+  72D0             
8402+  72D0 CD DA 72    A72D0:	call	A72DA
8403+  72D3 E3          	ex	(sp),hl
8404+  72D4 BE          	cp	(hl)
8405+  72D5 20 41       	jr	nz,A7318
8406+  72D7 23          	inc	hl
8407+  72D8 E3          	ex	(sp),hl
8408+  72D9 23          	inc	hl
8409+  72DA 2B          A72DA:	dec	hl
8410+  72DB DD 21 66 46 A72DB:	ld	ix,M4666
8411+  72DF 18 3D       	jr	A731E			; continue in CHRGTR
8412+  72E1             
8413+  72E1             ; unused code, patched ??
8414+  72E1             
8415+  72E1 00          	nop
8416+  72E2 00          	nop
8417+  72E3 00          	nop
8418+  72E4             
8419+  72E4 3E C9       A72E4:	ld	a,0C9H
8420+  72E6 32 D5 FE    A72E6:	ld	(H.LOPD+0),a
8421+  72E9 ED 5B 4A FC 	ld	de,(HIMEM)
8422+  72ED ED 53 49 F3 	ld	(YF349),de
8423+  72F1 C9          	ret
8424+  72F2             
8425+  72F2 F7          T72F2:	rst	030H
8426+  72F3 00          	defb	000H
8427+  72F4 E4 72       	defw	A72E4
8428+  72F6 C9          	ret
8429+  72F7             
8430+  72F7 1E 10       A72F7:	ld	e,010H
8431+  72F9 01          	defb	001H
8432+  72FA             
8433+  72FA 1E 0D       A72FA:	ld	e,00DH
8434+  72FC 01          	defb	001H
8435+  72FD             
8436+  72FD 1E 07       A72FD:	ld	e,007H
8437+  72FF 01          	defb	001H
8438+  7300             
8439+  7300 1E 3B       A7300:	ld	e,03BH
8440+  7302 01          	defb	001H
8441+  7303             
8442+  7303 1E 37       A7303:	ld	e,037H
8443+  7305 01          	defb	001H
8444+  7306             
8445+  7306 1E 32       A7306:	ld	e,032H
8446+  7308 01          	defb	001H
8447+  7309             
8448+  7309 1E 36       A7309:	ld	e,036H
8449+  730B 01          	defb	001H
8450+  730C             
8451+  730C 1E 34       A730C:	ld	e,034H
8452+  730E 01          	defb	001H
8453+  730F             
8454+  730F 1E 38       A730F:	ld	e,038H
8455+  7311 01          	defb	001H
8456+  7312             
8457+  7312 1E 35       A7312:	ld	e,035H
8458+  7314 01          	defb	001H
8459+  7315             
8460+  7315 1E 05       A7315:	ld	e,005H
8461+  7317 01          	defb	001H
8462+  7318             
8463+  7318 1E 02       A7318:	ld	e,002H
8464+  731A DD 21 6F 40 	ld	ix,M406F		; BASIC error
8465+  731E CD 59 01    A731E:	call	CALBAS
8466+  7321 FB          	ei
8467+  7322 C9          	ret
8468+  7323             
8469+  7323             ;	Subroutine	devicename parser (H.PARD)
8470+  7323             ;	Inputs		
8471+  7323             ;	Outputs		________________________
8472+  7323             
8473+  7323 FB          A7323:	ei
8474+  7324 E5          	push	hl
8475+  7325 D5          	push	de
8476+  7326 3A 48 F3    	ld	a,(YF348)
8477+  7329 87          	add	a,a
8478+  732A 21 10 00    	ld	hl,16
8479+  732D 30 02       	jr	nc,A7331
8480+  732F 2E 18       	ld	l,16+8
8481+  7331 39          A7331:	add	hl,sp
8482+  7332 5E          	ld	e,(hl)
8483+  7333 23          	inc	hl
8484+  7334 56          	ld	d,(hl)
8485+  7335 E5          	push	hl
8486+  7336 21 95 6E    	ld	hl,M6E92+3
8487+  7339 E7          	rst	020H			; called from BSAVE ?
8488+  733A E1          	pop	hl
8489+  733B 28 0D       	jr	z,A734A			; yep, adjust returnaddress for DiskBASIC BSAVE
8490+  733D E5          	push	hl
8491+  733E 21 C9 6E    	ld	hl,M6EC6+3
8492+  7341 E7          	rst	020H			; called from BLOAD ?
8493+  7342 E1          	pop	hl
8494+  7343 20 0B       	jr	nz,A7350		; nope, do not adjust returnaddress
8495+  7345 11 77 F3    	ld	de,XF377
8496+  7348 18 03       	jr	A734D			; yep, adjust returnaddress for DiskBASIC BLOAD
8497+  734A             
8498+  734A 11 7A F3    A734A:	ld	de,XF37A
8499+  734D 72          A734D:	ld	(hl),d
8500+  734E 2B          	dec	hl
8501+  734F 73          	ld	(hl),e
8502+  7350 D1          A7350:	pop	de
8503+  7351 E1          	pop	hl
8504+  7352 7B          	ld	a,e
8505+  7353 FE 02       	cp	2			; filespecification length <2 ?
8506+  7355 D8          	ret	c			; yep, no device specified
8507+  7356 7E          	ld	a,(hl)
8508+  7357 FE 3A       	cp	":"			; first character a ":" ?
8509+  7359 28 B4       	jr	z,A730F			; yep,
8510+  735B 23          	inc	hl
8511+  735C 7E          	ld	a,(hl)
8512+  735D FE 3A       	cp	":"			; second character a ":" ?
8513+  735F 2B          	dec	hl
8514+  7360 C0          	ret	nz			; nope, no diskdevice specifier
8515+  7361 CD 80 73    	call	A7380			; take control from caller
8516+  7364 7E          	ld	a,(hl)
8517+  7365 E6 DF       	and	0DFH			; upcase
8518+  7367 D6 40       	sub	040H			; to drivenumber/deviceid for disk (1...) 
8519+  7369 E5          	push	hl
8520+  736A 21 47 F3    	ld	hl,YF347
8521+  736D BE          	cp	(hl)			; valid drive ?
8522+  736E E1          	pop	hl
8523+  736F 28 03       	jr	z,A7374
8524+  7371 D2 9C 71    	jp	nc,A719C		; nope,
8525+  7374 23          A7374:	inc	hl
8526+  7375 23          	inc	hl
8527+  7376 1D          	dec	e
8528+  7377 1D          	dec	e
8529+  7378 D5          	push	de
8530+  7379 1C          	inc	e			; flag Zx reset
8531+  737A D1          	pop	de
8532+  737B C9          	ret
8533+  737C             
8534+  737C             ;	Subroutine	no device specified (H.NODE)
8535+  737C             ;	Inputs		
8536+  737C             ;	Outputs		________________________
8537+  737C             
8538+  737C FB          A737C:	ei
8539+  737D 3E 00       	ld	a,0			; deviceid for default drive
8540+  737F C9          	ret
8541+  7380             
8542+  7380             ;	Subroutine	take control from caller
8543+  7380             ;	Inputs		
8544+  7380             ;	Outputs		________________________
8545+  7380             
8546+  7380             ;	This is what the stack looks like at entry:
8547+  7380             ;
8548+  7380             ;	prim	exp
8549+  7380             ;	+0	+0	returnaddress A7380 caller
8550+  7380             ;	+2	+2	callf BIOS registers
8551+  7380             ;	+6	+14	returnaddress CALLF caller
8552+  7380             ;	+8	+16	returnaddress hook caller
8553+  7380             
8554+  7380 FB          A7380:	ei
8555+  7381 E5          	push	hl
8556+  7382 F5          	push	af
8557+  7383 3A 48 F3    	ld	a,(YF348)
8558+  7386 87          	add	a,a
8559+  7387 21 0C 00    	ld	hl,12
8560+  738A 30 02       	jr	nc,A738E
8561+  738C 2E 14       	ld	l,12+8
8562+  738E 39          A738E:	add	hl,sp
8563+  738F 36 8B       	ld	(hl),LOW RETRTN
8564+  7391 23          	inc	hl
8565+  7392 36 F3       	ld	(hl),HIGH RETRTN
8566+  7394 F1          	pop	af
8567+  7395 E1          	pop	hl
8568+  7396 C9          	ret
8569+  7397             
8570+  7397             ;	Subroutine	BDOS 09 (output string)
8571+  7397             ;	Inputs		DE = address of string
8572+  7397             ;	Outputs		________________________
8573+  7397             ;	Remark		is copied to 0F1C9H
8574+  7397             
8575+  7397 CD 6B F3    A7397:	call	XF36B			; enable ram on page 1
8576+  739A 1A          	ld	a,(de)
8577+  739B CD 68 F3    	call	XF368			; enable system diskrom
8578+  739E 13          	inc	de
8579+  739F FE 24       	cp	'$'
8580+  73A1 C8          	ret	z			; end of string, quit
8581+  73A2 CD A8 53    	call	A53A8			; console output
8582+  73A5 18 F0       	jr	A7397			; next
8583+  73A7             
8584+  73A7             ;	Subroutine	XFER (transfer)
8585+  73A7             ;	Inputs		HL = source address, DE = destition address, BC = size
8586+  73A7             ;	Outputs		________________________
8587+  73A7             ;	Remark		is copied to 0F1D9H
8588+  73A7             
8589+  73A7 CD 6B F3    	call	XF36B			; enable ram on page 1
8590+  73AA ED B0       	ldir				; transfer
8591+  73AC CD 68 F3    	call	XF368			; enable system diskrom
8592+  73AF C9          	ret
8593+  73B0             
8594+  73B0             ;	Subroutine	Warm Boot
8595+  73B0             ;	Inputs		________________________
8596+  73B0             ;	Outputs		________________________
8597+  73B0             ;	Remark		is copied to 0F1E2H
8598+  73B0             
8599+  73B0 CD 6B F3    	call	XF36B			; enable ram on page 1
8600+  73B3 C3 00 00    	jp	0			; WBOOT
8601+  73B6             
8602+  73B6             ;	Subroutine	start handler in DOS memory
8603+  73B6             ;	Inputs		HL = address of pointer
8604+  73B6             ;	Outputs		________________________
8605+  73B6             ;	Remark		is copied to 0F1E8H
8606+  73B6             
8607+  73B6 11 DE F1    	ld	de,XF1D9+5
8608+  73B9 D5          	push	de			; on return, enable system diskrom
8609+  73BA 5E          	ld	e,(hl)
8610+  73BB 23          	inc	hl
8611+  73BC 56          	ld	d,(hl)			; get pointer
8612+  73BD EB          	ex	de,hl
8613+  73BE CD 6B F3    	call	XF36B			; enable ram on page 1
8614+  73C1 E9          	jp	(hl)			; start it
8615+  73C2             
8616+  73C2             ;	Subroutine	validate FCB filename
8617+  73C2             ;	Inputs		HL = address of pointer
8618+  73C2             ;	Outputs		________________________
8619+  73C2             ;	Remark		is copied to 0F1F4H
8620+  73C2             
8621+  73C2 C3 04 56    	jp	A5604
8622+  73C5             
8623+  73C5             ;	Data		table with reserved filenames (devicenames)
8624+  73C5             ;	Remark		is copied to 0F1F7H
8625+  73C5             
8626+  73C5 50 52 4E 20 	defb	"PRN "
8627+  73C9 4C 53 54 20 	defb	"LST "
8628+  73CD 4E 55 4C 20 	defb	"NUL "
8629+  73D1 41 55 58 20 	defb	"AUX "
8630+  73D5 43 4F 4E 20 	defb	"CON "
8631+  73D9             
8632+  73D9             ;	Data		fake direntry for devices
8633+  73D9             ;	Remark		is copied to 0F20BH
8634+  73D9             
8635+  73D9             	defb	"           "
8635+  73D9 2020202020202020202020
8636+  73E4 80          	defb	10000000b
8637+  73E5 00          	defs	10
8638+  73EF 00 00       	defw	0
8639+  73F1 00 00       	defw	0
8640+  73F3 00 00       	defw	0
8641+  73F5 00 00 00 00 	defw	0,0
8642+  73F9             
8643+  73F9             	defb	31,28,31,30,31,30,31,31,30,31,30,31
8643+  73F9 1F1C1F1E1F1E1F1F1E1F1E1F
8644+  7405             
8645+  7405             
8646+  7405             ; -----------------------------------------------------------------------------
8647+  7405             ; Patches and moved code
8648+  7405             ; -----------------------------------------------------------------------------
8649+  7405             
8650+  7405                 if INVERT_CTRL_KEY = 1
8651+  7405~            SNSMAT_AND_INVERT_CTRL:
8652+  7405~                call SNSMAT
8653+  7405~                xor 2
8654+  7405~                ret
8655+  7405                 endif
8656+  7405             
8657+  7405                 ;The following patches allows us to become the only disk driver when SHIFT is pressed
8658+  7405                 ;(or, if DISABLE_OTHERS_BY_DEFAULT=1, when GRAPH is not pressed).
8659+  7405                 ;Inspired by the "hostile takeover" mode in https://github.com/joyrex2001/dsk2rom
8660+  7405                 ;Also, since v2.1 the ROM initialization can be cancelled by pressing DEL during boot.
8661+  7405             
8662+  7405                 ;------------------------------------------------------------------------------
8663+  7405             
8664+  7405                 ;Out: A= 0 to skip init (disksystem init already started by an other diskrom )
8665+  7405                 ;        1 to continue init
8666+  7405                 ;        2 to abort init
8667+  7405                 ;        3 to abort init (and beep)
8668+  7405             
8669+  7405             DO_CHECK_CAN_INIT:
8670+  7405                 ;Disable ROM if DEL is pressed at boot time
8671+  7405             
8672+  7405 3E 08           ld a,8
8673+  7407 CD 41 01        call SNSMAT
8674+  740A E6 08           and 00001000b
8675+  740C 3E 02           ld a,2
8676+  740E C8              ret z 
8677+  740F             
8678+  740F CD C3 74        call INIHRD			; initialize diskhardware
8679+  7412 3E 02           ld a,2
8680+  7414 D8              ret c
8681+  7415             
8682+  7415 CD 7E 74        call MUST_DISABLE_OTHERS
8683+  7418 30 09           jr nc,_DO_CHECK_CAN_INIT_2
8684+  741A             
8685+  741A AF             	xor     a
8686+  741B 32 99 FD    	ld      (DEVICE),a
8687+  741E 32 20 FB    	ld      (HOKVLD),a
8688+  7421 18 0B           jr       _DO_CHECK_CAN_INIT_3
8689+  7423             
8690+  7423             _DO_CHECK_CAN_INIT_2:
8691+  7423 F3          	di
8692+  7424 3A 99 FD    	ld	a,(DEVICE)
8693+  7427 A7          	and	a			; abort disksystem init ?
8694+  7428 3E 02       	ld a,2
8695+  742A F8              ret	m			; yep, quit
8696+  742B 3E 00           ld a,0
8697+  742D C0          	ret nz 	; disksystem init already started by an other diskrom, skip init
8698+  742E             
8699+  742E             _DO_CHECK_CAN_INIT_3:
8700+  742E 21 20 FB    	ld	hl,HOKVLD
8701+  7431 CB 46       	bit	0,(hl)			; EXTBIO hook valid ?
8702+  7433 20 0C       	jr	nz,A578E
8703+  7435 CB C6       	set	0,(hl)
8704+  7437 21 CA FF    	ld	hl,EXTBIO
8705+  743A 06 0F       	ld	b,3*5
8706+  743C 36 C9       A5789:	ld	(hl),0C9H
8707+  743E 23          	inc	hl
8708+  743F 10 FB       	djnz	A5789			; nop, init EXTBIO,DISINT and ENAINT hooks
8709+  7441 2A 48 FC    A578E:	ld	hl,(BOTTOM)
8710+  7444 11 01 C0    	ld	de,0C001H
8711+  7447 E7          	rst	020H			; at least 16Kb RAM ?
8712+  7448 3E 03           ld a,3
8713+  744A D0              ret nc  	; nop, abort
8714+  744B 3E 01       	ld a,1
8715+  744D C9              ret
8716+  744E             
8717+  744E                 ;------------------------------------------------------------------------------
8718+  744E             
8719+  744E             DO_SET_DEVICE:
8720+  744E CD 7E 74        call MUST_DISABLE_OTHERS
8721+  7451 30 06           jr nc,_DO_SET_DEVICE_2
8722+  7453             
8723+  7453 3E 81       	ld      a,129
8724+  7455 32 99 FD    	ld      (DEVICE),a
8725+  7458 C9          	ret
8726+  7459             
8727+  7459             _DO_SET_DEVICE_2:
8728+  7459 21 99 FD    	ld	hl,DEVICE
8729+  745C 34          	inc	(hl)			; increase diskdriver count
8730+  745D C9          	ret
8731+  745E             
8732+  745E                 ;------------------------------------------------------------------------------
8733+  745E             
8734+  745E             GET_DEVICE_FOR_INT:
8735+  745E CD 7E 74        call MUST_DISABLE_OTHERS
8736+  7461 3E 01           ld a,1
8737+  7463 D8              ret c
8738+  7464 3A 99 FD        ld a,(DEVICE)
8739+  7467 C9              ret
8740+  7468             
8741+  7468                 ;------------------------------------------------------------------------------
8742+  7468             
8743+  7468                 ;Out: Cy=1 to return to caller immediately
8744+  7468             
8745+  7468             DO_RUNC_INTERCEPTOR:
8746+  7468 CD 7E 74        call MUST_DISABLE_OTHERS
8747+  746B 38 0A           jr c,_DO_RUNC_INTERCEPTOR_2
8748+  746D             
8749+  746D 21 99 FD        ld	hl,DEVICE
8750+  7470 AF          	xor	a
8751+  7471 BE          	cp	(hl)
8752+  7472 77          	ld	(hl),a			; clear diskinterface count
8753+  7473 37              scf
8754+  7474 F0          	ret	p			; already cleared, return control
8755+  7475 B7              or a
8756+  7476 C9              ret
8757+  7477             
8758+  7477             _DO_RUNC_INTERCEPTOR_2:
8759+  7477 AF          	xor	a
8760+  7478 21 99 FD    	ld	hl,DEVICE
8761+  747B 77          	ld	(hl),a
8762+  747C B7              or a
8763+  747D C9              ret
8764+  747E             
8765+  747E                 ;------------------------------------------------------------------------------
8766+  747E             
8767+  747E                 ;Out: Cy=1 if other drivers need to be disabled
8768+  747E             
8769+  747E             MUST_DISABLE_OTHERS:
8770+  747E 3E 06           ld a,6
8771+  7480 CD 41 01        call	SNSMAT
8772+  7483 F3          	di
8773+  7484 0F          	rrca
8774+  7485                 if DISABLE_OTHERS_BY_DEFAULT    ;...then return Cy=1 if GRAPH is NOT pressed
8775+  7485~                rrca
8776+  7485~                rrca
8777+  7485                 else                            ;...then return Cy=1 if SHIFT is pressed
8778+  7485 3F              ccf
8779+  7486                 endif
8780+  7486 C9              ret
0028   7487                 include "bank0/driver_entry_points.asm"
0001+  7487             ; MSXUSB USB FDD BIOS
0002+  7487             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003+  7487             ; This version is adapted to work with the latest version of the MSXUSB project
0004+  7487             ;
0005+  7487             ; This file contains the entry points for the driver functions
0006+  7487             ; that live in ROM bank 1, plus the implementation of DRIVES.
0007+  7487             
0008+  7487             
0009+  7487             ; The following symbols information was borrowed from
0010+  7487             ; https://github.com/joyrex2001/dsk2rom
0011+  7487             
0012+  7487             ; symbols which can be used from the kernel
0013+  7487             
0014+  7487             ; GETSLT	get my slotid
0015+  7487             ; DIV16		divide
0016+  7487             ; GETWRK	get my workarea
0017+  7487             ; SETINT	install my interrupt handler
0018+  7487             ; PRVINT	call orginal interrupt handler
0019+  7487             ; PROMPT	prompt for phantom drive
0020+  7487             ; RAWFLG	verify flag
0021+  7487             ; $SECBUF	temporary sectorbuffer
0022+  7487             ; XFER		transfer to TPA
0023+  7487             ; DISINT	inform interrupts are being disabled
0024+  7487             ; ENAINT	inform interrupts are being enabled
0025+  7487             ; PROCNM	CALL statement name
0026+  7487             
0027+  7487              ; symbols which must be defined by the driver
0028+  7487             
0029+  7487             ; INIHRD	initialize diskdriver hardware
0030+  7487             ; DRIVES	how many drives are connected
0031+  7487             ; INIENV	initialize diskdriver workarea
0032+  7487             ; DSKIO		diskdriver sector i/o
0033+  7487             ; DSKCHG	diskdriver diskchange status
0034+  7487             ; GETDPB	build Drive Parameter Block
0035+  7487             ; CHOICE	get format choice string
0036+  7487             ; DSKFMT	format disk
0037+  7487             ; DSKSTP	stop diskmotor
0038+  7487             ; OEMSTA	diskdriver special call statements
0039+  7487             
0040+  7487             ; MYSIZE	size of diskdriver workarea
0041+  7487             ; SECLEN	size of biggest sector supported by the diskdriver
0042+  7487             ; DEFDPB	pointer to a default Drive Parameter Block
0043+  7487             
0044+  7487             
0045+  7487             ; -----------------------------------------------------------------------------
0046+  7487             ; some constants
0047+  7487             ; -----------------------------------------------------------------------------
0048+  7487             
0049+  7487             ;How many bytes to allocate in page 3.
0050+  7487             ;We don't allocate any because the 8 bytes assigned to our slot
0051+  7487             ;in SLTWRK are enough.	
0052+  7487             MYSIZE:		equ	0
0053+  7487             
0054+  7487             SECLEN:		equ	512		; Size of biggest sector
0055+  7487             
0056+  7487             
0057+  7487             ; -----------------------------------------------------------------------------
0058+  7487             ; DRIVES
0059+  7487             ; -----------------------------------------------------------------------------
0060+  7487             ; Input: 	F	Zx set if to return physical drives
0061+  7487             ;			Zx reset if to return at least 2 drives, if only one
0062+  7487             ;			  physical drive it becomes a phantom drive
0063+  7487             ; Output:	L	number of drives
0064+  7487             ; Changed:	F,HL,IX,IY may be affected
0065+  7487             ;
0066+  7487             ; Remark:	DOS1 does not handle L=0 correctly
0067+  7487             ; -----------------------------------------------------------------------------
0068+  7487             
0069+  7487             DRIVES:
0070+  7487 2E 01       	ld   l,1
0071+  7489 C8              ret z
0072+  748A 2C              inc l
0073+  748B C9          	ret
0074+  748C             
0075+  748C             
0076+  748C             ; -----------------------------------------------------------------------------
0077+  748C             ; Entry points for the driver functions
0078+  748C             ; -----------------------------------------------------------------------------
0079+  748C             
0080+  748C             DSKIO:
0081+  748C DD 21 EC 47     ld ix,DSKIO_IMPL
0082+  7490 FD 21 01 00     ld iy,ROM_BANK_1
0083+  7494 C3 D2 7F        jp CALL_BANK
0084+  7497             
0085+  7497             DSKCHG:
0086+  7497 DD 21 EB 4A     ld ix,DSKCHG_IMPL
0087+  749B FD 21 01 00     ld iy,ROM_BANK_1
0088+  749F C3 D2 7F        jp CALL_BANK
0089+  74A2             
0090+  74A2             GETDPB:
0091+  74A2 DD 21 36 4B     ld ix,GETDPB_IMPL
0092+  74A6 FD 21 01 00     ld iy,ROM_BANK_1
0093+  74AA C3 D2 7F        jp CALL_BANK
0094+  74AD             
0095+  74AD             CHOICE:
0096+  74AD DD 21 E2 4B     ld ix,CHOICE_IMPL
0097+  74B1 FD 21 01 00     ld iy,ROM_BANK_1
0098+  74B5 C3 D2 7F        jp CALL_BANK
0099+  74B8                 
0100+  74B8             DSKFMT:
0101+  74B8 DD 21 ED 4B     ld ix,DSKFMT_IMPL
0102+  74BC FD 21 01 00     ld iy,ROM_BANK_1
0103+  74C0 C3 D2 7F        jp CALL_BANK
0104+  74C3             
0105+  74C3             INIHRD:
0106+  74C3 DD 21 E8 44     ld ix,INIHRD_IMPL
0107+  74C7 FD 21 01 00     ld iy,ROM_BANK_1
0108+  74CB C3 D2 7F        jp CALL_BANK
0109+  74CE             
0110+  74CE             INIENV:
0111+  74CE DD 21 02 45     ld ix,INIENV_IMPL
0112+  74D2 FD 21 01 00     ld iy,ROM_BANK_1
0113+  74D6 C3 D2 7F        jp CALL_BANK
0114+  74D9             
0115+  74D9             
0116+  74D9                 ;Disk access experiments
0117+  74D9                 if 0
0118+  74D9~            
0119+  74D9~            READ_SECTOR_0:
0120+  74D9~                ld hl,8000h
0121+  74D9~                ld de,8000h+1
0122+  74D9~                ld bc,4000h-1
0123+  74D9~                ld (hl),0ffh
0124+  74D9~                ldir
0125+  74D9~            
0126+  74D9~                xor a
0127+  74D9~                ld b,32
0128+  74D9~                ld de,0
0129+  74D9~                ld hl,8000h
0130+  74D9~                call DSKIO
0131+  74D9~                ret
0132+  74D9~            
0133+  74D9~                xor a
0134+  74D9~                ld hl,9000h
0135+  74D9~                call DSKCHG
0136+  74D9~            
0137+  74D9~                ds 7500h-$,0FFh
0138+  74D9~            
0139+  74D9~            DO_READ_SECTOR_CMD:
0140+  74D9~                ld b,80
0141+  74D9~                push bc
0142+  74D9~                ld hl,READ_SECTOR_0_CMD
0143+  74D9~                ld de,0C000h
0144+  74D9~                ld bc,12
0145+  74D9~                ldir
0146+  74D9~                pop bc
0147+  74D9~                ld a,b
0148+  74D9~                ld (0C008h),a
0149+  74D9~                sla b
0150+  74D9~                ld c,0
0151+  74D9~                ld hl,0C000h
0152+  74D9~                ld de,2000h
0153+  74D9~                ld a,1
0154+  74D9~                or a
0155+  74D9~                ld ix,USB_EXECUTE_CBI_WITH_RETRY
0156+  74D9~                ld iy,ROM_BANK_1
0157+  74D9~                call CALL_BANK
0158+  74D9~                jr DO_READ_SECTOR_CMD
0159+  74D9~            
0160+  74D9~            READ_SECTOR_0_CMD:
0161+  74D9~                db 28h, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0
0162+  74D9~            
0163+  74D9                 endif
0029   74D9                 include "bank0/choice_strings.asm"
0001+  74D9             ; MSXUSB USB FDD BIOS
0002+  74D9             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003+  74D9             ; This version is adapted to work with the latest version of the MSXUSB project
0004+  74D9             ;
0005+  74D9             ; This file contains the choice string for the FORMAT command.
0006+  74D9             ; It needs to be in a separate file because FORMAT lives in ROM bank 1,
0007+  74D9             ; but this string needs to be in bank 0.
0008+  74D9             
0009+  74D9             CHOICE_S:
0010+  74D9                 db "1 - 720K, full format",13,10
0010+  74D9 31202D203732304B2C2066756C6C20666F726D61740D0A
0011+  74F0                 db "2 - 720K, quick format",13,10
0011+  74F0 32202D203732304B2C20717569636B20666F726D61740D0A
0012+  7508                 db "3 - 1.44M, full format",13,10
0012+  7508 33202D20312E34344D2C2066756C6C20666F726D61740D0A
0013+  7520                 db "4 - 1.44M, quick format",13,10
0013+  7520 34202D20312E34344D2C20717569636B20666F726D61740D0A
0014+  7539 00              db 0
0030   753A                 include "bank0/oemstat.asm"
0001+  753A             ; MSXUSB USB FDD BIOS
0002+  753A             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003+  753A             ; This version is adapted to work with the latest version of the MSXUSB project
0004+  753A             ;
0005+  753A             ; This file contains the CALL statements handler and the
0006+  753A             ; implementations of the statements themselves.
0007+  753A             
0008+  753A             
0009+  753A             ; -----------------------------------------------------------------------------
0010+  753A             ; OEMSTATEMENT
0011+  753A             ; -----------------------------------------------------------------------------
0012+  753A             ; Input:	HL	basicpointer
0013+  753A             ; Output:	F	Cx set if statement not recognized
0014+  753A             ;			Cx reset if statement is recognized
0015+  753A             ;		HL	basicpointer,	updated if recognized
0016+  753A             ;					unchanged if not recognized
0017+  753A             ; Changed:	AF,BC,DE,HL,IX,IY may be affected
0018+  753A             ; -----------------------------------------------------------------------------
0019+  753A             
0020+  753A             OEMSTA:
0021+  753A E5              push hl
0022+  753B 21 62 75        ld hl,OEM_COMMANDS
0023+  753E             
0024+  753E             _OEMSTA_CHECK_COMMAND:
0025+  753E 7E              ld a,(hl)
0026+  753F B7              or a
0027+  7540 28 1D           jr z,_OEMSTA_UNKNOWN
0028+  7542 11 89 FD        ld de,PROCNM
0029+  7545             _OEMSTA_CHECK_COMMAND_LOOP:
0030+  7545 1A              ld a,(de)
0031+  7546 BE              cp (hl)
0032+  7547 20 07           jr nz,_OEMSTA_SKIP_COMMAND
0033+  7549 B7              or a
0034+  754A 28 0D           jr z,_OEMSTA_FOUND
0035+  754C 23              inc hl
0036+  754D 13              inc de
0037+  754E 18 F5           jr _OEMSTA_CHECK_COMMAND_LOOP
0038+  7550             
0039+  7550             _OEMSTA_SKIP_COMMAND:
0040+  7550 7E              ld a,(hl)
0041+  7551 23              inc hl
0042+  7552 B7              or a
0043+  7553 20 FB           jr nz,_OEMSTA_SKIP_COMMAND
0044+  7555 23              inc hl  ;Skip routine address
0045+  7556 23              inc hl
0046+  7557 18 E5           jr _OEMSTA_CHECK_COMMAND
0047+  7559             
0048+  7559             _OEMSTA_FOUND:
0049+  7559 23              inc hl
0050+  755A 7E              ld a,(hl)
0051+  755B 23              inc hl
0052+  755C 66              ld h,(hl)
0053+  755D 6F              ld l,a
0054+  755E E9              jp (hl)
0055+  755F             
0056+  755F             _OEMSTA_UNKNOWN:
0057+  755F E1              pop hl
0058+  7560 37          	scf
0059+  7561 C9          	ret
0060+  7562             
0061+  7562             OEM_COMMANDS:
0062+  7562             
0063+  7562                 if USE_ALTERNATIVE_PORTS=1
0064+  7562~                db "USBRESET2",0
0065+  7562~                dw OEMC_USBRESET
0066+  7562~                db "USBERROR2",0
0067+  7562~                dw OEMC_USBERROR
0068+  7562~                db "USBMENU2",0
0069+  7562~                dw OEMC_USBMENU
0070+  7562~                db "USBCD2",0
0071+  7562~                dw OEMC_USBCD
0072+  7562~                db "USBMOUNT2",0
0073+  7562~                dw OEMC_USBMOUNT
0074+  7562~                db "USBMOUNTR2",0
0075+  7562~                dw OEMC_USBMOUNTR
0076+  7562~                db "USBFILES2",0
0077+  7562~                dw OEMC_USBFILES
0078+  7562                 else
0079+  7562                 db "USBRESET",0
0079+  7562 555342524553455400
0080+  756B B7 77           dw OEMC_USBRESET
0081+  756D                 db "USBERROR",0
0081+  756D 5553424552524F5200
0082+  7576 D4 77           dw OEMC_USBERROR
0083+  7578                 db "USBMENU",0
0083+  7578 5553424D454E5500
0084+  7580 76 78           dw OEMC_USBMENU
0085+  7582                 db "USBCD",0
0085+  7582 555342434400
0086+  7588 F8 79           dw OEMC_USBCD
0087+  758A                 db "USBMOUNT",0
0087+  758A 5553424D4F554E5400
0088+  7593 AB 78           dw OEMC_USBMOUNT
0089+  7595                 db "USBMOUNTR",0
0089+  7595 5553424D4F554E545200
0090+  759F 8F 78           dw OEMC_USBMOUNTR
0091+  75A1                 db "USBFILES",0
0091+  75A1 55534246494C455300
0092+  75AA F9 7A           dw OEMC_USBFILES
0093+  75AC                 endif
0094+  75AC             
0095+  75AC                 db "USBHELP",0
0095+  75AC 55534248454C5000
0096+  75B4 B7 75           dw OEMC_USBHELP
0097+  75B6 00              db 0
0098+  75B7             
0099+  75B7                 ;--- CALL USBHELP
0100+  75B7                 ;    Show info on available CALL commands
0101+  75B7             
0102+  75B7             OEMC_USBHELP:
0103+  75B7 21 C0 75        ld hl,OEM_S_HELP
0104+  75BA CD DD 7C        call OEM_PRINT
0105+  75BD C3 26 78        jp OEM_END
0106+  75C0             
0107+  75C0             OEM_S_HELP:
0108+  75C0                 ;   ----------------------------------------
0109+  75C0                 if USE_ALTERNATIVE_PORTS=1
0110+  75C0~                db "_USBRESET2 - Re-initialize device",13,10
0111+  75C0~                db 13,10
0112+  75C0~                db "FDD device only:",13,10
0113+  75C0~                db "_USBERROR2 - Show last ASC/ASCQ err",13,10
0114+  75C0~                db 13,10
0115+  75C0~                db "Storage device only:",13,10
0116+  75C0~                db "_USBMENU2 - Show file navig menu",13,10
0117+  75C0~                db "_USBCD2 - Show current dir",13,10
0118+  75C0~                ;db"_USBCD2("dir/dir") - Change dir, rel",13,10
0119+  75C0~                db "_USBCD2(",34,"dir/dir",34,") - Change dir, rel",13,10
0120+  75C0~                ;db"_USBCD2("/dir/dir") - Change dir (abs)",13,10
0121+  75C0~                db "_USBCD2(",34,"/dir/dir",34,") - Change dir,abs",13,10
0122+  75C0~                db "_USBFILES2 - List files in curr dir",13,10
0123+  75C0~                db "_USBMOUNT2 - Show mounted file name",13,10
0124+  75C0~                ;db"_USBMOUNT2("file.ext") - Mount file",13,10
0125+  75C0~                db "_USBMOUNT2(",34,"file.ext",34,") - Mount file",13,10
0126+  75C0~                db "_USBMOUNT2(-1) - Unmount file",13,10
0127+  75C0~                db "_USBMOUNT2(0) - Mount default file",13,10
0128+  75C0~                db "_USBMOUNT2(n) - Mount nth file, 1-255",13,10
0129+  75C0~                db "_USBMOUNTR2(...) - Mount and reset",13,10
0130+  75C0                 else
0131+  75C0                 db "_USBRESET - Re-initialize device",13,10
0131+  75C0 5F5553425245534554202D2052652D696E697469616C697A6520646576696365
0131+  75E0 0D0A
0132+  75E2 0D 0A           db 13,10
0133+  75E4                 db "FDD device only:",13,10
0133+  75E4 46444420646576696365206F6E6C793A0D0A
0134+  75F6                 db "_USBERROR - Show last ASC/ASCQ error",13,10
0134+  75F6 5F5553424552524F52202D2053686F77206C617374204153432F415343512065
0134+  7616 72726F720D0A
0135+  761C 0D 0A           db 13,10
0136+  761E                 db "Storage device only:",13,10
0136+  761E 53746F7261676520646576696365206F6E6C793A0D0A
0137+  7634                 db "_USBMENU - Show file navigation menu",13,10
0137+  7634 5F5553424D454E55202D2053686F772066696C65206E617669676174696F6E20
0137+  7654 6D656E750D0A
0138+  765A                 db "_USBCD - Show current dir",13,10
0138+  765A 5F5553424344202D2053686F772063757272656E74206469720D0A
0139+  7675                 ;db"_USBCD("dir/dir") - Change dir, rel",13,10
0140+  7675                 db "_USBCD(",34,"dir/dir",34,") - Change dir, rel",13,10
0140+  7675 5F555342434428226469722F6469722229202D204368616E6765206469722C20
0140+  7695 72656C0D0A
0141+  769A                 ;db"_USBCD("/dir/dir") - Change dir (abs)",13,10
0142+  769A                 db "_USBCD(",34,"/dir/dir",34,") - Change dir, abs",13,10
0142+  769A 5F555342434428222F6469722F6469722229202D204368616E6765206469722C
0142+  76BA 206162730D0A
0143+  76C0                 db "_USBFILES - List files in curr dir",13,10
0143+  76C0 5F55534246494C4553202D204C6973742066696C657320696E20637572722064
0143+  76E0 69720D0A
0144+  76E4                 db "_USBMOUNT - Show mounted file name",13,10
0144+  76E4 5F5553424D4F554E54202D2053686F77206D6F756E7465642066696C65206E61
0144+  7704 6D650D0A
0145+  7708                 ;db"_USBMOUNT("file.ext") - Mount file",13,10
0146+  7708                 db "_USBMOUNT(",34,"file.ext",34,") - Mount file",13,10
0146+  7708 5F5553424D4F554E54282266696C652E6578742229202D204D6F756E74206669
0146+  7728 6C650D0A
0147+  772C                 db "_USBMOUNT(-1) - Unmount file",13,10
0147+  772C 5F5553424D4F554E54282D3129202D20556E6D6F756E742066696C650D0A
0148+  774A                 db "_USBMOUNT(0) - Mount default file",13,10
0148+  774A 5F5553424D4F554E54283029202D204D6F756E742064656661756C742066696C
0148+  776A 650D0A
0149+  776D                 db "_USBMOUNT(n) - Mount nth file, 1-255",13,10
0149+  776D 5F5553424D4F554E54286E29202D204D6F756E74206E74682066696C652C2031
0149+  778D 2D3235350D0A
0150+  7793                 db "_USBMOUNTR(...) - Mount and reset",13,10
0150+  7793 5F5553424D4F554E5452282E2E2E29202D204D6F756E7420616E642072657365
0150+  77B3 740D0A
0151+  77B6                 endif
0152+  77B6 00              db 0
0153+  77B7             
0154+  77B7             
0155+  77B7                 ;--- CALL USBRESET
0156+  77B7                 ;    Resets USB hardware and prints device info, just like at boot time
0157+  77B7             
0158+  77B7             OEMC_USBRESET:
0159+  77B7 DD 21 1A 45     ld ix,VERBOSE_RESET
0160+  77BB CD AE 7B        call OEM_CALL_BANK_1
0161+  77BE DD 21 E5 4F     ld ix,WK_GET_STORAGE_DEV_FLAGS
0162+  77C2 CD AE 7B        call OEM_CALL_BANK_1
0163+  77C5 CA 26 78        jp z,OEM_END
0164+  77C8 3E 01           ld a,1
0165+  77CA DD 21 3C 6C     ld ix,DSK_DO_BOOT_PROC
0166+  77CE CD AE 7B        call OEM_CALL_BANK_1
0167+  77D1 C3 26 78        jp OEM_END
0168+  77D4             
0169+  77D4             
0170+  77D4                 ;--- CALL USBERROR
0171+  77D4                 ;    Displays information about the USB or UFI error returned
0172+  77D4                 ;    by the last executed UFI command
0173+  77D4             
0174+  77D4             OEMC_USBERROR:
0175+  77D4 DD 21 E5 4F     ld ix,WK_GET_STORAGE_DEV_FLAGS
0176+  77D8 CD AE 7B        call OEM_CALL_BANK_1
0177+  77DB C2 F1 7B        jp nz,THROW_ILLEGAL_FN_CALL
0178+  77DE             
0179+  77DE DD 21 76 4F     ld ix,WK_GET_ERROR
0180+  77E2 CD AE 7B        call OEM_CALL_BANK_1
0181+  77E5 B7              or a
0182+  77E6 28 12           jr z,_OEMC_USBERROR_ASC
0183+  77E8             
0184+  77E8 F5              push af
0185+  77E9 21 29 78        ld hl,OEM_S_USBERR
0186+  77EC CD DD 7C        call OEM_PRINT
0187+  77EF F1              pop af
0188+  77F0 CD 27 7C        call PRINT_ERROR_DESCRIPTION
0189+  77F3 18 31           jr OEM_END
0190+  77F5             
0191+  77F5             _OEMC_USBERROR_HEX:
0192+  77F5 CD C7 7C        call OEM_PRINTHEX
0193+  77F8 18 2C           jr OEM_END
0194+  77FA             
0195+  77FA             _OEMC_USBERROR_ASC:
0196+  77FA 7A              ld a,d
0197+  77FB B7              or a
0198+  77FC 21 47 78        ld hl,OEM_S_NOERRDATA
0199+  77FF F5              push af
0200+  7800 CC DD 7C        call z,OEM_PRINT
0201+  7803 F1              pop af
0202+  7804 28 20           jr z,OEM_END
0203+  7806             
0204+  7806 21 39 78        ld hl,OEM_S_ASC
0205+  7809 CD DD 7C        call OEM_PRINT
0206+  780C 7A              ld a,d
0207+  780D CD C7 7C        call OEM_PRINTHEX
0208+  7810 21 35 78        ld hl,OEM_S_H_CRLF
0209+  7813 CD DD 7C        call OEM_PRINT
0210+  7816 21 40 78        ld hl,OEM_S_ASCQ
0211+  7819 CD DD 7C        call OEM_PRINT
0212+  781C 7B              ld a,e
0213+  781D CD C7 7C        call OEM_PRINTHEX
0214+  7820 21 35 78        ld hl,OEM_S_H_CRLF
0215+  7823             
0216+  7823             OEM_PRINT_AND_END:
0217+  7823 CD DD 7C        call OEM_PRINT
0218+  7826             
0219+  7826             OEM_END:
0220+  7826 E1              pop hl
0221+  7827 B7              or a
0222+  7828 C9              ret
0223+  7829             
0224+  7829             OEM_S_USBERR:
0225+  7829                 db "USB error: ",0
0225+  7829 555342206572726F723A2000
0226+  7835             OEM_S_H_CRLF:
0227+  7835 68              db  "h"
0228+  7836             OEM_S_CRLF:
0229+  7836 0D 0A 00        db 13,10,0
0230+  7839             OEM_S_ASC:
0231+  7839                 db  "ASC:  ",0
0231+  7839 4153433A202000
0232+  7840             OEM_S_ASCQ:
0233+  7840                 db  "ASCQ: ",0
0233+  7840 415343513A2000
0234+  7847             OEM_S_NOERRDATA:
0235+  7847                 db  "No error data recorded",0
0235+  7847 4E6F206572726F722064617461207265636F7264656400
0236+  785E                 
0237+  785E             
0238+  785E             ; -----------------------------------------------------------------------------
0239+  785E             ; Make sure that a storage device is connected, throw an error if not.
0240+  785E             
0241+  785E             OEMC_ENSURE_STORAGE_DEVICE:
0242+  785E DD E5           push ix
0243+  7860 E5              push hl
0244+  7861 DD 21 5B 50     ld ix,USB_CHECK_DEV_CHANGE
0245+  7865 CD AE 7B        call OEM_CALL_BANK_1
0246+  7868 DD 21 E5 4F     ld ix,WK_GET_STORAGE_DEV_FLAGS
0247+  786C CD AE 7B        call OEM_CALL_BANK_1
0248+  786F E1              pop hl
0249+  7870 DD E1           pop ix
0250+  7872 CA F1 7B        jp z,THROW_ILLEGAL_FN_CALL
0251+  7875 C9              ret
0252+  7876             
0253+  7876             
0254+  7876                 ;--- CALL USBMENU
0255+  7876                 ;    Open the USB menu if there's a storage device inserted
0256+  7876             
0257+  7876             OEMC_USBMENU:
0258+  7876 CD 5E 78        call OEMC_ENSURE_STORAGE_DEVICE
0259+  7879             
0260+  7879 3E 01           ld a,1
0261+  787B DD 21 25 57     ld ix,DO_BOOT_MENU
0262+  787F CD AE 7B        call OEM_CALL_BANK_1
0263+  7882 FE 03           cp 3
0264+  7884 CA F1 7B        jp z,THROW_ILLEGAL_FN_CALL
0265+  7887 FE 02           cp 2
0266+  7889 CA D9 7B        jp z,THROW_OUT_OF_MEMORY
0267+  788C C3 26 78        jp OEM_END
0268+  788F             
0269+  788F             
0270+  788F                 ;--- CALL USBMOUNTR:
0271+  788F                 ;    Same as USBMOUNT but resets the machine afterwards
0272+  788F                 ;    (it doesn't support the "Show file currently mounted" mode)
0273+  788F             
0274+  788F             OEMC_USBMOUNTR:
0275+  788F E1              pop hl
0276+  7890 06 01           ld b,1
0277+  7892 CD AE 78        call _OEMC_USBMOUNT_COMMON
0278+  7895             
0279+  7895 DD 21 1A 6D     ld ix,DSK_CREATE_TMP_BOOT_FILE
0280+  7899 CD AE 7B        call OEM_CALL_BANK_1
0281+  789C B7              or a
0282+  789D C2 05 7C        jp nz,THROW_DISK_ERROR
0283+  78A0                 
0284+  78A0 FD 2A C0 FC     ld iy,(EXPTBL-1)
0285+  78A4 DD 21 00 00     ld ix,0
0286+  78A8 C3 1C 00        jp CALSLT
0287+  78AB             
0288+  78AB             
0289+  78AB                 ;--- CALL USBMOUNT - Show file currently mounted
0290+  78AB                 ;    CALL USBMOUNT(-1) - Unmount file
0291+  78AB                 ;    CALL USBMOUNT(0) - Mount default file in current dir
0292+  78AB                 ;    CALL USBMOUNT(n) - Mount nth file in current dir
0293+  78AB                 ;    CALL USBMOUNT("file.ext") - Mount specified file in current dir
0294+  78AB             
0295+  78AB             OEMC_USBMOUNT:
0296+  78AB E1              pop hl
0297+  78AC 06 00           ld b,0
0298+  78AE             
0299+  78AE             _OEMC_USBMOUNT_COMMON:
0300+  78AE E5              push hl
0301+  78AF C5              push bc
0302+  78B0 CD 5E 78        call OEMC_ENSURE_STORAGE_DEVICE
0303+  78B3 C1              pop bc
0304+  78B4 E1              pop hl
0305+  78B5             
0306+  78B5 FD E5           push iy
0307+  78B7 FD 21 BF FF     ld iy,-65
0308+  78BB FD 39           add iy,sp
0309+  78BD FD F9           ld sp,iy
0310+  78BF CD CE 78        call _OEMC_USBMOUNT
0311+  78C2 FD 21 41 00     ld iy,65
0312+  78C6 FD 39           add iy,sp
0313+  78C8 FD F9           ld sp,iy
0314+  78CA FD E1           pop iy
0315+  78CC             
0316+  78CC B7              or a
0317+  78CD C9              ret
0318+  78CE             
0319+  78CE             _OEMC_USBMOUNT:
0320+  78CE 2B              dec hl
0321+  78CF DD 21 66 46     ld ix,CHRGTR
0322+  78D3 C5              push bc
0323+  78D4 CD D1 7B        call OEM_CALBAS
0324+  78D7 C1              pop bc
0325+  78D8 CA C0 79        jp z,_OEMC_USBMOUNT_PRINT
0326+  78DB             
0327+  78DB FE 28           cp '('
0328+  78DD C2 F5 7B        jp nz,THROW_SYNTAX_ERROR
0329+  78E0 23              inc hl
0330+  78E1 E5              push hl ;Save BASIC text pointer in case we need to reevaluate expression
0331+  78E2 DD 21 64 4C     ld ix,FRMEVL
0332+  78E6 CD D1 7B        call OEM_CALBAS
0333+  78E9 2B              dec hl
0334+  78EA DD 21 66 46     ld ix,CHRGTR
0335+  78EE CD D1 7B        call OEM_CALBAS
0336+  78F1 FE 29           cp ')'
0337+  78F3 C2 F5 7B        jp nz,THROW_SYNTAX_ERROR
0338+  78F6             
0339+  78F6 3A 63 F6        ld a,(VALTYP)
0340+  78F9 FE 03           cp 3
0341+  78FB 28 0B           jr z,_OEMC_USBMOUNT_BYNAME
0342+  78FD E3              ex (sp),hl  ;Restore saved BASIC text pointer and at the same time save the current pointer
0343+  78FE DD 21 2F 54     ld ix,FRMQNT
0344+  7902 CD D1 7B        call OEM_CALBAS
0345+  7905 E1              pop hl ;Restore the current pointer
0346+  7906 18 4D           jr _OEMC_USBMOUNT_NUM
0347+  7908             
0348+  7908                 ;--- Mount a file by name
0349+  7908             
0350+  7908             _OEMC_USBMOUNT_BYNAME:
0351+  7908 C1              pop bc  ;Discard saved BASIC text pointer
0352+  7909 E5              push hl
0353+  790A DD 21 D0 67     ld ix,FRESTR
0354+  790E CD D1 7B        call OEM_CALBAS
0355+  7911 EB              ex de,hl
0356+  7912 E1              pop hl
0357+  7913             
0358+  7913                 ;Here DE = Pointer to string descriptor
0359+  7913             
0360+  7913 E5              push hl ;Save BASIC text pointer
0361+  7914 EB              ex de,hl
0362+  7915             
0363+  7915 7E              ld a,(hl)
0364+  7916 B7              or a
0365+  7917 CA F1 7B        jp z,THROW_ILLEGAL_FN_CALL
0366+  791A FE 0D           cp 12+1
0367+  791C D2 E9 7B        jp nc,THROW_STRING_TOO_LONG
0368+  791F             
0369+  791F 06 00           ld b,0
0370+  7921 4F              ld c,a  ;BC = Length of string
0371+  7922 23              inc hl
0372+  7923 7E              ld a,(hl)
0373+  7924 23              inc hl
0374+  7925 66              ld h,(hl)
0375+  7926 6F              ld l,a  ;HL = Pointer to string
0376+  7927             
0377+  7927 FD E5           push iy
0378+  7929 D1              pop de
0379+  792A ED B0           ldir
0380+  792C AF              xor a
0381+  792D 12              ld (de),a   ;IY contains now the zero-terminated string
0382+  792E             
0383+  792E             _OEMC_USBMOUNT_BYNAME_GO:
0384+  792E FD E5           push iy
0385+  7930 E1              pop hl
0386+  7931 CD BA 7B        call OEM_TOUPPER
0387+  7934 AF              xor a
0388+  7935 DD 21 4A 69     ld ix,DSK_MOUNT
0389+  7939 CD AE 7B        call OEM_CALL_BANK_1
0390+  793C B7              or a
0391+  793D CA F5 79        jp z,_OEM_USBMOUNT_END
0392+  7940             
0393+  7940 F5              push af
0394+  7941 DD 21 57 6A     ld ix,DSK_REMOUNT
0395+  7945 CD AE 7B        call OEM_CALL_BANK_1
0396+  7948 F1              pop af
0397+  7949 3D              dec a
0398+  794A 3D              dec a
0399+  794B CA 01 7C        jp z,THROW_FILE_NOT_FOUND
0400+  794E 3D              dec a
0401+  794F CA E5 7B        jp z,THROW_FILE_EXISTS
0402+  7952 C3 05 7C        jp THROW_DISK_ERROR
0403+  7955             
0404+  7955             _OEMC_USBMOUNT_NUM:
0405+  7955 CB 7A           bit 7,d
0406+  7957 20 3B           jr nz,_OEMC_USBMOUNT_UNMOUNT
0407+  7959             
0408+  7959 7A              ld a,d
0409+  795A B7              or a
0410+  795B C2 F1 7B        jp nz,THROW_ILLEGAL_FN_CALL
0411+  795E             
0412+  795E B3              or e
0413+  795F 28 3D           jr z,_OEMC_USBMOUNT_DEFAULT
0414+  7961             
0415+  7961                 ;--- Mount Nth file in the directory
0416+  7961             
0417+  7961 E5              push hl
0418+  7962 D5              push de
0419+  7963             
0420+  7963 DD 21 E5 6C     ld ix,DSK_REMOUNT_DIR
0421+  7967 CD AE 7B        call OEM_CALL_BANK_1
0422+  796A B7              or a
0423+  796B C2 05 7C        jp nz,THROW_DISK_ERROR
0424+  796E             
0425+  796E D1              pop de
0426+  796F 7B              ld a,e
0427+  7970 3D              dec a
0428+  7971 FD E5           push iy
0429+  7973 E1              pop hl
0430+  7974 01 0E 00        ld bc,14
0431+  7977 09              add hl,bc
0432+  7978 DD 21 4C 42     ld ix,HWF_FIND_NTH_FILE
0433+  797C CD AE 7B        call OEM_CALL_BANK_1
0434+  797F B7              or a
0435+  7980 20 36           jr nz,_OEMC_USBMOUNT_DEFAULT_ERR
0436+  7982             
0437+  7982 FD E5           push iy
0438+  7984 E1              pop hl
0439+  7985 E5              push hl
0440+  7986 D1              pop de
0441+  7987 01 0E 00        ld bc,14
0442+  798A 09              add hl,bc
0443+  798B DD 21 3D 5D     ld ix,BM_GENERATE_FILENAME
0444+  798F CD AE 7B        call OEM_CALL_BANK_1
0445+  7992             
0446+  7992 18 9A           jr _OEMC_USBMOUNT_BYNAME_GO
0447+  7994             
0448+  7994                 ;--- Unmount currently mounted file
0449+  7994             
0450+  7994             _OEMC_USBMOUNT_UNMOUNT:
0451+  7994 E5              push hl
0452+  7995             
0453+  7995 DD 21 D1 6C     ld ix,DSK_CLOSE_FILE
0454+  7999 CD AE 7B        call OEM_CALL_BANK_1
0455+  799C             
0456+  799C 18 57           jr _OEM_USBMOUNT_END
0457+  799E             
0458+  799E                 ;--- Mount default file for directory
0459+  799E             
0460+  799E             _OEMC_USBMOUNT_DEFAULT:
0461+  799E E5              push hl
0462+  799F             
0463+  799F DD 21 E5 6C     ld ix,DSK_REMOUNT_DIR
0464+  79A3 CD AE 7B        call OEM_CALL_BANK_1
0465+  79A6 B7              or a
0466+  79A7 C2 05 7C        jp nz,THROW_DISK_ERROR
0467+  79AA             
0468+  79AA FD E5           push iy
0469+  79AC E1              pop hl
0470+  79AD DD 21 DD 6A     ld ix,DSK_GET_DEFAULT
0471+  79B1 CD AE 7B        call OEM_CALL_BANK_1
0472+  79B4 B7              or a
0473+  79B5 CA 2E 79        jp z,_OEMC_USBMOUNT_BYNAME_GO
0474+  79B8             
0475+  79B8             _OEMC_USBMOUNT_DEFAULT_ERR:
0476+  79B8 3D              dec a
0477+  79B9 3D              dec a
0478+  79BA CA 01 7C        jp z,THROW_FILE_NOT_FOUND
0479+  79BD C3 05 7C        jp THROW_DISK_ERROR
0480+  79C0             
0481+  79C0                 ;--- Print currently mounted file
0482+  79C0             
0483+  79C0             _OEMC_USBMOUNT_PRINT:
0484+  79C0 78              ld a,b
0485+  79C1 B7              or a
0486+  79C2 C2 F5 7B        jp nz,THROW_SYNTAX_ERROR
0487+  79C5             
0488+  79C5 E5              push hl
0489+  79C6             
0490+  79C6 CD 5E 78        call OEMC_ENSURE_STORAGE_DEVICE
0491+  79C9 E6 01           and 1
0492+  79CB CA 01 7C        jp z,THROW_FILE_NOT_FOUND
0493+  79CE             
0494+  79CE FD E5           push iy
0495+  79D0 D1              pop de
0496+  79D1 DD 21 C4 6C     ld ix,DSK_READ_CURFILE_FILE
0497+  79D5 CD AE 7B        call OEM_CALL_BANK_1
0498+  79D8 3D              dec a
0499+  79D9 CA 05 7C        jp z,THROW_DISK_ERROR
0500+  79DC 3D              dec a
0501+  79DD CA 01 7C        jp z,THROW_FILE_NOT_FOUND
0502+  79E0             
0503+  79E0 FD E5           push iy
0504+  79E2 E1              pop hl
0505+  79E3 CD DD 7C        call OEM_PRINT
0506+  79E6 21 36 78        ld hl,OEM_S_CRLF
0507+  79E9 CD DD 7C        call OEM_PRINT
0508+  79EC             
0509+  79EC DD 21 57 6A     ld ix,DSK_REMOUNT
0510+  79F0 CD AE 7B        call OEM_CALL_BANK_1
0511+  79F3             
0512+  79F3 E1              pop hl
0513+  79F4 C9              ret
0514+  79F5             
0515+  79F5             _OEM_USBMOUNT_END:
0516+  79F5 E1              pop hl
0517+  79F6 23              inc hl
0518+  79F7 C9              ret
0519+  79F8             
0520+  79F8             
0521+  79F8                 ;--- CALL USBCD - Print the current directory
0522+  79F8                 ;    CALL USBCD("dir/dir")  - Change to the specified relative directory
0523+  79F8                 ;    CALL USBCD("/dir/dir") - Change to the specified absolute directory
0524+  79F8             
0525+  79F8             OEMC_USBCD:
0526+  79F8 CD 5E 78        call OEMC_ENSURE_STORAGE_DEVICE
0527+  79FB             
0528+  79FB E1              pop hl
0529+  79FC             
0530+  79FC FD E5           push iy
0531+  79FE FD 21 BF FF     ld iy,-65
0532+  7A02 FD 39           add iy,sp
0533+  7A04 FD F9           ld sp,iy
0534+  7A06 CD 15 7A        call _OEMC_USBCD
0535+  7A09 FD 21 41 00     ld iy,65
0536+  7A0D FD 39           add iy,sp
0537+  7A0F FD F9           ld sp,iy
0538+  7A11 FD E1           pop iy
0539+  7A13             
0540+  7A13 B7              or a
0541+  7A14 C9              ret
0542+  7A15             _OEMC_USBCD:
0543+  7A15             
0544+  7A15 2B              dec hl
0545+  7A16 DD 21 66 46     ld ix,CHRGTR
0546+  7A1A CD D1 7B        call OEM_CALBAS
0547+  7A1D CA D0 7A        jp z,OEMC_USBCD_PRINT
0548+  7A20             
0549+  7A20                 ;--- Change the current directory
0550+  7A20             
0551+  7A20 FE 28           cp '('
0552+  7A22 C2 F5 7B        jp nz,THROW_SYNTAX_ERROR
0553+  7A25 23              inc hl
0554+  7A26 DD 21 64 4C     ld ix,FRMEVL
0555+  7A2A CD D1 7B        call OEM_CALBAS
0556+  7A2D E5              push hl
0557+  7A2E DD 21 D0 67     ld ix,FRESTR
0558+  7A32 CD D1 7B        call OEM_CALBAS
0559+  7A35 EB              ex de,hl
0560+  7A36 E1              pop hl
0561+  7A37 2B              dec hl
0562+  7A38 DD 21 66 46     ld ix,CHRGTR
0563+  7A3C CD D1 7B        call OEM_CALBAS
0564+  7A3F FE 29           cp ')'
0565+  7A41 C2 F5 7B        jp nz,THROW_SYNTAX_ERROR
0566+  7A44             
0567+  7A44                 ;Here DE = Pointer to string descriptor
0568+  7A44             
0569+  7A44 E5              push hl ;Save BASIC text pointer
0570+  7A45 EB              ex de,hl
0571+  7A46             
0572+  7A46 7E              ld a,(hl)
0573+  7A47 B7              or a
0574+  7A48 CA F1 7B        jp z,THROW_ILLEGAL_FN_CALL
0575+  7A4B FE 41           cp 64+1
0576+  7A4D D2 E9 7B        jp nc,THROW_STRING_TOO_LONG
0577+  7A50             
0578+  7A50 06 00           ld b,0
0579+  7A52 4F              ld c,a  ;BC = Length of string
0580+  7A53 23              inc hl
0581+  7A54 7E              ld a,(hl)
0582+  7A55 23              inc hl
0583+  7A56 66              ld h,(hl)
0584+  7A57 6F              ld l,a  ;HL = Pointer to string
0585+  7A58             
0586+  7A58 FD E5           push iy
0587+  7A5A D1              pop de
0588+  7A5B C5              push bc
0589+  7A5C ED B0           ldir
0590+  7A5E C1              pop bc
0591+  7A5F AF              xor a
0592+  7A60 12              ld (de),a   ;IY contains now the zero-terminated string
0593+  7A61             
0594+  7A61 FD E5           push iy
0595+  7A63 E1              pop hl
0596+  7A64 7E              ld a,(hl)
0597+  7A65 FE 2E           cp '.'
0598+  7A67 20 35           jr nz,_OEMC_USBCD_DO
0599+  7A69 23              inc hl
0600+  7A6A 7E              ld a,(hl)
0601+  7A6B 2B              dec hl
0602+  7A6C FE 2E           cp '.'
0603+  7A6E C2 F9 7B        jp nz,THROW_DIR_NOT_FOUND
0604+  7A71             
0605+  7A71                 ;"..": go to parent directory
0606+  7A71             
0607+  7A71 FD E5           push iy
0608+  7A73 D1              pop de
0609+  7A74 DD 21 BD 6C     ld ix,DSK_READ_CURDIR_FILE
0610+  7A78 CD AE 7B        call OEM_CALL_BANK_1
0611+  7A7B 3D              dec a
0612+  7A7C CA 05 7C        jp z,THROW_DISK_ERROR
0613+  7A7F             
0614+  7A7F 78              ld a,b  ;Length of current directory
0615+  7A80 B7              or a
0616+  7A81 CA F9 7B        jp z,THROW_DIR_NOT_FOUND    ;Root directory: it has no parent
0617+  7A84 58              ld e,b
0618+  7A85 48              ld c,b
0619+  7A86 06 00           ld b,0
0620+  7A88 FD E5           push iy
0621+  7A8A E1              pop hl
0622+  7A8B 09              add hl,bc   ;HL points now at the terminating zero
0623+  7A8C 43              ld b,e
0624+  7A8D             _OEMC_USBCD_FIND_PARENT:
0625+  7A8D 2B              dec hl
0626+  7A8E 7E              ld a,(hl)
0627+  7A8F FE 2F           cp '/'
0628+  7A91 28 02           jr z,_OEMC_USBCD_PARENT_FOUND
0629+  7A93 10 F8           djnz _OEMC_USBCD_FIND_PARENT
0630+  7A95                 ;If this is reached: no '/' in current dir, so parent is root
0631+  7A95             
0632+  7A95             _OEMC_USBCD_PARENT_FOUND:
0633+  7A95 36 00           ld (hl),0   ;Remove last '/' and everything after it
0634+  7A97 FD E5           push iy
0635+  7A99 E1              pop hl
0636+  7A9A 3E 01           ld a,1  ;Set absolute dir
0637+  7A9C 18 08           jr _OEMC_USBCD_DO2
0638+  7A9E             
0639+  7A9E             _OEMC_USBCD_DO:
0640+  7A9E FE 2F           cp '/'
0641+  7AA0 3E 00           ld a,0
0642+  7AA2 20 02           jr nz,_OEMC_USBCD_DO2    ;Relative dir
0643+  7AA4 23              inc hl  ;Absolute dir
0644+  7AA5 3C              inc a
0645+  7AA6             _OEMC_USBCD_DO2:
0646+  7AA6 CD BA 7B        call OEM_TOUPPER
0647+  7AA9 DD 21 89 68     ld ix,DSK_CHANGE_DIR_U
0648+  7AAD CD AE 7B        call OEM_CALL_BANK_1
0649+  7AB0 B7              or a
0650+  7AB1 28 19           jr z,_OEMC_USBCD_END
0651+  7AB3             
0652+  7AB3 F5              push af
0653+  7AB4 DD 21 57 6A     ld ix,DSK_REMOUNT
0654+  7AB8 CD AE 7B        call OEM_CALL_BANK_1
0655+  7ABB F1              pop af
0656+  7ABC             
0657+  7ABC 3D              dec a
0658+  7ABD 3D              dec a
0659+  7ABE CA F9 7B        jp z,THROW_DIR_NOT_FOUND
0660+  7AC1 3D              dec a
0661+  7AC2 CA E5 7B        jp z,THROW_FILE_EXISTS
0662+  7AC5 3D              dec a
0663+  7AC6 CA E9 7B        jp z,THROW_STRING_TOO_LONG
0664+  7AC9 C3 05 7C        jp THROW_DISK_ERROR
0665+  7ACC             
0666+  7ACC             _OEMC_USBCD_END:
0667+  7ACC E1              pop hl
0668+  7ACD 23              inc hl
0669+  7ACE B7              or a
0670+  7ACF C9              ret
0671+  7AD0             
0672+  7AD0                 ;--- Print the current directory
0673+  7AD0             
0674+  7AD0             OEMC_USBCD_PRINT:
0675+  7AD0 E5              push hl
0676+  7AD1             
0677+  7AD1 FD E5           push iy
0678+  7AD3 D1              pop de
0679+  7AD4 DD 21 BD 6C     ld ix,DSK_READ_CURDIR_FILE
0680+  7AD8 CD AE 7B        call OEM_CALL_BANK_1
0681+  7ADB 3D              dec a
0682+  7ADC CA 05 7C        jp z,THROW_DISK_ERROR
0683+  7ADF             
0684+  7ADF 3E 2F           ld a,'/'
0685+  7AE1 CD A2 00        call CHPUT
0686+  7AE4 FD E5           push iy
0687+  7AE6 E1              pop hl
0688+  7AE7 CD DD 7C        call OEM_PRINT
0689+  7AEA 21 36 78        ld hl,OEM_S_CRLF
0690+  7AED CD DD 7C        call OEM_PRINT
0691+  7AF0             
0692+  7AF0 DD 21 57 6A     ld ix,DSK_REMOUNT
0693+  7AF4 CD AE 7B        call OEM_CALL_BANK_1
0694+  7AF7             
0695+  7AF7 E1              pop hl
0696+  7AF8 C9              ret
0697+  7AF9             
0698+  7AF9             
0699+  7AF9                 ;--- CALL USBFILES - List files in current directory
0700+  7AF9             
0701+  7AF9             OEMC_USBFILES:
0702+  7AF9 CD 5E 78        call OEMC_ENSURE_STORAGE_DEVICE
0703+  7AFC             
0704+  7AFC FD E5           push iy
0705+  7AFE FD 21 F1 FF     ld iy,-14-1
0706+  7B02 FD 39           add iy,sp
0707+  7B04 FD F9           ld sp,iy
0708+  7B06 CD 16 7B        call _OEMC_USBFILES
0709+  7B09 FD 21 0F 00     ld iy,14+1
0710+  7B0D FD 39           add iy,sp
0711+  7B0F FD F9           ld sp,iy
0712+  7B11 FD E1           pop iy
0713+  7B13             
0714+  7B13 C3 26 78        jp OEM_END
0715+  7B16             
0716+  7B16             _OEMC_USBFILES:
0717+  7B16             
0718+  7B16                 ;Throw error if we have less than 1.5K of free space
0719+  7B16             
0720+  7B16 E5              push hl
0721+  7B17 21 00 00        ld hl,0
0722+  7B1A 39              add hl,sp
0723+  7B1B ED 5B C6 F6     ld de,(STREND)
0724+  7B1F B7              or a
0725+  7B20 ED 52           sbc hl,de
0726+  7B22 7C              ld a,h
0727+  7B23 FE 06           cp 6
0728+  7B25 3E 02           ld a,2
0729+  7B27 D1              pop de
0730+  7B28 DA D9 7B        jp c,THROW_OUT_OF_MEMORY
0731+  7B2B             
0732+  7B2B                 ;How many columns to show?
0733+  7B2B             
0734+  7B2B 3A B0 F3        ld a,(LINLEN)
0735+  7B2E 06 01           ld b,1
0736+  7B30 FE 1B           cp 27
0737+  7B32 38 15           jr c,_OEMC_USBFILES_SETCOLS
0738+  7B34 04              inc b
0739+  7B35 FE 28           cp 40
0740+  7B37 38 10           jr c,_OEMC_USBFILES_SETCOLS
0741+  7B39 04              inc b
0742+  7B3A FE 35           cp 53
0743+  7B3C 38 0B           jr c,_OEMC_USBFILES_SETCOLS
0744+  7B3E 04              inc b
0745+  7B3F FE 42           cp 66
0746+  7B41 38 06           jr c,_OEMC_USBFILES_SETCOLS
0747+  7B43 04              inc b
0748+  7B44 FE 4F           cp 79
0749+  7B46 38 01           jr c,_OEMC_USBFILES_SETCOLS
0750+  7B48 04              inc b
0751+  7B49             _OEMC_USBFILES_SETCOLS:
0752+  7B49 FD 60           ld iyh,b
0753+  7B4B             
0754+  7B4B                 ;How many files to list?
0755+  7B4B             
0756+  7B4B 01 64 00        ld bc,100   ;Work stack space
0757+  7B4E B7              or a
0758+  7B4F ED 42           sbc hl,bc
0759+  7B51 E5              push hl
0760+  7B52 C1              pop bc
0761+  7B53 D5              push de
0762+  7B54 11 0B 00        ld de,11
0763+  7B57 DD 21 87 55     ld ix,DIVIDE_16 ;Now BC = Files to enum
0764+  7B5B CD AE 7B        call OEM_CALL_BANK_1
0765+  7B5E D1              pop de
0766+  7B5F             
0767+  7B5F                 ;Get files
0768+  7B5F             
0769+  7B5F C5              push bc
0770+  7B60 DD 21 E5 6C     ld ix,DSK_REMOUNT_DIR
0771+  7B64 CD AE 7B        call OEM_CALL_BANK_1
0772+  7B67 C1              pop bc
0773+  7B68             
0774+  7B68 2A C6 F6        ld hl,(STREND)
0775+  7B6B DD 21 40 42     ld ix,HWF_ENUM_FILES
0776+  7B6F CD AE 7B        call OEM_CALL_BANK_1
0777+  7B72 78              ld a,b
0778+  7B73 B1              or c
0779+  7B74 CA 01 7C        jp z,THROW_FILE_NOT_FOUND
0780+  7B77             
0781+  7B77                 ;Print files
0782+  7B77             
0783+  7B77 2A C6 F6        ld hl,(STREND)
0784+  7B7A 1E 00           ld e,0
0785+  7B7C             _OEMC_USBFILES_LOOP:
0786+  7B7C 7B              ld a,e
0787+  7B7D 1C              inc e
0788+  7B7E FD BC           cp iyh
0789+  7B80 38 0A           jr c,_OEMC_USBFILES_GO
0790+  7B82 E5              push hl
0791+  7B83 21 36 78        ld hl,OEM_S_CRLF
0792+  7B86 CD DD 7C        call OEM_PRINT
0793+  7B89 E1              pop hl
0794+  7B8A 1E 01           ld e,1
0795+  7B8C             
0796+  7B8C             _OEMC_USBFILES_GO:
0797+  7B8C 7E              ld a,(hl)
0798+  7B8D B7              or a
0799+  7B8E 28 16           jr z,_OEMC_USBFILES_END
0800+  7B90             
0801+  7B90 D5              push de
0802+  7B91 DD 21 49 5D     ld ix,BM_PRINT_FILENAME
0803+  7B95 CD AE 7B        call OEM_CALL_BANK_1
0804+  7B98 D1              pop de
0805+  7B99             _OEMC_USBFILES_PAD:
0806+  7B99 79              ld a,c
0807+  7B9A FE 0D           cp 13
0808+  7B9C 30 DE           jr nc,_OEMC_USBFILES_LOOP
0809+  7B9E 3E 20           ld a,' '
0810+  7BA0 CD A2 00        call CHPUT
0811+  7BA3 0C              inc c
0812+  7BA4 18 F3           jr _OEMC_USBFILES_PAD
0813+  7BA6             
0814+  7BA6             _OEMC_USBFILES_END:
0815+  7BA6 DD 21 57 6A     ld ix,DSK_REMOUNT
0816+  7BAA CD AE 7B        call OEM_CALL_BANK_1
0817+  7BAD C9              ret
0818+  7BAE             
0819+  7BAE             
0820+  7BAE             ; -----------------------------------------------------------------------------
0821+  7BAE             ; Call a routine in the ROM bank 1 preserving IY
0822+  7BAE             ;
0823+  7BAE             ; Input:  IX = Routine address
0824+  7BAE             ;         AF, BC, DE, HL: Depends on the routine
0825+  7BAE             ; Output: AF, BC, DE, HL: Depends on the routine
0826+  7BAE             
0827+  7BAE             OEM_CALL_BANK_1:
0828+  7BAE FD E5           push iy
0829+  7BB0 FD 21 01 00     ld iy,ROM_BANK_1
0830+  7BB4 CD D2 7F        call CALL_BANK
0831+  7BB7 FD E1           pop iy
0832+  7BB9 C9              ret
0833+  7BBA             
0834+  7BBA             
0835+  7BBA             ; -----------------------------------------------------------------------------
0836+  7BBA             ; Convert a string to uppercase (ASCII characters only)
0837+  7BBA             ; Input: HL = Address of string
0838+  7BBA             
0839+  7BBA             OEM_TOUPPER:
0840+  7BBA F5              push af
0841+  7BBB E5              push hl
0842+  7BBC             _OEM_TOUPPER:
0843+  7BBC 7E              ld a,(hl)
0844+  7BBD B7              or a
0845+  7BBE 28 0E           jr z,_TOUPPER_END
0846+  7BC0 FE 61           cp 'a'
0847+  7BC2 38 07           jr c,_TOUPPER_NEXT
0848+  7BC4 FE 7B           cp 'z'+1
0849+  7BC6 30 03           jr nc,_TOUPPER_NEXT
0850+  7BC8 E6 DF           and 0DFh
0851+  7BCA 77              ld (hl),a
0852+  7BCB             _TOUPPER_NEXT:
0853+  7BCB 23              inc hl
0854+  7BCC 18 EE           jr _OEM_TOUPPER
0855+  7BCE             _TOUPPER_END:
0856+  7BCE E1              pop hl
0857+  7BCF F1              pop af
0858+  7BD0 C9              ret
0859+  7BD1             
0860+  7BD1             
0861+  7BD1             ; -----------------------------------------------------------------------------
0862+  7BD1             ; Call a routine in the BASIC interpreter preserving IY
0863+  7BD1             ;
0864+  7BD1             ; Input:  IX = Routine address
0865+  7BD1             ;         AF, BC, DE, HL: Depends on the routine
0866+  7BD1             ; Output: AF, BC, DE, HL: Depends on the routine
0867+  7BD1             
0868+  7BD1             OEM_CALBAS:
0869+  7BD1 FD E5           push iy
0870+  7BD3 CD 59 01        call CALBAS
0871+  7BD6 FD E1           pop iy
0872+  7BD8 C9              ret
0873+  7BD9             
0874+  7BD9             
0875+  7BD9             ; -----------------------------------------------------------------------------
0876+  7BD9             ; Throw various BASIC errors
0877+  7BD9             
0878+  7BD9             THROW_OUT_OF_MEMORY:
0879+  7BD9 1E 07           ld e,7
0880+  7BDB 18 2A           jr BASIC_ERR
0881+  7BDD             THROW_DIR_EXISTS:
0882+  7BDD 1E 49           ld e,73
0883+  7BDF 3A 13 F3        ld a,(0F313h)
0884+  7BE2 B7              or a
0885+  7BE3 20 22           jr nz,BASIC_ERR
0886+  7BE5             THROW_FILE_EXISTS:
0887+  7BE5 1E 41           ld e,65
0888+  7BE7 18 1E           jr BASIC_ERR
0889+  7BE9             THROW_STRING_TOO_LONG:
0890+  7BE9 1E 0F           ld e,15
0891+  7BEB 18 1A           jr BASIC_ERR
0892+  7BED             THROW_TYPE_MISMATCH:
0893+  7BED 1E 0D           ld e,13
0894+  7BEF 18 16           jr BASIC_ERR
0895+  7BF1             THROW_ILLEGAL_FN_CALL:
0896+  7BF1 1E 05           ld e,5
0897+  7BF3 18 12           jr BASIC_ERR
0898+  7BF5             THROW_SYNTAX_ERROR:
0899+  7BF5 1E 02           ld e,2
0900+  7BF7 18 0E           jr BASIC_ERR
0901+  7BF9             THROW_DIR_NOT_FOUND:
0902+  7BF9 1E 4A           ld e,74
0903+  7BFB 3A 13 F3        ld a,(0F313h)
0904+  7BFE B7              or a
0905+  7BFF 20 06           jr nz,BASIC_ERR
0906+  7C01             THROW_FILE_NOT_FOUND:
0907+  7C01 1E 35           ld e,53
0908+  7C03 18 02           jr BASIC_ERR
0909+  7C05             THROW_DISK_ERROR:
0910+  7C05 1E 45           ld e,69
0911+  7C07             
0912+  7C07             BASIC_ERR:
0913+  7C07 3A 13 F3        ld a,(0F313h)
0914+  7C0A B7              or a
0915+  7C0B 20 13           jr nz,BASIC_ERR2
0916+  7C0D             
0917+  7C0D 01 00 00        ld bc,0
0918+  7C10 AF              xor a
0919+  7C11 32 7C F8        ld (NLONLY),a		; not loading basic program, close i/o channels when requested
0920+  7C14 32 AE FC        ld (FLBMEM),a		; ascii mode
0921+  7C17 D5              push de
0922+  7C18 DD 21 24 6B     ld ix,6B24h
0923+  7C1C CD 59 01        call CALBAS
0924+  7C1F D1              pop	de
0925+  7C20             
0926+  7C20             BASIC_ERR2:
0927+  7C20 DD 21 6F 40     ld ix,406fh
0928+  7C24 C3 59 01        jp CALBAS
0929+  7C27             
0930+  7C27             
0931+  7C27             ; -----------------------------------------------------------------------------
0932+  7C27             ; Print the description of an USB error code
0933+  7C27             ;
0934+  7C27             ; Input: A = USB error code
0935+  7C27             
0936+  7C27             PRINT_ERROR_DESCRIPTION:
0937+  7C27 FE 08           cp USB_ERR_MAX+1
0938+  7C29 D2 C7 7C        jp nc,OEM_PRINTHEX
0939+  7C2C             
0940+  7C2C 3D              dec a
0941+  7C2D 4F              ld c,a
0942+  7C2E CB 21           sla c
0943+  7C30 06 00           ld b,0
0944+  7C32 21 3D 7C        ld hl,USBERR_S_TABLE
0945+  7C35 09              add hl,bc
0946+  7C36 7E              ld a,(hl)
0947+  7C37 23              inc hl
0948+  7C38 66              ld h,(hl)
0949+  7C39 6F              ld l,a
0950+  7C3A C3 DD 7C        jp OEM_PRINT
0951+  7C3D             
0952+  7C3D             USBERR_S_TABLE:
0953+  7C3D 4B 7C           dw USBERR_S_1
0954+  7C3F 4F 7C           dw USBERR_S_2
0955+  7C41 55 7C           dw USBERR_S_3
0956+  7C43 5D 7C           dw USBERR_S_4
0957+  7C45 68 7C           dw USBERR_S_5
0958+  7C47 80 7C           dw USBERR_S_6
0959+  7C49 95 7C           dw USBERR_S_7
0960+  7C4B             
0961+  7C4B 4E 41 4B 00 USBERR_S_1: db "NAK",0
0962+  7C4F             USBERR_S_2: db "Stall",0
0962+  7C4F 5374616C6C00
0963+  7C55             USBERR_S_3: db "Timeout",0
0963+  7C55 54696D656F757400
0964+  7C5D             USBERR_S_4: db "Data error",0
0964+  7C5D 44617461206572726F7200
0965+  7C68             USBERR_S_5: db "Device was disconnected",0
0965+  7C68 4465766963652077617320646973636F6E6E656374656400
0966+  7C80             USBERR_S_6: db "Panic button pressed",0
0966+  7C80 50616E696320627574746F6E207072657373656400
0967+  7C95             USBERR_S_7: db "Unexpected status received from USB host hardware",0
0967+  7C95 556E6578706563746564207374617475732072656365697665642066726F6D20
0967+  7CB5 55534220686F737420686172647761726500
0968+  7CC7             
0969+  7CC7             
0970+  7CC7             ; -----------------------------------------------------------------------------
0971+  7CC7             ; Print a byte in hexadecimal format
0972+  7CC7             ;
0973+  7CC7             ; Input: A = byte to print
0974+  7CC7             
0975+  7CC7             OEM_PRINTHEX:
0976+  7CC7 F5              push af
0977+  7CC8 CD CE 7C    	call	_OEM_PRINTHEX_1
0978+  7CCB F1          	pop af
0979+  7CCC 18 04       	jr	_OEM_PRINTHEX_2
0980+  7CCE             
0981+  7CCE 1F          _OEM_PRINTHEX_1:	rra
0982+  7CCF 1F          	rra
0983+  7CD0 1F          	rra
0984+  7CD1 1F          	rra
0985+  7CD2 F6 F0       _OEM_PRINTHEX_2:	or	0F0h
0986+  7CD4 27          	daa
0987+  7CD5 C6 A0       	add	a,0A0h
0988+  7CD7 CE 40       	adc	a,40h
0989+  7CD9             
0990+  7CD9 CD A2 00    	call CHPUT
0991+  7CDC C9          	ret
0992+  7CDD             
0993+  7CDD             
0994+  7CDD             ; -----------------------------------------------------------------------------
0995+  7CDD             ; Print a zero-terminated string
0996+  7CDD             ;
0997+  7CDD             ; Input: HL = Pointer to the string
0998+  7CDD             
0999+  7CDD             OEM_PRINT:
1000+  7CDD 7E          	ld a,(hl)
1001+  7CDE B7          	or a
1002+  7CDF C8          	ret z
1003+  7CE0 CD A2 00    	call CHPUT
1004+  7CE3 23          	inc hl
1005+  7CE4 18 F7       	jr OEM_PRINT
0031   7CE6             DEFDPB:
0032   7CE6                 include "defdpb.asm"    
0001+  7CE6             ; MSXUSB USB FDD BIOS
0002+  7CE6             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003+  7CE6             ; This version is adapted to work with the latest version of the MSXUSB project
0004+  7CE6             ;
0005+  7CE6             ; This file contains the default DPB (for a 720K disk).
0006+  7CE6             ; This needs to be present in both bank 0 (for the kernel) and bank 1 (for the driver).
0007+  7CE6             
0008+  7CE6 00          	db   0
0009+  7CE7             	;; default dpb
0010+  7CE7 F9          	db   0F9h		; Media F9
0011+  7CE8 00 02       	dw   512		; 80 Tracks	
0012+  7CEA 0F          	db   0Fh		; 9 sectors
0013+  7CEB 04          	db   04h		; 2 sides
0014+  7CEC 01          	db   01h		; 3.5" 720 Kb
0015+  7CED 02          	db   02h
0016+  7CEE 01 00       	dw   1
0017+  7CF0 02          	db   2
0018+  7CF1 70          	db   112
0019+  7CF2 0E 00       	dw   14
0020+  7CF4 CA 02       	dw   714
0021+  7CF6 03          	db   3
0022+  7CF7 07 00       	dw   7
0033   7CF9             
0034   7CF9 FF              ds CALL_IX-$,0FFh
0035   7FD0                 include "callbnk.asm"
0001+  7FD0             ; MSXUSB USB FDD BIOS
0002+  7FD0             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003+  7FD0             ; This version is adapted to work with the latest version of the MSXUSB project
0004+  7FD0             ;
0005+  7FD0             ; This file contains the code to call a routine in another ROM bank.
0006+  7FD0             ; This code needs to exist in both ROM banks 0 and 1, and at the same address.
0007+  7FD0             ;
0008+  7FD0             ; Labels are defined at the main file, not here, so that this file can be included twice.
0009+  7FD0             
0010+  7FD0             ; Adjusted for the Konami SCC mapper with proper bank-switching addresses by The Retro Hacker
0011+  7FD0             ; This is to support MSXUSB which uses the Konami SCC mapper for bank-switching
0012+  7FD0             ; Date: 2024-12-22
0013+  7FD0             ; 
0014+  7FD0             ; Key Changes:
0015+  7FD0             ; - Bank switching now uses the addresses for the Konami SCC mapper:
0016+  7FD0             ;   Bank 1: 5000h (4000h-5FFFh region)
0017+  7FD0             ;   Bank 2: 7000h (6000h-7FFFh region)
0018+  7FD0             ;   Bank 3: 9000h (8000h-9FFFh region)
0019+  7FD0             ;   Bank 4: B000h (A000h-BFFFh region)
0020+  7FD0             ; - Fixed layout of the SCC mapper is assumed for other regions.
0021+  7FD0             
0022+  7FD0             ;CALL_IX:
0023+  7FD0 DD E9           jp (ix) ; Jump to the address in IX (routine in the switched bank)
0024+  7FD2             
0025+  7FD2             
0026+  7FD2             ; Call a routine in another bank
0027+  7FD2             ; Input:  IX = Routine address
0028+  7FD2             ;         IYl = Bank number
0029+  7FD2             ;         All others registers = input for the routine
0030+  7FD2             ; Output: All registers = output from the routine
0031+  7FD2             
0032+  7FD2             ;CALL_BANK:
0033+  7FD2 E5              push hl ; Save HL (used to track the current bank)
0034+  7FD3 2A FF 7F        ld hl,(7FFFh) ; Load the current bank number into HL (L=Current bank)
0035+  7FD6 E3              ex (sp),hl ; Swap HL with the top of the stack (store previous bank)
0036+  7FD7 F5              push af ; Save AF (to preserve flags)
0037+  7FD8             
0038+  7FD8                 ; Switch to the target bank
0039+  7FD8 FD 7D           ld a,iyl ; Load the target bank number into A
0040+  7FDA                 if USE_ALTERNATIVE_PORTS=1
0041+  7FDA~                or 80h
0042+  7FDA                 endif
0043+  7FDA             
0044+  7FDA CB 27           sla a ; Shift the bank number to the left
0045+  7FDC 32 00 50        ld (ROM_BANK_SWITCH),a ; Switch bank for 4000h-5FFFh region
0046+  7FDF 3C              inc a ; Increment the bank number
0047+  7FE0 32 00 70        ld (7000h),a ; Switch bank for 6000h-7FFFh region
0048+  7FE3             
0049+  7FE3 F1              pop af ; Restore AF (flags)
0050+  7FE4 CD D0 7F        call CALL_IX ; Call the routine in the switched bank
0051+  7FE7 E3              ex (sp),hl ; Retrieve the previous bank number into HL
0052+  7FE8 F5              push af ; Save AF again (to preserve flags during restoration)
0053+  7FE9 7D              ld a,l ; Load the previous bank number into A
0054+  7FEA             
0055+  7FEA                 if USE_ALTERNATIVE_PORTS=1
0056+  7FEA~                or 80h
0057+  7FEA                 endif
0058+  7FEA                 
0059+  7FEA CB 27           sla a ; Shift the bank number to the left
0060+  7FEC 32 00 50        ld (ROM_BANK_SWITCH),a ; Switch bank for 4000h-5FFFh region
0061+  7FEF 3C              inc a ; Increment the bank number
0062+  7FF0 32 00 70        ld (7000h),a ; Switch bank for 6000h-7FFFh region
0063+  7FF3                 
0064+  7FF3 F1              pop af ; Restore AF (flags)
0065+  7FF4 E1              pop hl ; Restore HL
0066+  7FF5 C9              ret ; Return to the calling routine
0067+  7FF6             
0068+  7FF6             
0036   7FF6             
0037   7FF6 FF              ds 7FFFh-$,0FFh
0038   7FFF 00              db ROM_BANK_0
0039   8000             
0040   8000             
0041   8000                 ;--- ROM bank 1: 
0042   8000                 ;    - Initialization routine, executed at boot and by CALL USBRESET
0043   8000                 ;    - MSX-DOS driver function implementations
0044   8000                 ;    - All the USB+CBI related code
0045   8000                 ;    - Default DPB for use by the driver
0046   8000             
0047   8000                 ; Note: USB host hardware dependant code needs to be placed before usb.asm 
0048   8000                 ; because of the HW_IMPL_* constants.
0049   8000             
0050   8000                 org 4000h
0051   4000             
0052   4000                 include "bank1/header.asm"
0001+  4000             ; MSXUSB USB FDD BIOS
0002+  4000             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003+  4000             ; This version is adapted to work with the latest version of the MSXUSB project
0004+  4000             ;
0005+  4000             ; This file defines a ROM header for bank 1, it simply jumps to the initialization
0006+  4000             ; routine for bank 0. This header is needed to ensure that the ROM will boot properly
0007+  4000             ; even if for some reason the computer resets while executing code in bank 1.
0008+  4000             
0009+  4000 41 42           db "AB"
0010+  4002 10 40           dw BANK1_INIT
0011+  4004 00              ds 12
0012+  4010             
0013+  4010             BANK1_INIT:
0014+  4010 21 1E 40        ld hl,BANK1_INIT_DO
0015+  4013 11 00 C0        ld de,0C000h
0016+  4016 01 08 00        ld bc,BANK1_INIT_DO_END - BANK1_INIT_DO
0017+  4019 ED B0           ldir
0018+  401B C3 00 C0        jp 0C000h
0019+  401E             
0020+  401E             BANK1_INIT_DO:
0021+  401E AF              xor a
0022+  401F 32 00 50        ld (ROM_BANK_SWITCH),a
0023+  4022 2A 02 40        ld hl,(4002h)
0024+  4025 E9              jp (hl)
0025+  4026             BANK1_INIT_DO_END:
0053   4026                 include "bank1/ch376.asm" ;USB host hardware dependant code
0001+  4026             ; MSXUSB USB FDD BIOS
0002+  4026             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003+  4026             ; This version is adapted to work with the latest version of the MSXUSB project
0004+  4026             ;
0005+  4026             ; This file contains all the code that depends on the CH376.
0006+  4026             ; To adapt the ROM to use a different USB host controller you need to:
0007+  4026             ;
0008+  4026             ; 1. Create a new source file.
0009+  4026             
0010+  4026             ; 2. Copy the HW_IMPL_* constants and set their values as appropriate,
0011+  4026             ;    depending on which routines you are implementing.
0012+  4026             ;
0013+  4026             ; 3. Implement all the HW_* routines in the new file,
0014+  4026             ;    except those for which you have set HW_IMPL_* to 0.
0015+  4026             ;
0016+  4026             ; 4. Include the new file in rookiefdd.asm, replacing the file labeled as
0017+  4026             ;    "USB host hardware dependant code".
0018+  4026             ;
0019+  4026             ; All the code in this file is stateless: work area is not used,
0020+  4026             ; all the required information is passed in registers or buffers.
0021+  4026             
0022+  4026             
0023+  4026             ; -----------------------------------------------------------------------------
0024+  4026             ; Optional routine implementation flags
0025+  4026             ; -----------------------------------------------------------------------------
0026+  4026             ;
0027+  4026             ; The CH376 has built-in shortcuts for some common USB operations,
0028+  4026             ; and this BIOS take advantage of this.
0029+  4026             ; If you are adapting this BIOS to a different USB host hardware,
0030+  4026             ; you can implement the same routines if the hardware provides the same
0031+  4026             ; shortcuts, or leave the constants to 0 if not.
0032+  4026             ;
0033+  4026             ; HW_IMPL_<routine> needs to be 1 if HW_<routine> is implemented.
0034+  4026             
0035+  4026             HW_IMPL_GET_DEV_DESCR: equ 1
0036+  4026             HW_IMPL_GET_CONFIG_DESCR: equ 1
0037+  4026             HW_IMPL_SET_CONFIG: equ 1
0038+  4026             HW_IMPL_SET_ADDRESS: equ 1
0039+  4026             HW_IMPL_CONFIGURE_NAK_RETRY: equ 1
0040+  4026             
0041+  4026             
0042+  4026             ; -----------------------------------------------------------------------------
0043+  4026             ; Constant definitions
0044+  4026             ; -----------------------------------------------------------------------------
0045+  4026             
0046+  4026             ;--- CH376 port to Z80 ports mapping
0047+  4026             
0048+  4026                 if USE_ALTERNATIVE_PORTS=1
0049+  4026~            CH_DATA_PORT: equ 22h
0050+  4026~            CH_COMMAND_PORT: equ 23h    
0051+  4026                 else
0052+  4026             CH_DATA_PORT: equ 20h
0053+  4026             CH_COMMAND_PORT: equ 21h
0054+  4026                 endif
0055+  4026             
0056+  4026             ;--- Commands
0057+  4026             
0058+  4026             CH_CMD_GET_IC_VER: equ 01h
0059+  4026             CH_CMD_RESET_ALL: equ 05h
0060+  4026             CH_CMD_CHECK_EXIST: equ 06h
0061+  4026             CH_CMD_READ_VAR8: equ 0Ah
0062+  4026             CH_CMD_SET_RETRY: equ 0Bh
0063+  4026             CH_CMD_WRITE_VAR8: equ 0Bh
0064+  4026             CH_CMD_READ_VAR32: equ 0Ch
0065+  4026             CH_CMD_WRITE_VAR32: equ 0Dh
0066+  4026             CH_CMD_DELAY_100US: equ 0Fh
0067+  4026             CH_CMD_SET_USB_ADDR: equ 13h
0068+  4026             CH_CMD_SET_USB_MODE: equ 15h
0069+  4026             CH_CMD_TEST_CONNECT: equ 16h
0070+  4026             CH_CMD_ABORT_NAK: equ 17h
0071+  4026             CH_CMD_GET_STATUS: equ 22h
0072+  4026             CH_CMD_RD_USB_DATA0: equ 27h
0073+  4026             CH_CMD_WR_HOST_DATA: equ 2Ch
0074+  4026             CH_CMD_WR_REQ_DATA: equ 2Dh
0075+  4026             CH_CMD_SET_FILE_NAME: equ 2Fh
0076+  4026             CH_CMD_DISK_CONNECT: equ 30h
0077+  4026             CH_CMD_DISK_MOUNT: equ 31h
0078+  4026             CH_CMD_FILE_OPEN: equ 32h
0079+  4026             CH_CMD_FILE_ENUM_GO: equ 33h
0080+  4026             CH_CMD_FILE_CREATE: equ 34h
0081+  4026             CH_CMD_FILE_ERASE: equ 35h
0082+  4026             CH_CMD_FILE_CLOSE: equ 36h
0083+  4026             CH_CMD_DIR_INFO_READ: equ 37h
0084+  4026             CH_CMD_BYTE_LOCATE: equ 39h
0085+  4026             CH_CMD_BYTE_READ: equ 3Ah
0086+  4026             CH_CMD_BYTE_RD_GO: equ 3Bh
0087+  4026             CH_CMD_BYTE_WRITE: equ 3Ch
0088+  4026             CH_CMD_BYTE_WRITE_GO: equ 3Dh
0089+  4026             CH_CMD_DIR_CREATE: equ 40h
0090+  4026             CH_CMD_SET_ADDRESS: equ 45h
0091+  4026             CH_CMD_GET_DESCR: equ 46h
0092+  4026             CH_CMD_SET_CONFIG: equ 49h
0093+  4026             CH_CMD_ISSUE_TKN_X: equ 4Eh
0094+  4026             
0095+  4026             ;--- PIDs
0096+  4026             
0097+  4026             CH_PID_SETUP: equ 0Dh
0098+  4026             CH_PID_IN: equ 09h
0099+  4026             CH_PID_OUT: equ 01h
0100+  4026             
0101+  4026             ;--- Status codes
0102+  4026             
0103+  4026             CH_ST_INT_SUCCESS: equ 14h
0104+  4026             CH_ST_INT_CONNECT: equ 15h
0105+  4026             CH_ST_INT_DISCONNECT: equ 16h
0106+  4026             CH_ST_INT_BUF_OVER: equ 17h
0107+  4026             CH_ST_INT_DISK_READ: equ 1Dh
0108+  4026             CH_ST_INT_DISK_WRITE: equ 1Eh
0109+  4026             CH_ST_INT_DISK_ERR: equ 1Fh
0110+  4026             CH_ST_RET_SUCCESS: equ 51h
0111+  4026             CH_ST_RET_ABORT: equ 5Fh
0112+  4026             
0113+  4026             
0114+  4026             ; -----------------------------------------------------------------------------
0115+  4026             ; Mandatory routines
0116+  4026             ; -----------------------------------------------------------------------------   
0117+  4026             
0118+  4026             ; -----------------------------------------------------------------------------
0119+  4026             ; HW_TEST: Check if the USB host controller hardware is operational
0120+  4026             ; -----------------------------------------------------------------------------
0121+  4026             ; Output: Cy = 0 if hardware is operational, 1 if it's not
0122+  4026             
0123+  4026             HW_TEST:
0124+  4026                 if USE_FAKE_STORAGE_DEVICE=1
0125+  4026~                or a
0126+  4026~                ret
0127+  4026                 endif
0128+  4026             
0129+  4026 3E 34           ld a,34h
0130+  4028 CD 36 40        call _HW_TEST_DO
0131+  402B 37              scf
0132+  402C C0              ret nz
0133+  402D             
0134+  402D 3E 89           ld a,89h
0135+  402F CD 36 40        call _HW_TEST_DO
0136+  4032 37              scf
0137+  4033 C0              ret nz
0138+  4034             
0139+  4034 B7              or a
0140+  4035 C9              ret
0141+  4036             
0142+  4036             _HW_TEST_DO:
0143+  4036 47              ld b,a
0144+  4037 3E 06           ld a,CH_CMD_CHECK_EXIST
0145+  4039 D3 21           out (CH_COMMAND_PORT),a
0146+  403B 78              ld a,b
0147+  403C EE FF           xor 0FFh
0148+  403E D3 20           out (CH_DATA_PORT),a
0149+  4040 DB 20           in a,(CH_DATA_PORT)
0150+  4042 B8              cp b
0151+  4043 C9              ret
0152+  4044             
0153+  4044             
0154+  4044             ; -----------------------------------------------------------------------------
0155+  4044             ; HW_RESET: Reset the USB controller hardware
0156+  4044             ;
0157+  4044             ; If a device is connected performs a bus reset that leaves the device
0158+  4044             ; in the "Default" state.
0159+  4044             ; -----------------------------------------------------------------------------
0160+  4044             ; Input:  -
0161+  4044             ; Output: A = 1 if a USB device is connected
0162+  4044             ;             -1 if no USB device is connected
0163+  4044             ;         Cy = 1 if reset failed
0164+  4044             
0165+  4044             HW_RESET:
0166+  4044             
0167+  4044                 ;Clear the CH376 data buffer in case a reset was made
0168+  4044                 ;while it was in the middle of a data transfer operation
0169+  4044                 ;ld b,64
0170+  4044             _HW_RESET_CLEAR_DATA_BUF:
0171+  4044 DB 20           in a,(CH_DATA_PORT)
0172+  4046 10 FC           djnz _HW_RESET_CLEAR_DATA_BUF
0173+  4048             
0174+  4048 3E 05           ld a,CH_CMD_RESET_ALL
0175+  404A D3 21           out (CH_COMMAND_PORT),a
0176+  404C             
0177+  404C                 if USING_ARDUINO_BOARD=1
0178+  404C~                ld bc,1000
0179+  404C~            _HW_RESET_WAIT:
0180+  404C~                dec bc
0181+  404C~                ld a,b
0182+  404C~                or c
0183+  404C~                jr nz,_HW_RESET_WAIT
0184+  404C                 else
0185+  404C 01 5E 01        ld bc,350
0186+  404F CD 8D 41        call CH_DELAY
0187+  4052                 endif
0188+  4052             
0189+  4052 CD 6A 44        call CH_DO_SET_NOSOF_MODE
0190+  4055 D8              ret c
0191+  4056             
0192+  4056 3E 16           ld a,CH_CMD_TEST_CONNECT
0193+  4058 D3 21           out (CH_COMMAND_PORT),a
0194+  405A             _CH_WAIT_TEST_CONNECT:
0195+  405A DB 20           in a,(CH_DATA_PORT)
0196+  405C B7              or a
0197+  405D 28 FB           jr z,_CH_WAIT_TEST_CONNECT
0198+  405F FE 16           cp CH_ST_INT_DISCONNECT
0199+  4061 3E FF           ld a,-1
0200+  4063 C8              ret z
0201+  4064             
0202+  4064 C3 74 41        jp HW_BUS_RESET
0203+  4067             
0204+  4067             
0205+  4067             ; -----------------------------------------------------------------------------
0206+  4067             ; HW_DEV_CHANGE: Check for changes in the device connection
0207+  4067             ;
0208+  4067             ; The returned status is relative to the last time that the routine
0209+  4067             ; was called.
0210+  4067             ;
0211+  4067             ; If a device has been connected it performs a bus reset that leaves the device
0212+  4067             ; in the "Default" state.
0213+  4067             ; -----------------------------------------------------------------------------
0214+  4067             ; Input:  -
0215+  4067             ; Output: A = 1 if a USB device has been connected
0216+  4067             ;             0 if no change has been detected
0217+  4067             ;             -1 if the USB device has been disconnected
0218+  4067             ;         Cy = 1 if bus reset failed
0219+  4067             
0220+  4067             HW_DEV_CHANGE:
0221+  4067 CD F3 43        call CH_CHECK_INT_IS_ACTIVE
0222+  406A 3E 00           ld a,0
0223+  406C C0              ret nz
0224+  406D                 
0225+  406D CD 63 44        call CH_GET_STATUS
0226+  4070 FE 15           cp CH_ST_INT_CONNECT
0227+  4072 CA 74 41        jp z,HW_BUS_RESET
0228+  4075 FE 16           cp CH_ST_INT_DISCONNECT
0229+  4077 CA 6A 44        jp z,CH_DO_SET_NOSOF_MODE
0230+  407A             
0231+  407A AF              xor a
0232+  407B C9              ret
0233+  407C             
0234+  407C             
0235+  407C             ; -----------------------------------------------------------------------------
0236+  407C             ; HW_CONTROL_TRANSFER: Perform a USB control transfer on endpoint 0
0237+  407C             ;
0238+  407C             ; The size and direction of the transfer are taken from the contents
0239+  407C             ; of the setup packet.
0240+  407C             ; -----------------------------------------------------------------------------
0241+  407C             ; Input:  HL = Address of a 8 byte buffer with the setup packet
0242+  407C             ;         DE = Address of the input or output data buffer
0243+  407C             ;         A  = Device address
0244+  407C             ;         B  = Maximum packet size for endpoint 0
0245+  407C             ; Output: A  = USB error code
0246+  407C             ;         BC = Amount of data actually transferred (if IN transfer and no error)
0247+  407C             
0248+  407C             HW_CONTROL_TRANSFER:
0249+  407C CD 8D 44        call CH_SET_TARGET_DEVICE_ADDRESS
0250+  407F             
0251+  407F E5              push hl
0252+  4080 C5              push bc
0253+  4081 D5              push de
0254+  4082             
0255+  4082 06 08           ld b,8
0256+  4084 CD C5 44        call CH_WRITE_DATA  ;Write SETUP data packet    
0257+  4087             
0258+  4087 AF              xor a
0259+  4088 1E 00           ld e,0
0260+  408A 06 0D           ld b,CH_PID_SETUP
0261+  408C CD 96 44        call CH_ISSUE_TOKEN
0262+  408F             
0263+  408F CD 01 44        call CH_WAIT_INT_AND_GET_RESULT
0264+  4092 E1              pop hl  ;HL = Data address (was DE)
0265+  4093 D1              pop de  ;D  = Endpoint size (was B)
0266+  4094 DD E1           pop ix  ;IX = Address of setup packet (was HL)
0267+  4096 B7              or a
0268+  4097 01 00 00        ld bc,0
0269+  409A C0              ret nz  ;DONE if error
0270+  409B             
0271+  409B DD 4E 06        ld c,(ix+6)
0272+  409E DD 46 07        ld b,(ix+7) ;BC = Data length
0273+  40A1 78              ld a,b
0274+  40A2 B1              or c
0275+  40A3 28 27           jr z,_CH_CONTROL_STATUS_IN_TRANSFER
0276+  40A5 1E 00           ld e,0      ;E  = Endpoint number
0277+  40A7 37              scf         ;Use toggle = 1
0278+  40A8 DD CB 00 7E     bit 7,(ix)
0279+  40AC 28 19           jr z,_CH_CONTROL_OUT_TRANSFER
0280+  40AE             
0281+  40AE             _CH_CONTROL_IN_TRANSFER:
0282+  40AE CD E4 40        call CH_DATA_IN_TRANSFER
0283+  40B1 B7              or a
0284+  40B2 C0              ret nz
0285+  40B3             
0286+  40B3 C5              push bc
0287+  40B4             
0288+  40B4 06 00           ld b,0
0289+  40B6 CD C5 44        call CH_WRITE_DATA
0290+  40B9 1E 00           ld e,0
0291+  40BB 06 01           ld b,CH_PID_OUT
0292+  40BD 3E 40           ld a,40h    ;Toggle bit = 1
0293+  40BF CD 96 44        call CH_ISSUE_TOKEN
0294+  40C2 CD 01 44        call CH_WAIT_INT_AND_GET_RESULT
0295+  40C5             
0296+  40C5 C1              pop bc
0297+  40C6 C9              ret
0298+  40C7             
0299+  40C7             _CH_CONTROL_OUT_TRANSFER:
0300+  40C7 CD 2E 41        call CH_DATA_OUT_TRANSFER
0301+  40CA B7              or a
0302+  40CB C0              ret nz
0303+  40CC             
0304+  40CC             _CH_CONTROL_STATUS_IN_TRANSFER:
0305+  40CC C5              push bc
0306+  40CD             
0307+  40CD 1E 00           ld e,0
0308+  40CF 06 09           ld b,CH_PID_IN
0309+  40D1 3E 80           ld a,80h    ;Toggle bit = 1
0310+  40D3 CD 96 44        call CH_ISSUE_TOKEN
0311+  40D6 21 00 00        ld hl,0
0312+  40D9 CD A9 44        call CH_READ_DATA
0313+  40DC CD 01 44        call CH_WAIT_INT_AND_GET_RESULT
0314+  40DF             
0315+  40DF C1              pop bc
0316+  40E0 C9              ret
0317+  40E1             
0318+  40E1             
0319+  40E1             ; -----------------------------------------------------------------------------
0320+  40E1             ; HW_DATA_IN_TRANSFER: Perform a USB data IN transfer
0321+  40E1             ; -----------------------------------------------------------------------------
0322+  40E1             ; Input:  HL = Address of a buffer for the received data
0323+  40E1             ;         BC = Data length
0324+  40E1             ;         A  = Device address
0325+  40E1             ;         D  = Maximum packet size for the endpoint
0326+  40E1             ;         E  = Endpoint number
0327+  40E1             ;         Cy = Current state of the toggle bit
0328+  40E1             ; Output: A  = USB error code
0329+  40E1             ;         BC = Amount of data actually received (only if no error)
0330+  40E1             ;         Cy = New state of the toggle bit (even on error)
0331+  40E1             
0332+  40E1             HW_DATA_IN_TRANSFER:
0333+  40E1 CD 8D 44        call CH_SET_TARGET_DEVICE_ADDRESS
0334+  40E4             
0335+  40E4             ; This entry point is used when target device address is already set
0336+  40E4             CH_DATA_IN_TRANSFER:
0337+  40E4 3E 00           ld a,0
0338+  40E6 1F              rra     ;Toggle to bit 7 of A
0339+  40E7 DD 21 00 00     ld ix,0 ;IX = Received so far count
0340+  40EB D5              push de
0341+  40EC FD E1           pop iy  ;IY = EP size + EP number
0342+  40EE             
0343+  40EE             _CH_DATA_IN_LOOP:
0344+  40EE F5              push af ;Toggle in bit 7
0345+  40EF C5              push bc ;Remaining length
0346+  40F0             
0347+  40F0 FD 5D           ld e,iyl
0348+  40F2 06 09           ld b,CH_PID_IN
0349+  40F4 CD 96 44        call CH_ISSUE_TOKEN
0350+  40F7             
0351+  40F7 CD 01 44        call CH_WAIT_INT_AND_GET_RESULT
0352+  40FA B7              or a
0353+  40FB 20 25           jr nz,_CH_DATA_IN_ERR   ;DONE if error
0354+  40FD             
0355+  40FD CD A9 44        call CH_READ_DATA
0356+  4100 48              ld c,b
0357+  4101 06 00           ld b,0
0358+  4103 DD 09           add ix,bc   ;Update received so far count
0359+  4105             _CH_DATA_IN_NO_MORE_DATA:
0360+  4105             
0361+  4105 D1              pop de
0362+  4106 F1              pop af
0363+  4107 EE 80           xor 80h     ;Update toggle
0364+  4109 F5              push af
0365+  410A D5              push de
0366+  410B             
0367+  410B 79              ld a,c
0368+  410C B7              or a
0369+  410D 28 12           jr z,_CH_DATA_IN_DONE    ;DONE if no data received
0370+  410F             
0371+  410F E3              ex (sp),hl  ;Now HL = Remaining data length
0372+  4110 B7              or a
0373+  4111 ED 42           sbc hl,bc   ;Now HL = Updated remaning data length
0374+  4113 7C              ld a,h
0375+  4114 B5              or l
0376+  4115 E3              ex (sp),hl  ;Remaining data length is back on the stack
0377+  4116 28 09           jr z,_CH_DATA_IN_DONE    ;DONE if no data remaining
0378+  4118             
0379+  4118 79              ld a,c
0380+  4119 FD BC           cp iyh
0381+  411B 38 04           jr c,_CH_DATA_IN_DONE    ;DONE if transferred less than the EP size
0382+  411D             
0383+  411D C1              pop bc
0384+  411E F1              pop af  ;We need this to pass the next toggle to CH_ISSUE_TOKEN
0385+  411F             
0386+  411F 18 CD           jr _CH_DATA_IN_LOOP
0387+  4121             
0388+  4121             ;Input: A=Error code (if ERR), in stack: remaining length, new toggle
0389+  4121             _CH_DATA_IN_DONE:
0390+  4121 AF              xor a
0391+  4122             _CH_DATA_IN_ERR:
0392+  4122 57              ld d,a
0393+  4123 C1              pop bc
0394+  4124 F1              pop af
0395+  4125 17              rla ;Toggle back to Cy
0396+  4126 7A              ld a,d
0397+  4127 DD E5           push ix
0398+  4129 C1              pop bc
0399+  412A C9              ret
0400+  412B             
0401+  412B             
0402+  412B             ; -----------------------------------------------------------------------------
0403+  412B             ; HW_DATA_OUT_TRANSFER: Perform a USB data OUT transfer
0404+  412B             ; -----------------------------------------------------------------------------
0405+  412B             ; Input:  HL = Address of a buffer for the data to be sent
0406+  412B             ;         BC = Data length
0407+  412B             ;         A  = Device address
0408+  412B             ;         D  = Maximum packet size for the endpoint
0409+  412B             ;         E  = Endpoint number
0410+  412B             ;         Cy = Current state of the toggle bit
0411+  412B             ; Output: A  = USB error code
0412+  412B             ;         Cy = New state of the toggle bit (even on error)
0413+  412B             
0414+  412B             HW_DATA_OUT_TRANSFER:
0415+  412B CD 8D 44        call CH_SET_TARGET_DEVICE_ADDRESS
0416+  412E             
0417+  412E             ; This entry point is used when target device address is already set
0418+  412E             CH_DATA_OUT_TRANSFER:
0419+  412E 3E 00           ld a,0
0420+  4130 1F              rra     ;Toggle to bit 6 of A
0421+  4131 1F              rra
0422+  4132 D5              push de
0423+  4133 FD E1           pop iy  ;IY = EP size + EP number
0424+  4135             
0425+  4135             _CH_DATA_OUT_LOOP:
0426+  4135 F5              push af ;Toggle in bit 6
0427+  4136 C5              push bc ;Remaining length
0428+  4137             
0429+  4137 78              ld a,b 
0430+  4138 B7              or a
0431+  4139 FD 7C           ld a,iyh
0432+  413B 20 07           jr nz,_CH_DATA_OUT_DO
0433+  413D 79              ld a,c
0434+  413E FD BC           cp iyh
0435+  4140 38 02           jr c,_CH_DATA_OUT_DO
0436+  4142 FD 7C           ld a,iyh
0437+  4144             
0438+  4144             _CH_DATA_OUT_DO:
0439+  4144                 ;Here, A = Length of the next transfer: min(remaining length, EP size)
0440+  4144             
0441+  4144 E3              ex (sp),hl
0442+  4145 5F              ld e,a
0443+  4146 16 00           ld d,0
0444+  4148 B7              or a
0445+  4149 ED 52           sbc hl,de
0446+  414B E3              ex (sp),hl     ;Updated remaining data length to the stack
0447+  414C             
0448+  414C 47              ld b,a
0449+  414D CD C5 44        call CH_WRITE_DATA
0450+  4150             
0451+  4150 C1              pop bc
0452+  4151 F1              pop af  ;Retrieve toggle
0453+  4152 F5              push af
0454+  4153 C5              push bc
0455+  4154             
0456+  4154 FD 5D           ld e,iyl
0457+  4156 06 01           ld b,CH_PID_OUT
0458+  4158 CD 96 44        call CH_ISSUE_TOKEN
0459+  415B             
0460+  415B CD 01 44        call CH_WAIT_INT_AND_GET_RESULT
0461+  415E B7              or a
0462+  415F 20 0C           jr nz,_CH_DATA_OUT_DONE   ;DONE if error
0463+  4161             
0464+  4161 C1              pop bc
0465+  4162 F1              pop af
0466+  4163 EE 40           xor 40h     ;Update toggle
0467+  4165 F5              push af
0468+  4166             
0469+  4166 78              ld a,b
0470+  4167 B1              or c
0471+  4168 28 04           jr z,_CH_DATA_OUT_DONE_2  ;DONE if no more data to transfer
0472+  416A             
0473+  416A F1              pop af  ;We need this to pass the next toggle to CH_ISSUE_TOKEN
0474+  416B             
0475+  416B 18 C8           jr _CH_DATA_OUT_LOOP
0476+  416D             
0477+  416D             ;Input: A=Error code, in stack: remaining length, new toggle
0478+  416D             _CH_DATA_OUT_DONE:
0479+  416D C1              pop bc
0480+  416E             _CH_DATA_OUT_DONE_2:
0481+  416E 57              ld d,a
0482+  416F F1              pop af
0483+  4170 17              rla ;Toggle back to Cy
0484+  4171 17              rla
0485+  4172 7A              ld a,d
0486+  4173 C9              ret
0487+  4174             
0488+  4174             
0489+  4174             ; -----------------------------------------------------------------------------
0490+  4174             ; HW_BUS_RESET: Performs a USB bus reset.
0491+  4174             ;
0492+  4174             ; This needs to run when a device connection is detected.
0493+  4174             ; -----------------------------------------------------------------------------
0494+  4174             ; Output: A  = 1
0495+  4174             ;         Cy = 1 on error
0496+  4174             
0497+  4174             HW_BUS_RESET:
0498+  4174 3E 07           ld a,7
0499+  4176 CD 72 44        call CH_SET_USB_MODE
0500+  4179 3E 01           ld a,1
0501+  417B D8              ret c
0502+  417C             
0503+  417C                 if USING_ARDUINO_BOARD = 0
0504+  417C 01 96 00        ld bc,150
0505+  417F CD 8D 41        call CH_DELAY
0506+  4182                 endif
0507+  4182             
0508+  4182 3E 06           ld a,6
0509+  4184 CD 72 44        call CH_SET_USB_MODE
0510+  4187             
0511+  4187 3E 01           ld a,1
0512+  4189 D8              ret c
0513+  418A             
0514+  418A AF              xor a
0515+  418B 3C              inc a
0516+  418C C9              ret
0517+  418D             
0518+  418D                 ;Input: BC = Delay duration in units of 0.1ms
0519+  418D             CH_DELAY:
0520+  418D 3E 0F           ld a,CH_CMD_DELAY_100US
0521+  418F D3 21           out (CH_COMMAND_PORT),a
0522+  4191             _CH_DELAY_LOOP:
0523+  4191 DB 20           in a,(CH_DATA_PORT)
0524+  4193 B7              or a
0525+  4194 28 FB           jr z,_CH_DELAY_LOOP 
0526+  4196 0B              dec bc
0527+  4197 78              ld a,b
0528+  4198 B1              or c
0529+  4199 20 F2           jr nz,CH_DELAY
0530+  419B C9              ret
0531+  419C             
0532+  419C             
0533+  419C             ; -----------------------------------------------------------------------------
0534+  419C             ; File management routines
0535+  419C             ; -----------------------------------------------------------------------------    
0536+  419C             
0537+  419C             ; -----------------------------------------------------------------------------
0538+  419C             ; HWF_MOUNT_DISK: Mounts a storage device if present.
0539+  419C             ;
0540+  419C             ; On success it also opens the root directory
0541+  419C             ; -----------------------------------------------------------------------------
0542+  419C             ; Input:  HL = address for the name of the device found
0543+  419C             ; Output: Cy = 0: ok
0544+  419C             ;              1: error, no device present or it's not a storage device
0545+  419C             
0546+  419C             HWF_MOUNT_DISK:
0547+  419C                 if USE_FAKE_STORAGE_DEVICE=1
0548+  419C~            
0549+  419C~                ex de,hl
0550+  419C~                ld hl,FAKE_DEV_NAME
0551+  419C~                ld bc,24
0552+  419C~                ldir
0553+  419C~                xor a
0554+  419C~                ld (de),a
0555+  419C~                ret
0556+  419C~            
0557+  419C~            FAKE_DEV_NAME:
0558+  419C~                db "TheStorageThing     0.05"
0559+  419C~            
0560+  419C                 endif
0561+  419C             
0562+  419C 3E 30           ld a,CH_CMD_DISK_CONNECT
0563+  419E D3 21           out (CH_COMMAND_PORT),a
0564+  41A0 CD 01 44        call CH_WAIT_INT_AND_GET_RESULT
0565+  41A3 FE 00           cp USB_ERR_OK
0566+  41A5 37              scf
0567+  41A6 C0              ret nz
0568+  41A7             
0569+  41A7 3E 06           ld a,6
0570+  41A9 CD 72 44        call CH_SET_USB_MODE
0571+  41AC             
0572+  41AC 3E 31           ld a,CH_CMD_DISK_MOUNT
0573+  41AE D3 21           out (CH_COMMAND_PORT),a
0574+  41B0 CD 01 44        call CH_WAIT_INT_AND_GET_RESULT
0575+  41B3 FE 00           cp USB_ERR_OK
0576+  41B5 37              scf
0577+  41B6 C0              ret nz
0578+  41B7             
0579+  41B7 E5              push hl
0580+  41B8 CD A9 44        call CH_READ_DATA
0581+  41BB E1              pop hl
0582+  41BC 54              ld d,h
0583+  41BD 5D              ld e,l
0584+  41BE 01 08 00        ld bc,8
0585+  41C1 09              add hl,bc
0586+  41C2 01 1C 00        ld bc,36-8
0587+  41C5 ED B0           ldir
0588+  41C7 AF              xor a
0589+  41C8 12              ld (de),a
0590+  41C9             
0591+  41C9 C9              ret
0592+  41CA             
0593+  41CA             
0594+  41CA             ; -----------------------------------------------------------------------------
0595+  41CA             ; HWF_OPEN_FILE_DIR: Open a file or enter a directory from the current one
0596+  41CA             ; -----------------------------------------------------------------------------
0597+  41CA             ; Input:  HL = Address of file or directory name, relative to current
0598+  41CA             ; Output: A  = 0: ok, file or directory open
0599+  41CA             ;              1: generic error (e.g. no device found)
0600+  41CA             ;              2: file or directory not found
0601+  41CA             ;              
0602+  41CA             ;         Cy = 0: file open (if no error)
0603+  41CA             ;              1: directory open (if no error)
0604+  41CA             ;         Z if ok, NZ if error
0605+  41CA             ;         HL = Pointer to terminator of file or directory name
0606+  41CA             
0607+  41CA             HWF_OPEN_FILE_DIR:
0608+  41CA                 if USE_FAKE_STORAGE_DEVICE=1
0609+  41CA~            
0610+  41CA~                ;ld a,27
0611+  41CA~                ;call CHPUT
0612+  41CA~                ;ld a,'j'
0613+  41CA~                ;call CHPUT
0614+  41CA~                ;call PRINT
0615+  41CA~                xor a
0616+  41CA~                ret
0617+  41CA~            
0618+  41CA                 endif
0619+  41CA             
0620+  41CA 3E 2F           ld a,CH_CMD_SET_FILE_NAME
0621+  41CC D3 21           out (CH_COMMAND_PORT),a
0622+  41CE CD D3 44        call CH_WRITE_STRING
0623+  41D1             
0624+  41D1 E5              push hl
0625+  41D2 3E 32           ld a,CH_CMD_FILE_OPEN
0626+  41D4 D3 21           out (CH_COMMAND_PORT),a
0627+  41D6 CD 01 44        call CH_WAIT_INT_AND_GET_RESULT
0628+  41D9 E1              pop hl
0629+  41DA             
0630+  41DA 47              ld b,a
0631+  41DB FE 00           cp USB_ERR_OK
0632+  41DD 3E 00           ld a,0
0633+  41DF 37              scf
0634+  41E0 3F              ccf
0635+  41E1 C8              ret z   ;NC, Z
0636+  41E2             
0637+  41E2 78              ld a,b
0638+  41E3 FE 41           cp USB_ERR_OPEN_DIR
0639+  41E5 3E 00           ld a,0
0640+  41E7 37              scf
0641+  41E8 C8              ret z   ;C, Z
0642+  41E9             
0643+  41E9 78              ld a,b
0644+  41EA FE 42           cp USB_ERR_MISS_FILE
0645+  41EC 3E 02           ld a,2
0646+  41EE 28 01           jr z,_HWF_OPEN_FILE_DIR_END
0647+  41F0 3D              dec a
0648+  41F1             
0649+  41F1             _HWF_OPEN_FILE_DIR_END:
0650+  41F1 B7              or a    ;Force NZ
0651+  41F2 C9              ret
0652+  41F3             
0653+  41F3             
0654+  41F3             ; -----------------------------------------------------------------------------
0655+  41F3             ; HWF_CREATE_FILE: Create a new file in current directory, overwrite if exists
0656+  41F3             ; -----------------------------------------------------------------------------
0657+  41F3             ; Input:  HL = Address of file or directory name, relative to current
0658+  41F3             ; Output: A  = 0: ok, file open
0659+  41F3             ;              1: error (might be that a directory with the same name exists)
0660+  41F3             
0661+  41F3             HWF_CREATE_FILE:
0662+  41F3                 if 0
0663+  41F3~            
0664+  41F3~                push hl
0665+  41F3~                call HWF_CLOSE_FILE
0666+  41F3~                pop hl
0667+  41F3~            
0668+  41F3~                push hl
0669+  41F3~                ld a,CH_CMD_SET_FILE_NAME
0670+  41F3~                out (CH_COMMAND_PORT),a
0671+  41F3~                call CH_WRITE_STRING
0672+  41F3~                ld a,CH_CMD_FILE_ERASE
0673+  41F3~                out (CH_COMMAND_PORT),a
0674+  41F3~                call CH_WAIT_INT_AND_GET_RESULT
0675+  41F3~                pop hl
0676+  41F3~                
0677+  41F3                 endif
0678+  41F3             
0679+  41F3 3E 2F           ld a,CH_CMD_SET_FILE_NAME
0680+  41F5 D3 21           out (CH_COMMAND_PORT),a
0681+  41F7 CD D3 44        call CH_WRITE_STRING
0682+  41FA             
0683+  41FA 3E 34           ld a,CH_CMD_FILE_CREATE
0684+  41FC D3 21           out (CH_COMMAND_PORT),a
0685+  41FE CD 01 44        call CH_WAIT_INT_AND_GET_RESULT
0686+  4201             
0687+  4201 FE 00           cp USB_ERR_OK
0688+  4203 3E 00           ld a,0
0689+  4205 C8              ret z
0690+  4206 3C              inc a
0691+  4207 C9              ret
0692+  4208             
0693+  4208             
0694+  4208             ; -----------------------------------------------------------------------------
0695+  4208             ; HWF_CREATE_DIR: Create a new directory in current directory, open if exists
0696+  4208             ; -----------------------------------------------------------------------------
0697+  4208             ; Input:  HL = Address of file or directory name, relative to current
0698+  4208             ; Output: A  = 0: ok, file open
0699+  4208             ;              1: error (might be that a file with the same name exists)
0700+  4208             
0701+  4208             HWF_CREATE_DIR:
0702+  4208 3E 2F           ld a,CH_CMD_SET_FILE_NAME
0703+  420A D3 21           out (CH_COMMAND_PORT),a
0704+  420C CD D3 44        call CH_WRITE_STRING
0705+  420F             
0706+  420F 3E 40           ld a,CH_CMD_DIR_CREATE
0707+  4211 D3 21           out (CH_COMMAND_PORT),a
0708+  4213 CD 01 44        call CH_WAIT_INT_AND_GET_RESULT
0709+  4216             
0710+  4216 FE 00           cp USB_ERR_OK
0711+  4218 3E 00           ld a,0
0712+  421A C8              ret z
0713+  421B 3C              inc a
0714+  421C C9              ret
0715+  421D             
0716+  421D             
0717+  421D             ; -----------------------------------------------------------------------------
0718+  421D             ; HWF_CLOSE_FILE: Close open file or directory, update size in dir entry
0719+  421D             ; -----------------------------------------------------------------------------
0720+  421D             
0721+  421D             HWF_CLOSE_FILE:
0722+  421D 3E 36           ld a,CH_CMD_FILE_CLOSE
0723+  421F D3 21           out (CH_COMMAND_PORT),a
0724+  4221 3E 01           ld a,1
0725+  4223 D3 20           out (CH_DATA_PORT),a
0726+  4225 C3 01 44        jp CH_WAIT_INT_AND_GET_RESULT
0727+  4228             
0728+  4228             
0729+  4228             ; -----------------------------------------------------------------------------
0730+  4228             ; HWF_DELETE_FILE: Delete file or directory
0731+  4228             ; -----------------------------------------------------------------------------
0732+  4228             ; Input:  HL = File or directory name
0733+  4228             ; Output: A  = 0: Ok
0734+  4228             ;              1: Error
0735+  4228             
0736+  4228             HWF_DELETE_FILE:
0737+  4228                 ;Very important: close any open file first, or it will be deleted!
0738+  4228 E5              push hl
0739+  4229 CD 1D 42        call HWF_CLOSE_FILE
0740+  422C E1              pop hl
0741+  422D             
0742+  422D 3E 2F           ld a,CH_CMD_SET_FILE_NAME
0743+  422F D3 21           out (CH_COMMAND_PORT),a
0744+  4231 CD D3 44        call CH_WRITE_STRING
0745+  4234             
0746+  4234 3E 35           ld a,CH_CMD_FILE_ERASE
0747+  4236 D3 21           out (CH_COMMAND_PORT),a
0748+  4238 CD 01 44        call CH_WAIT_INT_AND_GET_RESULT
0749+  423B B7              or a
0750+  423C C8              ret z
0751+  423D 3E 01           ld a,1
0752+  423F C9              ret
0753+  4240             
0754+  4240             
0755+  4240             ; -----------------------------------------------------------------------------
0756+  4240             ; HWF_ENUM_FILES: Enumerate files and directories in the current directory
0757+  4240             ;
0758+  4240             ; Files/directories whose first character is "_" will be skipped.
0759+  4240             ;
0760+  4240             ; The name of each files/directory will be put at the specified address,
0761+  4240             ; sequentially and with no separators, as a fixed 11 bytes string in the
0762+  4240             ; same format as in the directory entry (e.g. "FILE    EXT"); after the last
0763+  4240             ; entry a 0 byte will be placed.
0764+  4240             ; -----------------------------------------------------------------------------
0765+  4240             ; Input:  HL = Address of buffer to get file info into
0766+  4240             ;         BC = Maximum number of files/directories to enumerate
0767+  4240             ; Output: HL = Pointer to the 0 byte at the end of the list
0768+  4240             ;         BC = Number of filenames found
0769+  4240             
0770+  4240             HWF_ENUM_FILES:
0771+  4240                 if USE_FAKE_STORAGE_DEVICE = 1
0772+  4240~            
0773+  4240~                push bc
0774+  4240~                call _HWF_ENUM_FILES
0775+  4240~                pop bc
0776+  4240~                ret
0777+  4240~            
0778+  4240~            _HWF_ENUM_FILES:
0779+  4240~                ld de,0
0780+  4240~                push hl
0781+  4240~                pop ix
0782+  4240~            _HWF_ENUM_FILES_LOOP:
0783+  4240~                push bc
0784+  4240~                push de
0785+  4240~            
0786+  4240~                push ix
0787+  4240~                pop de
0788+  4240~            
0789+  4240~                ld hl,FILE_S
0790+  4240~                ld bc,3
0791+  4240~                ldir
0792+  4240~            
0793+  4240~                pop hl
0794+  4240~                push hl
0795+  4240~                call Num2Hex
0796+  4240~                
0797+  4240~                ld a,' '
0798+  4240~                ld (de),a
0799+  4240~                inc de
0800+  4240~            
0801+  4240~                ld hl,EXT_S
0802+  4240~                ld bc,3
0803+  4240~                ldir
0804+  4240~            
0805+  4240~                push de
0806+  4240~                pop ix
0807+  4240~            
0808+  4240~                pop de
0809+  4240~                inc de
0810+  4240~            
0811+  4240~                ld a,e
0812+  4240~                and 15
0813+  4240~                jr nz,_HWF_ENUM_FILES_NODIR
0814+  4240~                ld (ix-4),' '
0815+  4240~                ld (ix-3),' '
0816+  4240~                ld (ix-2),' '
0817+  4240~                ld (ix-1),128+32    ;Space with bit 7 set
0818+  4240~            _HWF_ENUM_FILES_NODIR:
0819+  4240~            
0820+  4240~                pop bc
0821+  4240~                dec bc
0822+  4240~                ld a,b
0823+  4240~                or c
0824+  4240~                jr nz,_HWF_ENUM_FILES_LOOP
0825+  4240~            
0826+  4240~                xor a
0827+  4240~                ld (ix),a
0828+  4240~                push ix
0829+  4240~                pop hl
0830+  4240~                ret
0831+  4240~            
0832+  4240~            FILE_S: db "FIL"
0833+  4240~            EXT_S: db "EXT"
0834+  4240~            
0835+  4240~            ;Input: HL = number to convert
0836+  4240~            ;       DE = location of ASCII string
0837+  4240~            Num2Hex:
0838+  4240~            	ld	a,h
0839+  4240~            	call	Num1
0840+  4240~            	ld	a,h
0841+  4240~            	call	Num2
0842+  4240~            	ld	a,l
0843+  4240~            	call	Num1
0844+  4240~            	ld	a,l
0845+  4240~            	jr	Num2
0846+  4240~            
0847+  4240~            Num1:
0848+  4240~            	rra
0849+  4240~            	rra
0850+  4240~            	rra
0851+  4240~            	rra
0852+  4240~            Num2:
0853+  4240~            	or	0F0h
0854+  4240~            	daa
0855+  4240~            	add	a,0A0h
0856+  4240~            	adc	a,040h
0857+  4240~            
0858+  4240~            	ld	(de),a
0859+  4240~            	inc	de
0860+  4240~            	ret
0861+  4240~            
0862+  4240                 endif
0863+  4240             
0864+  4240 FD E5           push iy
0865+  4242 FD 21 00 00     ld iy,0
0866+  4246 CD 64 42        call _HWF_ENUM_FILES_CORE
0867+  4249 FD E1           pop iy
0868+  424B C9              ret
0869+  424C             
0870+  424C             
0871+  424C             ; -----------------------------------------------------------------------------
0872+  424C             ; HWF_FIND_NTH_FILE: Find the Nth file in the current directory
0873+  424C             ;
0874+  424C             ; Files whose first character is "_" will be skipped.
0875+  424C             ;
0876+  424C             ; The name of the files will be put at the specified address,
0877+  424C             ; sequentially and with no separators, as a fixed 11 bytes string in the
0878+  424C             ; same format as in the directory entry (e.g. "FILE    EXT").
0879+  424C             ; -----------------------------------------------------------------------------
0880+  424C             ; Input:  HL = Address of buffer to get file info into
0881+  424C             ;         A  = Index of file to find (first is 0)
0882+  424C             ; Output: A  = 0: Ok
0883+  424C             ;              1: Generic error
0884+  424C             ;              2: File not found
0885+  424C             ;         HL = Pointer after the filename
0886+  424C             
0887+  424C             HWF_FIND_NTH_FILE:
0888+  424C FD E5           push iy
0889+  424E FD 21 01 00     ld iy,1
0890+  4252 4F              ld c,a
0891+  4253 06 00           ld b,0
0892+  4255 03              inc bc
0893+  4256 CD 64 42        call _HWF_ENUM_FILES_CORE
0894+  4259 FD E1           pop iy
0895+  425B B7              or a
0896+  425C C8              ret z
0897+  425D FE 42           cp USB_ERR_MISS_FILE
0898+  425F 3E 02           ld a,2
0899+  4261 C8              ret z
0900+  4262 3D              dec a
0901+  4263 C9              ret
0902+  4264             
0903+  4264             _HWF_ENUM_FILES_CORE:
0904+  4264                 if USE_FAKE_STORAGE_DEVICE = 0
0905+  4264             
0906+  4264 3E 2F           ld a,CH_CMD_SET_FILE_NAME
0907+  4266 D3 21           out (CH_COMMAND_PORT),a
0908+  4268 3E 2A           ld a,'*'
0909+  426A D3 20           out (CH_DATA_PORT),a
0910+  426C AF              xor a
0911+  426D D3 20           out (CH_DATA_PORT),a
0912+  426F             
0913+  426F 11 00 00        ld de,0     ;Number of files found
0914+  4272 3E 32           ld a,CH_CMD_FILE_OPEN
0915+  4274 D3 21           out (CH_COMMAND_PORT),a
0916+  4276             _HWF_ENUM_FILES_LOOP:
0917+  4276 E5              push hl
0918+  4277 D5              push de
0919+  4278 C5              push bc
0920+  4279 CD 01 44        call CH_WAIT_INT_AND_GET_RESULT
0921+  427C C1              pop bc
0922+  427D D1              pop de
0923+  427E E1              pop hl
0924+  427F FE 1D           cp CH_ST_INT_DISK_READ
0925+  4281 20 48           jr nz,_HWF_ENUM_FILES_END
0926+  4283             
0927+  4283 C5              push bc
0928+  4284 E5              push hl
0929+  4285 D5              push de
0930+  4286 CD A9 44        call CH_READ_DATA
0931+  4289 D1              pop de
0932+  428A E1              pop hl
0933+  428B C1              pop bc
0934+  428C             
0935+  428C 7E              ld a,(hl)
0936+  428D FE 5F           cp "_"
0937+  428F 28 33           jr z,_HWF_ENUM_DIR_NEXT
0938+  4291 FE 2E           cp "."  ;Skip "." and ".." entries
0939+  4293 28 2F           jr z,_HWF_ENUM_DIR_NEXT
0940+  4295             
0941+  4295 C5              push bc
0942+  4296 01 0B 00        ld bc,11
0943+  4299 09              add hl,bc ;Point to file attributes byte
0944+  429A C1              pop bc
0945+  429B             
0946+  429B 7E              ld a,(hl)
0947+  429C E6 0E           and 1110b   ;"Hidden", "System" or "Volume" attribute set?
0948+  429E 20 09           jr nz,_HWF_ENUM_SKIP
0949+  42A0 FD 7D           ld a,iyl
0950+  42A2 B7              or a
0951+  42A3 28 0C           jr z,_HWF_ENUM_USE
0952+  42A5 CB 66           bit 4,(hl)  ;"Directory" attribute set?
0953+  42A7 28 10           jr z,_HWF_ENUM_DIR_OK
0954+  42A9             
0955+  42A9             _HWF_ENUM_SKIP:
0956+  42A9 C5              push bc
0957+  42AA 01 F5 FF        ld bc,-11
0958+  42AD 09              add hl,bc
0959+  42AE C1              pop bc
0960+  42AF 18 13           jr _HWF_ENUM_DIR_NEXT
0961+  42B1             
0962+  42B1             _HWF_ENUM_USE:
0963+  42B1 CB 66           bit 4,(hl)  ;"Directory" attribute set?
0964+  42B3 28 04           jr z,_HWF_ENUM_DIR_OK
0965+  42B5 2B              dec hl
0966+  42B6 CB FE           set 7,(hl)
0967+  42B8 23              inc hl
0968+  42B9             _HWF_ENUM_DIR_OK:
0969+  42B9             
0970+  42B9 13              inc de
0971+  42BA             
0972+  42BA 0B              dec bc
0973+  42BB 78              ld a,b
0974+  42BC B1              or c
0975+  42BD 28 0C           jr z,_HWF_ENUM_FILES_END
0976+  42BF             
0977+  42BF FD 7D           ld a,iyl
0978+  42C1 B7              or a
0979+  42C2 20 E5           jr nz,_HWF_ENUM_SKIP
0980+  42C4             
0981+  42C4             _HWF_ENUM_DIR_NEXT:
0982+  42C4 3E 33           ld a,CH_CMD_FILE_ENUM_GO
0983+  42C6 D3 21           out (CH_COMMAND_PORT),a
0984+  42C8 C3 76 42        jp _HWF_ENUM_FILES_LOOP
0985+  42CB             
0986+  42CB             _HWF_ENUM_FILES_END:
0987+  42CB F5              push af
0988+  42CC FD 7D           ld a,iyl
0989+  42CE B7              or a
0990+  42CF 20 02           jr nz,_HWF_ENUM_FILES_END_2
0991+  42D1 36 00           ld (hl),0
0992+  42D3             _HWF_ENUM_FILES_END_2:
0993+  42D3 F1              pop af    
0994+  42D4 D5              push de
0995+  42D5 C1              pop bc
0996+  42D6 C9              ret
0997+  42D7             
0998+  42D7                 endif
0999+  42D7             
1000+  42D7             
1001+  42D7             ; -----------------------------------------------------------------------------
1002+  42D7             ; HWF_SEEK_FILE: Move the pointer of the currently mounted file
1003+  42D7             ; -----------------------------------------------------------------------------
1004+  42D7             ; Input:  HL:DE = New pointer
1005+  42D7             ; Output: A = 0: Ok
1006+  42D7             ;             1: End of file
1007+  42D7             ;             2: Other error
1008+  42D7             
1009+  42D7             HWF_SEEK_FILE:
1010+  42D7                 if USE_FAKE_STORAGE_DEVICE = 1
1011+  42D7~                xor a
1012+  42D7~                ret
1013+  42D7                 endif
1014+  42D7             
1015+  42D7 3E 39           ld a,CH_CMD_BYTE_LOCATE
1016+  42D9 D3 21           out (CH_COMMAND_PORT),a
1017+  42DB 7B              ld a,e
1018+  42DC D3 20           out (CH_DATA_PORT),a
1019+  42DE 7A              ld a,d
1020+  42DF D3 20           out (CH_DATA_PORT),a
1021+  42E1 7D              ld a,l
1022+  42E2 D3 20           out (CH_DATA_PORT),a
1023+  42E4 7C              ld a,h
1024+  42E5 D3 20           out (CH_DATA_PORT),a
1025+  42E7             
1026+  42E7 CD 01 44        call CH_WAIT_INT_AND_GET_RESULT
1027+  42EA B7              or a
1028+  42EB 3E 02           ld a,2
1029+  42ED C0              ret nz
1030+  42EE             
1031+  42EE 3E 27           ld a,CH_CMD_RD_USB_DATA0
1032+  42F0 D3 21           out (CH_COMMAND_PORT),a
1033+  42F2 DB 20           in a,(CH_DATA_PORT)
1034+  42F4 FE 04           cp 4
1035+  42F6 3E 02           ld a,2
1036+  42F8 C0              ret nz
1037+  42F9             
1038+  42F9                 ;Read the current pointer, if it's FFFFFFFFh return end of file error
1039+  42F9 06 04           ld b,4
1040+  42FB 0E FF           ld c,0FFh
1041+  42FD             _HWF_SEEK_FILE_CUR_POINTER:
1042+  42FD DB 20           in a,(CH_DATA_PORT)
1043+  42FF A1              and c
1044+  4300 4F              ld c,a
1045+  4301 10 FA           djnz _HWF_SEEK_FILE_CUR_POINTER
1046+  4303             
1047+  4303 79              ld a,c
1048+  4304 3C              inc a
1049+  4305 3E 01           ld a,1
1050+  4307 C8              ret z
1051+  4308 3D              dec a
1052+  4309 C9              ret
1053+  430A             
1054+  430A             
1055+  430A             ; -----------------------------------------------------------------------------
1056+  430A             ; HWF_READ_FILE: Read the currently mounted file
1057+  430A             ; -----------------------------------------------------------------------------
1058+  430A             ; Input:  BC = How many bytes to read
1059+  430A             ;         HL = Destination address
1060+  430A             ; Output: A  = 0: Ok
1061+  430A             ;              1: Error
1062+  430A             ;         BC = How many bytes actually read
1063+  430A             ;         HL = Address after last byte read
1064+  430A             
1065+  430A             HWF_READ_FILE:
1066+  430A                 if USE_FAKE_STORAGE_DEVICE=1
1067+  430A~                ld a,1
1068+  430A~                ld bc,2048
1069+  430A~                ret
1070+  430A                 endif
1071+  430A             
1072+  430A E5              push hl
1073+  430B E5              push hl
1074+  430C 3E 3A           ld a,CH_CMD_BYTE_READ
1075+  430E D3 21           out (CH_COMMAND_PORT),a
1076+  4310 79              ld a,c
1077+  4311 D3 20           out (CH_DATA_PORT),a
1078+  4313 78              ld a,b
1079+  4314 D3 20           out (CH_DATA_PORT),a
1080+  4316             
1081+  4316             _HWF_READ_FILE_LOOP:
1082+  4316 CD 01 44        call CH_WAIT_INT_AND_GET_RESULT
1083+  4319 B7              or a
1084+  431A 28 11           jr z,_HWF_READ_FILE_END
1085+  431C FE 1D           cp CH_ST_INT_DISK_READ
1086+  431E 3E 01           ld a,1
1087+  4320 20 0B           jr nz,_HWF_READ_FILE_END
1088+  4322             
1089+  4322 E1              pop hl
1090+  4323 CD A9 44        call CH_READ_DATA
1091+  4326 E5              push hl
1092+  4327             
1093+  4327 3E 3B           ld a,CH_CMD_BYTE_RD_GO
1094+  4329 D3 21           out (CH_COMMAND_PORT),a
1095+  432B             
1096+  432B 18 E9           jr _HWF_READ_FILE_LOOP
1097+  432D             
1098+  432D             _HWF_READ_FILE_END:
1099+  432D E1              pop hl  ;Address after the last byte retrieved
1100+  432E D1              pop de  ;Initial dest address
1101+  432F E5              push hl
1102+  4330 B7              or a
1103+  4331 ED 52           sbc hl,de
1104+  4333 E5              push hl
1105+  4334 C1              pop bc
1106+  4335 E1              pop hl
1107+  4336 C9              ret
1108+  4337             
1109+  4337             
1110+  4337             ; -----------------------------------------------------------------------------
1111+  4337             ; HWF_WRITE_FILE: Write to the currently mounted file
1112+  4337             ; -----------------------------------------------------------------------------
1113+  4337             ; Input:  BC = How many bytes to write
1114+  4337             ;         HL = Source address
1115+  4337             ; Output: A  = 0: Ok
1116+  4337             ;              1: Error
1117+  4337             ;         BC = How many bytes actually read
1118+  4337             ;         HL = Address after last byte written
1119+  4337             
1120+  4337             HWF_WRITE_FILE:
1121+  4337                 if USE_FAKE_STORAGE_DEVICE=1
1122+  4337~                ld a,1
1123+  4337~                ld bc,2048
1124+  4337~                ret
1125+  4337                 endif
1126+  4337             
1127+  4337 E5              push hl
1128+  4338 E5              push hl
1129+  4339 3E 3C           ld a,CH_CMD_BYTE_WRITE
1130+  433B D3 21           out (CH_COMMAND_PORT),a
1131+  433D 79              ld a,c
1132+  433E D3 20           out (CH_DATA_PORT),a
1133+  4340 78              ld a,b
1134+  4341 D3 20           out (CH_DATA_PORT),a
1135+  4343             
1136+  4343             _HWF_WRITE_FILE_LOOP:
1137+  4343 CD 01 44        call CH_WAIT_INT_AND_GET_RESULT
1138+  4346 B7              or a
1139+  4347 28 19           jr z,_HWF_WRITE_FILE_END
1140+  4349 FE 1E           cp CH_ST_INT_DISK_WRITE
1141+  434B 3E 01           ld a,1
1142+  434D 20 13           jr nz,_HWF_WRITE_FILE_END
1143+  434F             
1144+  434F 3E 2D           ld a,CH_CMD_WR_REQ_DATA
1145+  4351 D3 21           out (CH_COMMAND_PORT),a
1146+  4353 DB 20           in a,(CH_DATA_PORT)
1147+  4355 47              ld b,a
1148+  4356             
1149+  4356 E1              pop hl
1150+  4357 0E 20           ld c,CH_DATA_PORT
1151+  4359 ED B3           otir
1152+  435B E5              push hl
1153+  435C             
1154+  435C 3E 3D           ld a,CH_CMD_BYTE_WRITE_GO
1155+  435E D3 21           out (CH_COMMAND_PORT),a
1156+  4360             
1157+  4360 18 E1           jr _HWF_WRITE_FILE_LOOP
1158+  4362             
1159+  4362             _HWF_WRITE_FILE_END:
1160+  4362 F5              push af
1161+  4363 3E 3C           ld a,CH_CMD_BYTE_WRITE
1162+  4365 D3 21           out (CH_COMMAND_PORT),a
1163+  4367 AF              xor a
1164+  4368 D3 20           out (CH_DATA_PORT),a
1165+  436A D3 20           out (CH_DATA_PORT),a
1166+  436C F1              pop af
1167+  436D             
1168+  436D E1              pop hl  ;Address after the last byte written
1169+  436E D1              pop de  ;Initial src address
1170+  436F E5              push hl
1171+  4370 B7              or a
1172+  4371 ED 52           sbc hl,de
1173+  4373 E5              push hl
1174+  4374 C1              pop bc
1175+  4375 E1              pop hl
1176+  4376 C9              ret
1177+  4377             
1178+  4377             
1179+  4377             ; -----------------------------------------------------------------------------
1180+  4377             ; HWF_GET_FILE_ATTR: Get attributes byte of currently mounted file
1181+  4377             ; -----------------------------------------------------------------------------
1182+  4377             ; Output: A  = 0: Ok
1183+  4377             ;              1: Error
1184+  4377             ;         B  = Attributes byte if ok
1185+  4377             
1186+  4377             HWF_GET_FILE_ATTR:
1187+  4377 3E 37           ld a,CH_CMD_DIR_INFO_READ
1188+  4379 D3 21           out (CH_COMMAND_PORT),a
1189+  437B 3E FF           ld a,0FFh
1190+  437D D3 20           out (CH_DATA_PORT),a
1191+  437F E5              push hl
1192+  4380 C5              push bc
1193+  4381 CD 01 44        call CH_WAIT_INT_AND_GET_RESULT
1194+  4384 C1              pop bc
1195+  4385 E1              pop hl
1196+  4386 FE 00           cp USB_ERR_OK
1197+  4388 3E 01           ld a,1
1198+  438A C0              ret nz
1199+  438B             
1200+  438B 3E 27           ld a,CH_CMD_RD_USB_DATA0
1201+  438D D3 21           out (CH_COMMAND_PORT),a
1202+  438F 0E 20           ld c,CH_DATA_PORT
1203+  4391 06 0C           ld b,11+1   ;Discard bytes counter and filename
1204+  4393 CD BF 44        call _CH_READ_DISCARD_DATA_LOOP
1205+  4396 ED 78           in a,(c)    ;Attributes byte
1206+  4398 5F              ld e,a
1207+  4399 06 14           ld b,20     ;Discard the rest of the directory info
1208+  439B CD BF 44        call _CH_READ_DISCARD_DATA_LOOP
1209+  439E AF              xor a
1210+  439F 43              ld b,e
1211+  43A0 C9              ret
1212+  43A1             
1213+  43A1             
1214+  43A1             ; -----------------------------------------------------------------------------
1215+  43A1             ; Optional shortcut routines
1216+  43A1             ; -----------------------------------------------------------------------------    
1217+  43A1             
1218+  43A1             ; -----------------------------------------------------------------------------
1219+  43A1             ; HW_GET_DEV_DESCR and HW_GET_CONFIG_DESCR
1220+  43A1             ;
1221+  43A1             ; Exectute the standard GET_DESCRIPTOR USB request
1222+  43A1             ; to obtain the device descriptor or the configuration descriptor.
1223+  43A1             ; -----------------------------------------------------------------------------
1224+  43A1             ; Input:  DE = Address where the descriptor is to be read
1225+  43A1             ;         A  = Device address
1226+  43A1             ; Output: A  = USB error code
1227+  43A1             
1228+  43A1                 if HW_IMPL_GET_DEV_DESCR = 1
1229+  43A1                 
1230+  43A1             HW_GET_DEV_DESCR:
1231+  43A1 06 01           ld b,1
1232+  43A3 18 04           jr CH_GET_DESCR
1233+  43A5             
1234+  43A5                 endif
1235+  43A5             
1236+  43A5                 if HW_IMPL_GET_CONFIG_DESCR = 1
1237+  43A5             
1238+  43A5             HW_GET_CONFIG_DESCR:
1239+  43A5 06 02           ld b,2
1240+  43A7 18 00           jr CH_GET_DESCR
1241+  43A9             
1242+  43A9                 endif
1243+  43A9             
1244+  43A9                 if HW_IMPL_GET_DEV_DESCR = 1 or HW_IMPL_GET_CONFIG_DESCR = 1
1245+  43A9             
1246+  43A9             CH_GET_DESCR:
1247+  43A9 C5              push bc
1248+  43AA CD 8D 44        call CH_SET_TARGET_DEVICE_ADDRESS
1249+  43AD                 
1250+  43AD 3E 46           ld a,CH_CMD_GET_DESCR
1251+  43AF D3 21           out (CH_COMMAND_PORT),a
1252+  43B1 F1              pop af
1253+  43B2 D3 20           out (CH_DATA_PORT),a
1254+  43B4             
1255+  43B4 D5              push de
1256+  43B5 CD 01 44        call CH_WAIT_INT_AND_GET_RESULT
1257+  43B8 E1              pop hl
1258+  43B9 B7              or a
1259+  43BA C0              ret nz
1260+  43BB             
1261+  43BB CD A9 44        call CH_READ_DATA
1262+  43BE 06 00           ld b,0
1263+  43C0 AF              xor a
1264+  43C1 C9              ret
1265+  43C2             
1266+  43C2                 endif
1267+  43C2             
1268+  43C2             
1269+  43C2             ; -----------------------------------------------------------------------------
1270+  43C2             ; HW_SET_CONFIG
1271+  43C2             ;
1272+  43C2             ; Exectute the standard SET_CONFIGURATION USB request.
1273+  43C2             ; -----------------------------------------------------------------------------
1274+  43C2             ; Input: A = Device address
1275+  43C2             ;        B = Configuration number to assign
1276+  43C2             
1277+  43C2                 if HW_IMPL_SET_CONFIG = 1
1278+  43C2             
1279+  43C2                 ;In: A=Address, B=Config number
1280+  43C2             HW_SET_CONFIG:
1281+  43C2 CD 8D 44        call CH_SET_TARGET_DEVICE_ADDRESS
1282+  43C5 3E 49           ld a,CH_CMD_SET_CONFIG
1283+  43C7 D3 21           out (CH_COMMAND_PORT),a
1284+  43C9 78              ld a,b
1285+  43CA D3 20           out (CH_DATA_PORT),a
1286+  43CC             
1287+  43CC CD 01 44        call CH_WAIT_INT_AND_GET_RESULT
1288+  43CF C9              ret
1289+  43D0             
1290+  43D0                 endif
1291+  43D0             
1292+  43D0             
1293+  43D0             ; -----------------------------------------------------------------------------
1294+  43D0             ; HW_SET_ADDRESS
1295+  43D0             ;
1296+  43D0             ; Exectute the standard SET_ADDRESS USB request.
1297+  43D0             ; -----------------------------------------------------------------------------
1298+  43D0             ; Input: A = Adress to assign
1299+  43D0             
1300+  43D0                 if HW_IMPL_SET_ADDRESS = 1
1301+  43D0             
1302+  43D0             HW_SET_ADDRESS:
1303+  43D0 F5              push af
1304+  43D1 AF              xor a
1305+  43D2 CD 8D 44        call CH_SET_TARGET_DEVICE_ADDRESS
1306+  43D5 3E 45           ld a,CH_CMD_SET_ADDRESS
1307+  43D7 D3 21           out (CH_COMMAND_PORT),a
1308+  43D9 F1              pop af
1309+  43DA D3 20           out (CH_DATA_PORT),a
1310+  43DC             
1311+  43DC CD 01 44        call CH_WAIT_INT_AND_GET_RESULT
1312+  43DF C9              ret
1313+  43E0             
1314+  43E0                 endif    
1315+  43E0             
1316+  43E0             
1317+  43E0             ; -----------------------------------------------------------------------------
1318+  43E0             ; HW_CONFIGURE_NAK_RETRY
1319+  43E0             ; -----------------------------------------------------------------------------
1320+  43E0             ; Input: Cy = 0 to retry for a limited time when the device returns NAK
1321+  43E0             ;               (this is the default)
1322+  43E0             ;             1 to retry indefinitely (or for a long time) 
1323+  43E0             ;               when the device returns NAK 
1324+  43E0             
1325+  43E0             HW_CONFIGURE_NAK_RETRY:
1326+  43E0 3E FF           ld a,0FFh
1327+  43E2 30 02           jr nc,_HW_CONFIGURE_NAK_RETRY_2
1328+  43E4 3E BF           ld a,0BFh
1329+  43E6             _HW_CONFIGURE_NAK_RETRY_2:
1330+  43E6 F5              push af
1331+  43E7 3E 0B           ld a,CH_CMD_SET_RETRY
1332+  43E9 D3 21           out (CH_COMMAND_PORT),a
1333+  43EB 3E 25           ld a,25h    ;Fixed value, required by CH376
1334+  43ED D3 20           out (CH_DATA_PORT),a
1335+  43EF             
1336+  43EF                 ;Bits 7 and 6:
1337+  43EF                 ;  0x: Don't retry NAKs
1338+  43EF                 ;  10: Retry NAKs indefinitely (default)
1339+  43EF                 ;  11: Retry NAKs for 3s
1340+  43EF                 ;Bits 5-0: Number of retries after device timeout
1341+  43EF                 ;Default after reset and SET_USB_MODE is 8Fh
1342+  43EF F1              pop af
1343+  43F0 D3 20           out (CH_DATA_PORT),a
1344+  43F2 C9              ret
1345+  43F3             
1346+  43F3             
1347+  43F3             ; -----------------------------------------------------------------------------
1348+  43F3             ; Auxiliary "private" routines
1349+  43F3             ; -----------------------------------------------------------------------------
1350+  43F3             
1351+  43F3             ; --------------------------------------
1352+  43F3             ; CH_CHECK_INT_IS_ACTIVE
1353+  43F3             ;
1354+  43F3             ; Check the status of the INT pin of the CH376
1355+  43F3             ;
1356+  43F3             ; Output: Z if active, NZ if not active
1357+  43F3             
1358+  43F3             CH_CHECK_INT_IS_ACTIVE:
1359+  43F3 DB 21           in a,(CH_COMMAND_PORT)
1360+  43F5 E6 80           and 80h
1361+  43F7 C9              ret
1362+  43F8             
1363+  43F8             
1364+  43F8             CH_WAIT_WHILE_BUSY:
1365+  43F8 F5              push af
1366+  43F9             _CH_WAIT_WHILE_BUSY_LOOP:
1367+  43F9 DB 21           in a,(CH_COMMAND_PORT)
1368+  43FB E6 10           and 10000b
1369+  43FD 20 FA           jr nz,_CH_WAIT_WHILE_BUSY_LOOP
1370+  43FF F1              pop af
1371+  4400 C9              ret
1372+  4401             
1373+  4401             
1374+  4401             ; --------------------------------------
1375+  4401             ; CH_WAIT_INT_AND_GET_RESULT
1376+  4401             ;
1377+  4401             ; Wait for INT to get active, execute GET_STATUS, 
1378+  4401             ; and return the matching USB error code
1379+  4401             ;
1380+  4401             ; Output: A = Result of GET_STATUS (an USB error code)
1381+  4401             
1382+  4401             CH_WAIT_INT_AND_GET_RESULT:
1383+  4401                 if IMPLEMENT_PANIC_BUTTON=1
1384+  4401 CD 52 44        call PANIC_KEYS_PRESSED
1385+  4404 3E 06           ld a,USB_ERR_PANIC_BUTTON_PRESSED
1386+  4406 C8              ret z
1387+  4407                 endif
1388+  4407             
1389+  4407 CD F3 43        call CH_CHECK_INT_IS_ACTIVE
1390+  440A 20 F5           jr nz,CH_WAIT_INT_AND_GET_RESULT    ;TODO: Perhaps add a timeout check here?
1391+  440C             
1392+  440C CD 63 44        call CH_GET_STATUS
1393+  440F FE 41           cp USB_FILERR_MIN
1394+  4411 38 05           jr c,_CH_WAIT_INT_AND_GET_RESULT_2
1395+  4413 FE B5           cp USB_FILERR_MAX+1
1396+  4415 30 01           jr nc,_CH_WAIT_INT_AND_GET_RESULT_2
1397+  4417 C9              ret
1398+  4418             
1399+  4418             _CH_WAIT_INT_AND_GET_RESULT_2:
1400+  4418             
1401+  4418 FE 51           cp CH_ST_RET_SUCCESS
1402+  441A 06 00           ld b,USB_ERR_OK
1403+  441C 28 2C           jr z,_CH_LD_A_B_RET
1404+  441E FE 14           cp CH_ST_INT_SUCCESS
1405+  4420 28 28           jr z,_CH_LD_A_B_RET
1406+  4422 FE 1D           cp CH_ST_INT_DISK_READ
1407+  4424 C8              ret z
1408+  4425 FE 1E           cp CH_ST_INT_DISK_WRITE
1409+  4427 C8              ret z
1410+  4428 FE 16           cp CH_ST_INT_DISCONNECT
1411+  442A 28 20           jr z,_CH_NO_DEV_ERR
1412+  442C FE 17           cp CH_ST_INT_BUF_OVER
1413+  442E 06 04           ld b,USB_ERR_DATA_ERROR
1414+  4430 28 18           jr z,_CH_LD_A_B_RET
1415+  4432             
1416+  4432 E6 2F           and 2Fh
1417+  4434             
1418+  4434 FE 2A           cp 2Ah
1419+  4436 06 01           ld b,USB_ERR_NAK
1420+  4438 28 10           jr z,_CH_LD_A_B_RET
1421+  443A FE 2E           cp 2Eh
1422+  443C 06 02           ld b,USB_ERR_STALL
1423+  443E 28 0A           jr z,_CH_LD_A_B_RET
1424+  4440             
1425+  4440 E6 23           and 23h
1426+  4442             
1427+  4442 FE 20           cp 20h
1428+  4444 06 03           ld b,USB_ERR_TIMEOUT
1429+  4446 28 02           jr z,_CH_LD_A_B_RET
1430+  4448             
1431+  4448 06 07           ld b,USB_ERR_UNEXPECTED_STATUS_FROM_HOST
1432+  444A             
1433+  444A             _CH_LD_A_B_RET:
1434+  444A 78              ld a,b
1435+  444B C9              ret
1436+  444C             
1437+  444C             _CH_NO_DEV_ERR:
1438+  444C CD 6A 44        call CH_DO_SET_NOSOF_MODE
1439+  444F 3E 05           ld a,USB_ERR_NO_DEVICE
1440+  4451 C9              ret
1441+  4452             
1442+  4452             
1443+  4452                 if IMPLEMENT_PANIC_BUTTON=1
1444+  4452             
1445+  4452                 ;Return Z=1 if CAPS+ESC is pressed
1446+  4452             PANIC_KEYS_PRESSED:
1447+  4452 3E 06           ld a,6
1448+  4454 CD 38 55        call DO_SNSMAT
1449+  4457 E6 08           and 1000b
1450+  4459 47              ld b,a
1451+  445A 3E 07           ld a,7
1452+  445C CD 38 55        call DO_SNSMAT
1453+  445F E6 04           and 100b
1454+  4461 B0              or b
1455+  4462 C9              ret
1456+  4463             
1457+  4463                 endif
1458+  4463             
1459+  4463             
1460+  4463             ; --------------------------------------
1461+  4463             ; CH_GET_STATUS
1462+  4463             ;
1463+  4463             ; Output: A = Status code
1464+  4463             
1465+  4463             CH_GET_STATUS:
1466+  4463 3E 22           ld a,CH_CMD_GET_STATUS
1467+  4465 D3 21           out (CH_COMMAND_PORT),a
1468+  4467 DB 20           in a,(CH_DATA_PORT)
1469+  4469 C9              ret
1470+  446A             
1471+  446A             
1472+  446A             ; --------------------------------------
1473+  446A             ; CH_SET_NOSOF_MODE: Sets USB host mode without SOF
1474+  446A             ;
1475+  446A             ; This needs to run when a device disconnection is detected
1476+  446A             ;
1477+  446A             ; Output: A  = -1
1478+  446A             ;         Cy = 1 on error
1479+  446A             
1480+  446A             CH_DO_SET_NOSOF_MODE:
1481+  446A 3E 05           ld a,5
1482+  446C CD 72 44        call CH_SET_USB_MODE
1483+  446F             
1484+  446F 3E FF           ld a,-1
1485+  4471 C9              ret
1486+  4472             
1487+  4472             
1488+  4472             ; --------------------------------------
1489+  4472             ; CH_SET_USB_MODE
1490+  4472             ;
1491+  4472             ; Input: A = new USB mode:
1492+  4472             ;            5: Host, no SOF
1493+  4472             ;            6: Host, generate SOF
1494+  4472             ;            7: Host, generate SOF + bus reset
1495+  4472             ; Output: Cy = 1 on error
1496+  4472             
1497+  4472             CH_SET_USB_MODE:
1498+  4472 47              ld b,a
1499+  4473 3E 15           ld a,CH_CMD_SET_USB_MODE
1500+  4475 D3 21           out (CH_COMMAND_PORT),a
1501+  4477 78              ld a,b
1502+  4478 D3 20           out (CH_DATA_PORT),a
1503+  447A             
1504+  447A 06 FF           ld b,255
1505+  447C             _CH_WAIT_USB_MODE:
1506+  447C DB 20           in a,(CH_DATA_PORT)
1507+  447E FE 51           cp CH_ST_RET_SUCCESS
1508+  4480 CA 87 44        jp z,CH_CONFIGURE_RETRIES
1509+  4483 10 F7           djnz _CH_WAIT_USB_MODE
1510+  4485 37              scf
1511+  4486 C9              ret
1512+  4487             
1513+  4487             
1514+  4487             CH_CONFIGURE_RETRIES:
1515+  4487 B7              or a
1516+  4488 CD E0 43        call HW_CONFIGURE_NAK_RETRY
1517+  448B B7              or a
1518+  448C C9              ret
1519+  448D             
1520+  448D             
1521+  448D             ; --------------------------------------
1522+  448D             ; CH_SET_TARGET_DEVICE_ADDRESS
1523+  448D             ;
1524+  448D             ; Set target USB device address for operation
1525+  448D             ;
1526+  448D             ; Input: A = Device address
1527+  448D             
1528+  448D             CH_SET_TARGET_DEVICE_ADDRESS:
1529+  448D F5              push af
1530+  448E 3E 13           ld a,CH_CMD_SET_USB_ADDR
1531+  4490 D3 21           out (CH_COMMAND_PORT),a
1532+  4492 F1              pop af
1533+  4493 D3 20           out (CH_DATA_PORT),a
1534+  4495 C9              ret
1535+  4496             
1536+  4496             
1537+  4496             ; --------------------------------------
1538+  4496             ; CH_ISSUE_TOKEN
1539+  4496             ;
1540+  4496             ; Send a token to the current target USB device
1541+  4496             ;
1542+  4496             ; Input: E = Endpoint number
1543+  4496             ;        B = PID, one of CH_PID_*
1544+  4496             ;        A = Toggle bit in bit 7 (for IN transfer)
1545+  4496             ;            Toggle bit in bit 6 (for OUT transfer)
1546+  4496             
1547+  4496             CH_ISSUE_TOKEN:
1548+  4496 57              ld d,a
1549+  4497 3E 4E           ld a,CH_CMD_ISSUE_TKN_X
1550+  4499 D3 21           out (CH_COMMAND_PORT),a
1551+  449B 7A              ld a,d
1552+  449C D3 20           out (CH_DATA_PORT),a    ;Toggles
1553+  449E 7B              ld a,e
1554+  449F 17              rla
1555+  44A0 17              rla
1556+  44A1 17              rla
1557+  44A2 17              rla
1558+  44A3 E6 F0           and 0F0h
1559+  44A5 B0              or b
1560+  44A6 D3 20           out (CH_DATA_PORT),a    ;Endpoint | PID
1561+  44A8 C9              ret
1562+  44A9             
1563+  44A9             
1564+  44A9             ; --------------------------------------
1565+  44A9             ; CH_READ_DATA
1566+  44A9             ;
1567+  44A9             ; Read data from the CH data buffer
1568+  44A9             ;
1569+  44A9             ; Input:  HL = Destination address for the data
1570+  44A9             ; Output: B  = Amount of data received (0-64)
1571+  44A9             ;         HL = HL + B
1572+  44A9             
1573+  44A9             CH_READ_DATA:
1574+  44A9 3E 27           ld a,CH_CMD_RD_USB_DATA0
1575+  44AB D3 21           out (CH_COMMAND_PORT),a
1576+  44AD DB 20           in a,(CH_DATA_PORT)
1577+  44AF 4F              ld c,a
1578+  44B0 B7              or a
1579+  44B1 C8              ret z   ;No data to transfer at all
1580+  44B2 47              ld b,a
1581+  44B3             
1582+  44B3 57              ld d,a
1583+  44B4 0E 20           ld c,CH_DATA_PORT
1584+  44B6             
1585+  44B6 7C              ld a,h
1586+  44B7 B5              or l
1587+  44B8 28 05           jr z,_CH_READ_DISCARD_DATA_LOOP
1588+  44BA             
1589+  44BA 42              ld b,d
1590+  44BB ED B2           inir
1591+  44BD 42              ld b,d
1592+  44BE C9              ret
1593+  44BF             
1594+  44BF             _CH_READ_DISCARD_DATA_LOOP:
1595+  44BF ED 78           in a,(c)
1596+  44C1 10 FC           djnz _CH_READ_DISCARD_DATA_LOOP
1597+  44C3 42              ld b,d
1598+  44C4 C9              ret
1599+  44C5             
1600+  44C5             
1601+  44C5             ; --------------------------------------
1602+  44C5             ; CH_WRITE_DATA
1603+  44C5             ;
1604+  44C5             ; Write data to the CH data buffer
1605+  44C5             ;
1606+  44C5             ; Input:  HL = Source address of the data
1607+  44C5             ;         B  = Length of the data
1608+  44C5             ; Output: HL = HL + B
1609+  44C5             
1610+  44C5             CH_WRITE_DATA:
1611+  44C5 3E 2C           ld a,CH_CMD_WR_HOST_DATA
1612+  44C7 D3 21           out (CH_COMMAND_PORT),a
1613+  44C9 0E 20           ld c,CH_DATA_PORT
1614+  44CB 78              ld a,b  
1615+  44CC ED 79           out (c),a
1616+  44CE B7              or a
1617+  44CF C8              ret z
1618+  44D0             
1619+  44D0 ED B3           otir
1620+  44D2 C9              ret
1621+  44D3             
1622+  44D3             
1623+  44D3             ; --------------------------------------
1624+  44D3             ; CH_WRITE_STRING
1625+  44D3             ;
1626+  44D3             ; Write a zero or "/" terminated string
1627+  44D3             ; to the CH data buffer (if the terminator
1628+  44D3             ; is "/" a zero is written)
1629+  44D3             ;
1630+  44D3             ; Input:  HL = Source address of the string
1631+  44D3             ; Output: HL = Points to the terminator
1632+  44D3             
1633+  44D3             CH_WRITE_STRING:
1634+  44D3 0E 20           ld c,CH_DATA_PORT
1635+  44D5 7E              ld a,(hl)
1636+  44D6 ED 79           out (c),a   ;We accept "/" only as the first char
1637+  44D8             
1638+  44D8             _CH_WRITE_STRING_LOOP:
1639+  44D8 B7              or a
1640+  44D9 C8              ret z
1641+  44DA 23              inc hl
1642+  44DB 7E              ld a,(hl)
1643+  44DC FE 2F           cp "/"
1644+  44DE 28 04           jr z,_CH_WRITE_STRING_BAR
1645+  44E0 ED 79           out (c),a
1646+  44E2 18 F4           jr _CH_WRITE_STRING_LOOP
1647+  44E4             
1648+  44E4             _CH_WRITE_STRING_BAR:
1649+  44E4 AF              xor a
1650+  44E5 ED 79           out (c),a
1651+  44E7 C9              ret
0054   44E8                 include "bank1/inihrd_inienv.asm"
0001+  44E8             ; MSXUSB USB FDD BIOS
0002+  44E8             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003+  44E8             ; This version is adapted to work with the latest version of the MSXUSB project
0004+  44E8             ;
0005+  44E8             ; This file contains the implementation of the INIHRD and INIENV
0006+  44E8             ; driver routines.
0007+  44E8             
0008+  44E8             
0009+  44E8             ; We do the hardware reset in INIENV and not in INIHRD
0010+  44E8             ; because we need to setup the work area during reset, but work area
0011+  44E8             ; is zeroed by kernel between INIHRD and INIENV.
0012+  44E8             
0013+  44E8             
0014+  44E8             ; -----------------------------------------------------------------------------
0015+  44E8             ; INIHRD
0016+  44E8             ; -----------------------------------------------------------------------------
0017+  44E8             ; Input:	None
0018+  44E8             ; Output:	Cy=0 if USB hardware is operational, 1 if not
0019+  44E8             ; Changed:	AF,BC,DE,HL,IX,IY may be affected
0020+  44E8             ; -----------------------------------------------------------------------------
0021+  44E8             
0022+  44E8             INIHRD_IMPL:
0023+  44E8 CD 6C 00        call INITXT
0024+  44EB 21 57 46        ld hl,ROOKIE_S
0025+  44EE CD B5 45        call PRINT
0026+  44F1             
0027+  44F1 CD 26 40        call HW_TEST
0028+  44F4 D0              ret nc
0029+  44F5             
0030+  44F5 21 BE 46        ld hl,NOHARD_S
0031+  44F8 CD B5 45        call PRINT
0032+  44FB 06 3C           ld b,60
0033+  44FD CD 16 45        call DELAY_B
0034+  4500             
0035+  4500 37              scf
0036+  4501 C9              ret
0037+  4502             
0038+  4502             
0039+  4502             ; -----------------------------------------------------------------------------
0040+  4502             ; INIENV
0041+  4502             ; -----------------------------------------------------------------------------
0042+  4502             ; Input: 	None
0043+  4502             ; Output:	None
0044+  4502             ; Changed:	AF,BC,DE,HL,IX,IY may be affected
0045+  4502             ;
0046+  4502             ; Remark:	-
0047+  4502             ; -----------------------------------------------------------------------------
0048+  4502             
0049+  4502             INIENV_IMPL:
0050+  4502             
0051+  4502                 if WAIT_KEY_ON_INIT = 1
0052+  4502~                ld hl,INIHRD_NEXT
0053+  4502~                push hl
0054+  4502                 endif
0055+  4502             
0056+  4502 AF              xor a
0057+  4503 CD 87 4F        call WK_SET_LAST_REL_DRIVE
0058+  4506             
0059+  4506 CD 1A 45        call VERBOSE_RESET
0060+  4509 06 1E           ld b,30
0061+  450B CD 16 45        call DELAY_B
0062+  450E CD E5 4F        call WK_GET_STORAGE_DEV_FLAGS
0063+  4511 C8              ret z
0064+  4512 AF              xor a
0065+  4513 C3 3C 6C        jp DSK_DO_BOOT_PROC
0066+  4516             
0067+  4516             DELAY_B:
0068+  4516 76              halt
0069+  4517 10 FD           djnz DELAY_B
0070+  4519 C9              ret
0055   451A                 include "bank1/verbose_reset.asm"
0001+  451A             ; MSXUSB USB FDD BIOS
0002+  451A             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003+  451A             ; This version is adapted to work with the latest version of the MSXUSB project
0004+  451A             ;
0005+  451A             ; This routine resets the USB hardware, resets and initializes the device,
0006+  451A             ; and prints the device name or the appropriate error message.
0007+  451A             ; It is executed at boot time and by CALL USBRESET.
0008+  451A             
0009+  451A             VERBOSE_RESET:
0010+  451A FD E5           push iy
0011+  451C FD 21 DC FF     ld iy,-36
0012+  4520 FD 39           add iy,sp
0013+  4522 FD F9           ld sp,iy
0014+  4524 CD 32 45        call _VERBOSE_RESET
0015+  4527 FD 21 24 00     ld iy,36
0016+  452B FD 39           add iy,sp
0017+  452D FD F9           ld sp,iy
0018+  452F FD E1           pop iy
0019+  4531 C9              ret
0020+  4532             
0021+  4532             _VERBOSE_RESET:
0022+  4532 AF              xor a
0023+  4533 CD F8 4F        call WK_SET_STORAGE_DEV_FLAGS
0024+  4536 CD A9 4F        call WK_SET_MISC_FLAGS
0025+  4539             
0026+  4539 CD 26 40        call HW_TEST
0027+  453C 21 BE 46        ld hl,NOHARD_S
0028+  453F DA B5 45        jp c,PRINT
0029+  4542             
0030+  4542 FD E5           push iy
0031+  4544 E1              pop hl
0032+  4545 E5              push hl
0033+  4546 CD 9C 41        call HWF_MOUNT_DISK
0034+  4549 38 1F           jr c,_HW_RESET_NO_STOR
0035+  454B             
0036+  454B 21 BF 47        ld hl,STOR_FOUND_S
0037+  454E CD B5 45        call PRINT
0038+  4551 E1              pop hl
0039+  4552 06 00           ld b,0
0040+  4554                 ;Print the device name, collapsing multiple spaces to a single one
0041+  4554             _HW_RESET_PRINT:
0042+  4554 7E              ld a,(hl)
0043+  4555 23              inc hl
0044+  4556 B7              or a
0045+  4557 28 0D           jr z,_HW_RESET_PRINT_END
0046+  4559 FE 20           cp ' '
0047+  455B 20 03           jr nz,_HW_RESET_PRINT_GO
0048+  455D B8              cp b
0049+  455E 28 F4           jr z,_HW_RESET_PRINT
0050+  4560             _HW_RESET_PRINT_GO:
0051+  4560 47              ld b,a
0052+  4561 CD A2 00        call CHPUT
0053+  4564 18 EE           jr _HW_RESET_PRINT
0054+  4566             _HW_RESET_PRINT_END:
0055+  4566 CD B0 6D        call DSK_INIT_WK_FOR_STORAGE_DEV
0056+  4569 C9              ret
0057+  456A             
0058+  456A             _HW_RESET_NO_STOR:
0059+  456A E1              pop hl
0060+  456B 06 05           ld b,5
0061+  456D             _HW_RESET_TRY:
0062+  456D C5              push bc
0063+  456E CD 44 40        call HW_RESET
0064+  4571 C1              pop bc
0065+  4572 30 08           jr nc,_HW_RESET_TRY_OK
0066+  4574 10 F7           djnz _HW_RESET_TRY
0067+  4576 21 33 47        ld hl,RESERR_S
0068+  4579 C3 B5 45        jp PRINT
0069+  457C             _HW_RESET_TRY_OK:
0070+  457C 3C              inc a
0071+  457D 21 DD 46        ld hl,NODEV_S
0072+  4580 CA B5 45        jp z,PRINT
0073+  4583             
0074+  4583                 ;Experiments with hubs, please ignore
0075+  4583                 if 0
0076+  4583~            
0077+  4583~                ld hl,HUB_FOUND_S
0078+  4583~                call PRINT
0079+  4583~                ld a,2
0080+  4583~                call HW_SET_ADDRESS
0081+  4583~                ld a,2
0082+  4583~                ld b,1
0083+  4583~                call HW_SET_CONFIG
0084+  4583~                ld hl,CMD_PORT_POWER
0085+  4583~                ld de,0
0086+  4583~                ld a,2
0087+  4583~                ld b,64
0088+  4583~                call HW_CONTROL_TRANSFER
0089+  4583~                add "0"
0090+  4583~                call CHPUT
0091+  4583~                ld hl,CMD_PORT_RESET
0092+  4583~                ld de,0
0093+  4583~                ld a,2
0094+  4583~                ld b,64
0095+  4583~                call HW_CONTROL_TRANSFER
0096+  4583~                add "0"
0097+  4583~                call CHPUT
0098+  4583~            
0099+  4583~                halt
0100+  4583~                halt
0101+  4583~                halt
0102+  4583~                halt
0103+  4583~                halt
0104+  4583~            
0105+  4583~                xor a
0106+  4583~                call HW_GET_DEV_DESCR
0107+  4583~                add "0"
0108+  4583~                call CHPUT
0109+  4583~                jr HUBDONE
0110+  4583~            
0111+  4583~            CMD_PORT_POWER:
0112+  4583~                db  00100011b, 3, 8, 0, 1, 0, 0, 0
0113+  4583~            CMD_PORT_RESET:
0114+  4583~                db  00100011b, 3, 4, 0, 1, 0, 0, 0
0115+  4583~            HUBDONE:
0116+  4583~            
0117+  4583                 endif
0118+  4583             
0119+  4583 06 05           ld b,5
0120+  4585             _TRY_USB_INIT_DEV:
0121+  4585 C5              push bc
0122+  4586 CD 90 50        call USB_INIT_DEV
0123+  4589 60              ld h,b
0124+  458A C1              pop bc
0125+  458B FE 02           cp 2
0126+  458D 38 09           jr c,_TRY_USB_INIT_DEV_OK
0127+  458F 10 F4           djnz _TRY_USB_INIT_DEV
0128+  4591 7C              ld a,h
0129+  4592 21 72 47        ld hl,DEVERR_S
0130+  4595 C3 41 46        jp PRINT_ERROR
0131+  4598             _TRY_USB_INIT_DEV_OK:
0132+  4598             
0133+  4598 F5              push af
0134+  4599 CD C4 4F        call WK_GET_MISC_FLAGS
0135+  459C E6 01           and 1
0136+  459E 21 DA 47        ld hl,HUB_FOUND_S
0137+  45A1 C4 B5 45        call nz,PRINT
0138+  45A4 F1              pop af
0139+  45A5             
0140+  45A5 B7              or a
0141+  45A6 21 F5 46        ld hl,NO_CBI_DEV_S
0142+  45A9 C2 B5 45        jp nz,PRINT
0143+  45AC             
0144+  45AC 21 21 47        ld hl,YES_CBI_DEV_S
0145+  45AF CD B5 45        call PRINT
0146+  45B2 C3 BE 45        jp PRINT_DEVICE_INFO
0147+  45B5             
0148+  45B5                 if WAIT_KEY_ON_INIT = 1
0149+  45B5~            INIHRD_NEXT:
0150+  45B5~                jp CHGET
0151+  45B5                 endif
0152+  45B5             
0153+  45B5             PRINT:
0154+  45B5 7E          	ld a,(hl)
0155+  45B6 B7          	or a
0156+  45B7 C8          	ret z
0157+  45B8 CD A2 00    	call CHPUT
0158+  45BB 23          	inc hl
0159+  45BC 18 F7       	jr PRINT
0160+  45BE             
0161+  45BE             
0162+  45BE             ; -----------------------------------------------------------------------------
0163+  45BE             ; Print the device name from INQUIRY command
0164+  45BE             
0165+  45BE             PRINT_DEVICE_INFO_STACK_SPACE: equ 36
0166+  45BE             
0167+  45BE             PRINT_DEVICE_INFO:
0168+  45BE 21 DC FF        ld hl,-PRINT_DEVICE_INFO_STACK_SPACE
0169+  45C1 39              add hl,sp
0170+  45C2 F9              ld sp,hl
0171+  45C3             
0172+  45C3 06 03           ld b,3  ;Some drives stall on first command after reset so try a few times
0173+  45C5             _TRY_INQUIRY:    
0174+  45C5 C5              push bc
0175+  45C6 E5              push hl
0176+  45C7 D1              pop de
0177+  45C8 21 17 46        ld hl,INIQUIRY_CMD
0178+  45CB 01 24 00        ld bc,36
0179+  45CE 3E 01           ld a,1
0180+  45D0 B7              or a
0181+  45D1 D5              push de
0182+  45D2 CD 7C 53        call USB_EXECUTE_CBI_WITH_RETRY
0183+  45D5 E1              pop hl
0184+  45D6 C1              pop bc
0185+  45D7 B7              or a
0186+  45D8 28 04           jr z,_INQUIRY_OK
0187+  45DA 10 E9           djnz _TRY_INQUIRY
0188+  45DC 18 2D           jr _PRINT_DEVICE_INFO_ERR
0189+  45DE             _INQUIRY_OK:
0190+  45DE             
0191+  45DE 01 08 00        ld bc,8
0192+  45E1 09              add hl,bc
0193+  45E2 06 08           ld b,8
0194+  45E4 CD 23 46        call PRINT_SPACE_PADDED_STRING
0195+  45E7 3E 20           ld a,' '
0196+  45E9 CD A2 00        call CHPUT
0197+  45EC             
0198+  45EC 01 08 00        ld bc,8 ;base + 16
0199+  45EF 09              add hl,bc
0200+  45F0 06 10           ld b,16
0201+  45F2 CD 23 46        call PRINT_SPACE_PADDED_STRING
0202+  45F5 3E 20           ld a,' '
0203+  45F7 CD A2 00        call CHPUT
0204+  45FA             
0205+  45FA 01 10 00        ld bc,16 ;base + 32
0206+  45FD 09              add hl,bc
0207+  45FE 06 04           ld b,4
0208+  4600 CD 23 46        call PRINT_SPACE_PADDED_STRING
0209+  4603             
0210+  4603 21 DA 46        ld hl,CRLF_S
0211+  4606 CD B5 45        call PRINT
0212+  4609             
0213+  4609 18 06           jr _PRINT_DEVICE_INFO_END
0214+  460B             
0215+  460B             _PRINT_DEVICE_INFO_ERR:
0216+  460B 21 9E 47        ld hl,ERR_INQUIRY_S
0217+  460E CD 41 46        call PRINT_ERROR
0218+  4611             _PRINT_DEVICE_INFO_END:    
0219+  4611 21 24 00        ld hl,PRINT_DEVICE_INFO_STACK_SPACE
0220+  4614 39              add hl,sp
0221+  4615 F9              ld sp,hl
0222+  4616 C9              ret
0223+  4617             
0224+  4617             INIQUIRY_CMD:
0225+  4617                 db 12h, 0, 0, 0, 36, 0, 0, 0, 0, 0, 0, 0
0225+  4617 120000002400000000000000
0226+  4623             
0227+  4623             
0228+  4623                 ; Print a fixed-length space-padded string, skipping the padding
0229+  4623                 ; Input: HL = String address
0230+  4623                 ;        B  = String length
0231+  4623             
0232+  4623             PRINT_SPACE_PADDED_STRING:
0233+  4623 E5              push hl
0234+  4624 CD 29 46        call _PRINT_SPACE_PADDED_STRING
0235+  4627 E1              pop hl
0236+  4628 C9              ret
0237+  4629             
0238+  4629             _PRINT_SPACE_PADDED_STRING:
0239+  4629 58              ld e,b
0240+  462A 16 00           ld d,0
0241+  462C E5              push hl
0242+  462D 19              add hl,de   ;HL points past the last char of the string
0243+  462E             _PSPS_Z_LOOP:
0244+  462E 2B              dec hl
0245+  462F 7E              ld a,(hl)
0246+  4630 FE 20           cp ' '
0247+  4632 20 04           jr nz,_PSPS_DO
0248+  4634 10 F8           djnz _PSPS_Z_LOOP
0249+  4636 E1              pop hl
0250+  4637 C9              ret         ;All the string is spaces, do nothing
0251+  4638             
0252+  4638             _PSPS_DO:
0253+  4638 E1              pop hl
0254+  4639             _PSPS_P_LOOP:
0255+  4639 7E              ld a,(hl)
0256+  463A CD A2 00        call CHPUT
0257+  463D 23              inc hl
0258+  463E 10 F9           djnz _PSPS_P_LOOP
0259+  4640             
0260+  4640 C9              ret
0261+  4641             
0262+  4641             
0263+  4641             ; -----------------------------------------------------------------------------
0264+  4641             ; Print an error message and the description of an USB error code
0265+  4641             ;
0266+  4641             ; Input: HL = Error message
0267+  4641             ;        A = Error code
0268+  4641             
0269+  4641             PRINT_ERROR:
0270+  4641 F5              push af
0271+  4642 CD B5 45        call PRINT
0272+  4645 F1              pop af
0273+  4646             
0274+  4646 DD 21 27 7C     ld ix,PRINT_ERROR_DESCRIPTION
0275+  464A FD 21 00 00     ld iy,ROM_BANK_0
0276+  464E CD D2 7F        call CALL_BANK
0277+  4651             
0278+  4651 21 DA 46        ld hl,CRLF_S
0279+  4654 C3 B5 45        jp PRINT
0280+  4657             
0281+  4657             
0282+  4657             ; -----------------------------------------------------------------------------
0283+  4657             ; Strings
0284+  4657             
0285+  4657             ROOKIE_S:
0286+  4657             	db "USBHOST NestorBIOS v2.1",13,10
0286+  4657 555342484F5354204E6573746F7242494F532076322E310D0A
0287+  4670             	db "(c) 2018-2022 Konamiman",13,10
0287+  4670 28632920323031382D32303232204B6F6E616D696D616E0D0A
0288+  4689                 db "(c) 2024 The Retro Hacker",13,10
0288+  4689 28632920323032342054686520526574726F204861636B65720D0A
0289+  46A4 0D 0A       	db 13,10
0290+  46A6                 db "Initializing device...",13
0290+  46A6 496E697469616C697A696E67206465766963652E2E2E0D
0291+  46BD 00          	db 0
0292+  46BE             
0293+  46BE             NOHARD_S:
0294+  46BE                 db  "USB host hardware not found!"
0294+  46BE 55534220686F7374206861726477617265206E6F7420666F756E6421
0295+  46DA             CRLF_S:
0296+  46DA 0D 0A 00        db 13,10,0
0297+  46DD             
0298+  46DD             NODEV_S:
0299+  46DD                 db  "No USB device found",27,"K",13,10,0
0299+  46DD 4E6F205553422064657669636520666F756E641B4B0D0A00
0300+  46F5             
0301+  46F5             NO_CBI_DEV_S:
0302+  46F5                 db  "USB device found, but it's not a FDD unit",13,10,0
0302+  46F5 5553422064657669636520666F756E642C206275742069742773206E6F742061
0302+  4715 2046444420756E69740D0A00
0303+  4721             
0304+  4721             YES_CBI_DEV_S:
0305+  4721                 db  "USB FDD found: ",27,"K",0    
0305+  4721 5553422046444420666F756E643A201B4B00
0306+  4733             
0307+  4733             RESERR_S:
0308+  4733                 db  "ERROR initializing USB host hardware or resetting USB device",13,10,0
0308+  4733 4552524F5220696E697469616C697A696E672055534220686F73742068617264
0308+  4753 77617265206F7220726573657474696E6720555342206465766963650D0A00
0309+  4772             
0310+  4772             DEVERR_S:
0311+  4772                 db  "ERROR querying or initializing USB device: ",0
0311+  4772 4552524F52207175657279696E67206F7220696E697469616C697A696E672055
0311+  4792 5342206465766963653A2000
0312+  479E             
0313+  479E             ERR_INQUIRY_S:
0314+  479E                 db  "ERROR querying the device name: ",0
0314+  479E 4552524F52207175657279696E672074686520646576696365206E616D653A20
0314+  47BE 00
0315+  47BF             
0316+  47BF             STOR_FOUND_S:
0317+  47BF                 db "USB storage device found: ",0
0317+  47BF 5553422073746F726167652064657669636520666F756E643A2000
0318+  47DA             
0319+  47DA             HUB_FOUND_S:
0320+  47DA                 db "USB hub found",27,"K",13,10,0
0320+  47DA 5553422068756220666F756E641B4B0D0A00
0056   47EC                 include "bank1/dskio_dskchg.asm"
0001+  47EC             ; MSXUSB USB FDD BIOS
0002+  47EC             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003+  47EC             ; This version is adapted to work with the latest version of the MSXUSB project
0004+  47EC             ;
0005+  47EC             ; This file contains the implementation of the DSKIO, DSKCHG and GETDPB
0006+  47EC             ; driver routines.
0007+  47EC             
0008+  47EC             
0009+  47EC             ; Error codes used by DSKIO, DSKCHG and GETDPB:
0010+  47EC             ;
0011+  47EC             ; 0	write protect error
0012+  47EC             ; 2	not ready error
0013+  47EC             ; 4	data (crc) error
0014+  47EC             ; 6	seek error
0015+  47EC             ; 8	record not found error
0016+  47EC             ; 10 write fault error
0017+  47EC             ; 12 other error
0018+  47EC             
0019+  47EC             
0020+  47EC             ; -----------------------------------------------------------------------------
0021+  47EC             ; DSKIO
0022+  47EC             ; -----------------------------------------------------------------------------
0023+  47EC             ; Input: 	A	Drivenumber
0024+  47EC             ;		F	Cx reset for read
0025+  47EC             ;			Cx set for write
0026+  47EC             ; 		B	number of sectors
0027+  47EC             ; 		C	Media descriptor
0028+  47EC             ;		DE	logical sectornumber
0029+  47EC             ; 		HL	transferaddress
0030+  47EC             ; Output:	F	Cx set for error
0031+  47EC             ;			Cx reset for ok
0032+  47EC             ;		A	if error, errorcode
0033+  47EC             ;		B	total count of sectors read
0034+  47EC             ; Changed:	AF,BC,DE,HL,IX,IY may be affected
0035+  47EC             ; -----------------------------------------------------------------------------
0036+  47EC             
0037+  47EC             DSKIO_STACK_SPACE: equ 32
0038+  47EC             
0039+  47EC             DSKIO_IMPL:
0040+  47EC             
0041+  47EC                 if DEBUG_DSKIO=1
0042+  47EC~                call DO_DEBUG_DSKIO
0043+  47EC                 endif
0044+  47EC             
0045+  47EC CD 14 55        call CHECK_SAME_DRIVE
0046+  47EF             
0047+  47EF F5              push af
0048+  47F0 FE 02           cp 2
0049+  47F2 30 04           jr nc,_DSKIO_ERR_PARAM
0050+  47F4             
0051+  47F4 CB 78           bit 7,b ;Sanity check: transfer of 64K or more requested?
0052+  47F6 28 05           jr z,_DSKIO_OK_UNIT
0053+  47F8             
0054+  47F8             _DSKIO_ERR_PARAM:
0055+  47F8 F1              pop af
0056+  47F9 3E 0C           ld a,12
0057+  47FB 37              scf
0058+  47FC C9              ret
0059+  47FD             
0060+  47FD             _DSKIO_OK_UNIT:
0061+  47FD E5              push hl
0062+  47FE D5              push de
0063+  47FF C5              push bc
0064+  4800 CD 5B 50        call USB_CHECK_DEV_CHANGE
0065+  4803 C1              pop bc
0066+  4804 D1              pop de
0067+  4805 E1              pop hl
0068+  4806 3E 0C           ld a,12
0069+  4808 D8              ret c   ;No device is connected
0070+  4809             
0071+  4809 CD E5 4F        call WK_GET_STORAGE_DEV_FLAGS
0072+  480C C2 47 49        jp nz,_DSKIO_IMPL_STDEV
0073+  480F             
0074+  480F             
0075+  480F                 ;=== DSKIO for floppy disk drives ===
0076+  480F             
0077+  480F 78              ld a,b
0078+  4810 C1              pop bc
0079+  4811 CB 09           rrc c   ;Now C:7 = 0 to read, 1 to write
0080+  4813 47              ld b,a
0081+  4814             
0082+  4814                 ;ld a,b
0083+  4814 B7              or a
0084+  4815 C8              ret z   ;Nothing to read
0085+  4816             
0086+  4816 E5              push hl
0087+  4817 D5              push de
0088+  4818 C5              push bc
0089+  4819 CD CC 54        call TEST_DISK
0090+  481C C1              pop bc
0091+  481D D1              pop de
0092+  481E E1              pop hl
0093+  481F D8              ret c
0094+  4820             
0095+  4820 DD 21 E0 FF     ld ix,-DSKIO_STACK_SPACE
0096+  4824 DD 39           add ix,sp
0097+  4826 DD F9           ld sp,ix
0098+  4828             
0099+  4828 E5              push hl
0100+  4829 D5              push de
0101+  482A C5              push bc
0102+  482B             
0103+  482B DD E5           push ix
0104+  482D D1              pop de
0105+  482E 21 2B 49        ld hl,_UFI_READ_SECTOR_CMD
0106+  4831 01 0C 00        ld bc,12
0107+  4834 ED B0           ldir
0108+  4836                 
0109+  4836 C1              pop bc
0110+  4837 CB 79           bit 7,c
0111+  4839 28 05           jr z,_DSKIO_OK_CMD
0112+  483B 3E 2A           ld a,2Ah    ;Convert "Read sector" command into "Write sector" command
0113+  483D DD 77 00        ld (ix),a
0114+  4840             _DSKIO_OK_CMD:    
0115+  4840 D1              pop de
0116+  4841 DD 72 04        ld (ix+4),d   ;First sector number
0117+  4844 DD 73 05        ld (ix+5),e
0118+  4847 D1              pop de      ;DE = Transfer address
0119+  4848             
0120+  4848                 ;  At this point:
0121+  4848                 ;  IX = Read or write sector command, with the proper sector number and count=1
0122+  4848                 ;  DE = Transfer address
0123+  4848                 ;  B  = Sector count
0124+  4848             
0125+  4848                 ;* Check if we can transfer sectors directly or we need to transfer one by one.
0126+  4848                 ;* We'll start with one by one transfer if page 1 is involved in the transfer.
0127+  4848             
0128+  4848 CD 46 4A        call CHECK_XFER_IS_NEEDED
0129+  484B 38 4C           jr c,_DSKIO_ONE_BY_ONE
0130+  484D             
0131+  484D                 ;>>> Direct transfer
0132+  484D                 ;    We transfer sectors directly from/to the source/target address,
0133+  484D                 ;    in 16 sector chunks (some device NAK or fail on larger transfers)
0134+  484D             
0135+  484D             _DSKIO_DIRECT_TRANSFER:
0136+  484D 0E 00           ld c,0 
0137+  484F             _DSKIO_DIRECT_TRANSFER_LOOP:
0138+  484F                 ;Here IX=Read/write command, DE=Transfer address, B=Sectors remaining, C=Sectors transferred so far
0139+  484F             
0140+  484F 78              ld a,b
0141+  4850 B7              or a
0142+  4851 CA ED 48        jp z,_DSKIO_TX_END    ;Terminate if no more sectors to transfer
0143+  4854 FE 10           cp 16
0144+  4856 38 02           jr c,_DSKIO_DIRECT_TRANSFER_OK_COUNT
0145+  4858 3E 10           ld a,16
0146+  485A             _DSKIO_DIRECT_TRANSFER_OK_COUNT:
0147+  485A DD 77 08        ld (ix+8),a     ;Set sector count on command
0148+  485D C5              push bc
0149+  485E D5              push de
0150+  485F CD FB 48        call _DSKIO_DO_SECTOR_TX
0151+  4862 E1              pop hl  ;transfer address
0152+  4863 30 0B           jr nc,_DSKIO_DIRECT_TRANSFER_OK_BLOCK
0153+  4865             
0154+  4865                 ;Transfer error: just update transferred sectors count and terminate
0155+  4865             
0156+  4865 CB 38           srl b   ;B=transferred sectors (will always be 0 on write, that's ok)
0157+  4867 E1              pop hl  ;L=Sectors transferred so far
0158+  4868 F5              push af
0159+  4869 7D              ld a,l
0160+  486A 80              add b
0161+  486B 4F              ld c,a
0162+  486C F1              pop af
0163+  486D 37              scf
0164+  486E 18 7D           jr _DSKIO_TX_END
0165+  4870             
0166+  4870             _DSKIO_DIRECT_TRANSFER_OK_BLOCK:
0167+  4870 DD 46 08        ld b,(ix+8) ;Transfer length in sectors
0168+  4873 CB 20           sla b
0169+  4875 0E 00           ld c,0      ;BC = transfer length in bytes
0170+  4877 09              add hl,bc   ;Update transfer address
0171+  4878 EB              ex de,hl
0172+  4879 60              ld h,b
0173+  487A CB 3C           srl h   ;H=transfer length in sectors
0174+  487C             
0175+  487C C1              pop bc
0176+  487D 79              ld a,c
0177+  487E 84              add h
0178+  487F 4F              ld c,a  ;Update sectors transferred so far
0179+  4880 78              ld a,b
0180+  4881 94              sub h
0181+  4882 47              ld b,a  ;Update remaining sectors
0182+  4883             
0183+  4883 E5              push hl
0184+  4884 C5              push bc
0185+  4885 4C              ld c,h
0186+  4886 06 00           ld b,0
0187+  4888 DD 66 04        ld h,(ix+4)
0188+  488B DD 6E 05        ld l,(ix+5)
0189+  488E 09              add hl,bc     ;Update sector number
0190+  488F DD 74 04        ld (ix+4),h
0191+  4892 DD 75 05        ld (ix+5),l
0192+  4895 C1              pop bc
0193+  4896 E1              pop hl
0194+  4897             
0195+  4897 18 B6           jr _DSKIO_DIRECT_TRANSFER_LOOP
0196+  4899             
0197+  4899                 ;>>> One by one sector transfer, using SECBUF and XFER
0198+  4899             
0199+  4899             _DSKIO_ONE_BY_ONE:
0200+  4899 0E 00           ld c,0
0201+  489B             _DSKIO_TX_LOOP:
0202+  489B                 ;Here IX=Read/write command, DE=Transfer address, B=Sectors remaining, C=Sectors transferred so far
0203+  489B             
0204+  489B CB 7A           bit 7,d ;Switch to direct transfer if source/target address becomes >=8000h
0205+  489D 20 B0           jr nz,_DSKIO_DIRECT_TRANSFER_LOOP
0206+  489F             
0207+  489F C5              push bc
0208+  48A0 D5              push de
0209+  48A1             
0210+  48A1 DD 7E 00        ld a,(ix)   ;Command is 28h to read or 2Ah to write
0211+  48A4 FE 2A           cp 2Ah
0212+  48A6 28 16           jr z,_DSKIO_WRITE_XFER
0213+  48A8             
0214+  48A8             _DSKIO_READ_XFER:
0215+  48A8 ED 5B 4D F3     ld de,(SECBUF)
0216+  48AC CD FB 48        call _DSKIO_DO_SECTOR_TX
0217+  48AF 38 3A           jr c,_DSKIO_TX_END_POP
0218+  48B1             
0219+  48B1 D1              pop de
0220+  48B2 D5              push de
0221+  48B3 2A 4D F3        ld hl,(SECBUF)
0222+  48B6 01 00 02        ld bc,512
0223+  48B9 CD 37 49        call CALL_XFER
0224+  48BC             
0225+  48BC 18 17           jr _DSKIO_TX_STEP_OK
0226+  48BE             
0227+  48BE             _DSKIO_WRITE_XFER:
0228+  48BE E1              pop hl
0229+  48BF E5              push hl
0230+  48C0 ED 5B 4D F3     ld de,(SECBUF)
0231+  48C4 01 00 02        ld bc,512
0232+  48C7 CD 37 49        call CALL_XFER
0233+  48CA             
0234+  48CA ED 5B 4D F3     ld de,(SECBUF)
0235+  48CE CD FB 48        call _DSKIO_DO_SECTOR_TX
0236+  48D1 38 18           jr c,_DSKIO_TX_END_POP
0237+  48D3             
0238+  48D3 18 00           jr _DSKIO_TX_STEP_OK
0239+  48D5             
0240+  48D5                 ;* One sector was transferred ok
0241+  48D5             
0242+  48D5             _DSKIO_TX_STEP_OK:
0243+  48D5 D1              pop de
0244+  48D6 14              inc d
0245+  48D7 14              inc d   ;Update transfer address (+512 bytes)
0246+  48D8             
0247+  48D8 C1              pop bc
0248+  48D9 0C              inc c   ;Update total sectors already transferred count
0249+  48DA             
0250+  48DA DD 66 04        ld h,(ix+4)
0251+  48DD DD 6E 05        ld l,(ix+5)
0252+  48E0 23              inc hl      ;Update sector number
0253+  48E1 DD 74 04        ld (ix+4),h
0254+  48E4 DD 75 05        ld (ix+5),l
0255+  48E7             
0256+  48E7 10 B2           djnz _DSKIO_TX_LOOP 
0257+  48E9 18 02           jr _DSKIO_TX_END
0258+  48EB             
0259+  48EB             _DSKIO_TX_END_POP:
0260+  48EB E1              pop hl
0261+  48EC C1              pop bc
0262+  48ED             _DSKIO_TX_END:
0263+  48ED 41              ld b,c
0264+  48EE             _DSKIO_TX_END_2:    
0265+  48EE F5              push af
0266+  48EF E1              pop hl
0267+  48F0 DD 21 20 00     ld ix,DSKIO_STACK_SPACE
0268+  48F4 DD 39           add ix,sp
0269+  48F6 DD F9           ld sp,ix
0270+  48F8 E5              push hl
0271+  48F9 F1              pop af
0272+  48FA C9              ret
0273+  48FB             
0274+  48FB                 ;--- This routine does the actual sector transfer
0275+  48FB                 ;    Input:  IX = UFI read or write command address,
0276+  48FB                 ;                 with proper sector number and sector count set
0277+  48FB                 ;            DE = Transfer address
0278+  48FB                 ;    Output: On success: Cy = 0
0279+  48FB                 ;            On error:   Cy = 1, A = DSKIO error code
0280+  48FB                 ;            BC = Amount of bytes transferred (on read only)
0281+  48FB                 ;    Preserves IX
0282+  48FB             
0283+  48FB             _DSKIO_DO_SECTOR_TX:
0284+  48FB DD E5           push ix
0285+  48FD E1              pop hl
0286+  48FE DD 46 08        ld b,(ix+8)
0287+  4901 CB 20           sla b
0288+  4903 0E 00           ld c,0  ;BC = Bytes to transfer
0289+  4905 DD 7E 00        ld a,(ix)   ;Command is 28h to read or 2Ah to write
0290+  4908 1F              rra
0291+  4909 1F              rra     ;Now Cy=0 to read or 1 to write
0292+  490A 3E 01           ld a,1  ;Retry "media changed"
0293+  490C             
0294+  490C DD E5           push ix
0295+  490E CD 7C 53        call USB_EXECUTE_CBI_WITH_RETRY
0296+  4911 DD E1           pop ix
0297+  4913             
0298+  4913 B7              or a
0299+  4914 3E 0C           ld a,12
0300+  4916 37              scf
0301+  4917 C0              ret nz   ;Return "other error" on USB error
0302+  4918             
0303+  4918 DD 7E 00        ld a,(ix)
0304+  491B FE 2A           cp 2Ah
0305+  491D 28 06           jr z,_DSKIO_DO_SECTOR_TX_2
0306+  491F 78              ld a,b
0307+  4920 FE 02           cp 2
0308+  4922 3E 0C           ld a,12
0309+  4924 D8              ret c  ;Return "other error" if no whole sector was read
0310+  4925             
0311+  4925             _DSKIO_DO_SECTOR_TX_2:
0312+  4925 7A              ld a,d
0313+  4926 B7              or a
0314+  4927 C8              ret z   ;Success if ASC = 0
0315+  4928             
0316+  4928 C3 A7 54        jp ASC_TO_ERR
0317+  492B             
0318+  492B             _UFI_READ_SECTOR_CMD:
0319+  492B                 db 28h, 0, 0, 0, 255, 255, 0, 0, 1, 0, 0, 0   ;bytes 4 and 5 = sector number, byte 8 = transfer length
0319+  492B 28000000FFFF000001000000
0320+  4937             
0321+  4937             ;_UFI_WRITE_SECTOR_CMD:
0322+  4937             ;    db 2Ah, 0, 0, 0, 255, 255, 0, 0, 1, 0, 0, 0   ;bytes 4 and 5 = sector number, byte 8 = transfer length
0323+  4937             
0324+  4937             CALL_XFER:
0325+  4937 DD E5           push ix
0326+  4939 FD 21 00 00     ld iy,ROM_BANK_0
0327+  493D DD 21 6E F3     ld ix,XFER
0328+  4941 CD D2 7F        call CALL_BANK
0329+  4944 DD E1           pop ix
0330+  4946 C9              ret
0331+  4947             
0332+  4947             
0333+  4947                 ;=== DSKIO for storage devices (mounted file) ===
0334+  4947             
0335+  4947             _DSKIO_IMPL_STDEV:
0336+  4947                 ; Wait for VDP interrupt.
0337+  4947             	; This introduces a small delay that is required by some games.
0338+  4947             
0339+  4947 F5              push af
0340+  4948 F3          	di
0341+  4949 3E 02       	ld	a,2
0342+  494B D3 99       	out	(99h),a
0343+  494D 3E 8F       	ld	a,8fh
0344+  494F D3 99       	out	(99h),a
0345+  4951             WVDP:
0346+  4951 DB 99       	in	a,(99h)
0347+  4953 E6 81       	and	81h
0348+  4955 3D          	dec	a
0349+  4956 28 F9       	jr	z,WVDP
0350+  4958 AF          	xor	a
0351+  4959 D3 99       	out	(99h),a
0352+  495B 3E 8F       	ld	a,8fh
0353+  495D D3 99       	out	(99h),a
0354+  495F F1              pop af
0355+  4960             
0356+  4960 CD 65 4A        call MAYBE_CHANGE_DSK
0357+  4963             
0358+  4963 E5              push hl
0359+  4964 C5              push bc
0360+  4965             
0361+  4965 CD E5 4F        call WK_GET_STORAGE_DEV_FLAGS
0362+  4968 E6 FB           and 0FBh    ;reset  "Disk changed" flag
0363+  496A CD F8 4F        call WK_SET_STORAGE_DEV_FLAGS
0364+  496D             
0365+  496D 26 00           ld h,0
0366+  496F 6A              ld l,d
0367+  4970 53              ld d,e
0368+  4971 1E 00           ld e,0
0369+  4973 CB 22           sla d
0370+  4975 CB 15           rl l
0371+  4977 CB 14           rl h    ;HLDE = DE*512
0372+  4979 CD D7 42        call HWF_SEEK_FILE
0373+  497C             
0374+  497C C1              pop bc
0375+  497D E1              pop hl
0376+  497E 48              ld c,b
0377+  497F 06 00           ld b,0
0378+  4981 B7              or a
0379+  4982 28 13           jr z,_DSKIO_IMPL_STDEV_SEEKOK
0380+  4984             
0381+  4984 CD E5 4F        call WK_GET_STORAGE_DEV_FLAGS
0382+  4987 E6 81           and 81h
0383+  4989 FE 80           cp 80h
0384+  498B CA 3F 4A        jp z,_DSKIO_IMPL_POPAF_RET_ERR  ;Storage device but no disk mounted
0385+  498E             
0386+  498E E1              pop hl  ;Discard input AF
0387+  498F 3D              dec a
0388+  4990 3E 08           ld a,8  ;Record not found
0389+  4992 37              scf
0390+  4993 C8              ret z
0391+  4994 3E 0C           ld a,12 ;Other error
0392+  4996 C9              ret
0393+  4997             
0394+  4997             _DSKIO_IMPL_STDEV_SEEKOK:
0395+  4997 41              ld b,c
0396+  4998             
0397+  4998 CD AA 6D        call DSK_TEST_CAPS_LIT_WK
0398+  499B 20 03           jr nz,_DSKIO_IMPL_STDEV_GO_CAPS
0399+  499D F1              pop af
0400+  499E 18 0B           jr _DSKIO_IMPL_STDEV_GO
0401+  49A0             
0402+  49A0             _DSKIO_IMPL_STDEV_GO_CAPS:
0403+  49A0 F1              pop af
0404+  49A1 CD 0C 57        call CAPSON
0405+  49A4 CD AB 49        call _DSKIO_IMPL_STDEV_GO
0406+  49A7 CD 15 57        call CAPSOFF
0407+  49AA C9              ret
0408+  49AB             
0409+  49AB             _DSKIO_IMPL_STDEV_GO:
0410+  49AB DA EF 49        jp c,_DSKIO_IMPL_STDEW_WRITE
0411+  49AE             
0412+  49AE             
0413+  49AE                 ;=== DSKIO for storage devices - READ ===
0414+  49AE             
0415+  49AE             _DSKIO_IMPL_STDEW_READ:
0416+  49AE EB              ex de,hl
0417+  49AF CD 46 4A        call CHECK_XFER_IS_NEEDED
0418+  49B2 EB              ex de,hl
0419+  49B3 38 10           jr c,_DSKIO_R_STDEV_XFER
0420+  49B5             
0421+  49B5                 ;* Direct transfer
0422+  49B5             
0423+  49B5             _DSKIO_R_STDEV_DIRECT:
0424+  49B5 CB 20           sla b
0425+  49B7 0E 00           ld c,0  ;BC = B*512
0426+  49B9 CD 0A 43        call HWF_READ_FILE
0427+  49BC CB 38           srl b  ;B = BC/512
0428+  49BE             
0429+  49BE B7              or a
0430+  49BF 3E 0C           ld a,12
0431+  49C1 37              scf
0432+  49C2 C0              ret nz
0433+  49C3                 
0434+  49C3 AF              xor a
0435+  49C4 C9              ret
0436+  49C5             
0437+  49C5                 ;* Transfer using XFER
0438+  49C5             
0439+  49C5             _DSKIO_R_STDEV_XFER:
0440+  49C5 0E 00           ld c,0
0441+  49C7             _DSKIO_R_STDEV_XFER_LOOP:
0442+  49C7 C5              push bc ;B=Sectors left, C=Sectors transferred
0443+  49C8 E5              push hl ;Dest address
0444+  49C9             
0445+  49C9 2A 4D F3        ld hl,(SECBUF)
0446+  49CC 01 00 02        ld bc,512
0447+  49CF CD 0A 43        call HWF_READ_FILE
0448+  49D2 B7              or a
0449+  49D3 20 63           jr nz,_DSKIO_IMPL_STDEV_XFER_ERR
0450+  49D5 78              ld a,b
0451+  49D6 FE 02           cp 2
0452+  49D8 38 5E           jr c,_DSKIO_IMPL_STDEV_XFER_ERR ;Error if less than 1 sector transferred
0453+  49DA             
0454+  49DA D1              pop de
0455+  49DB D5              push de
0456+  49DC             
0457+  49DC 2A 4D F3        ld hl,(SECBUF)
0458+  49DF 01 00 02        ld bc,512
0459+  49E2 CD 37 49        call CALL_XFER
0460+  49E5             
0461+  49E5 E1              pop hl
0462+  49E6 C1              pop bc
0463+  49E7 0C              inc c
0464+  49E8 24              inc h
0465+  49E9 24              inc h   ;HL=HL+512
0466+  49EA 10 DB           djnz _DSKIO_R_STDEV_XFER_LOOP
0467+  49EC             
0468+  49EC 41              ld b,c
0469+  49ED AF              xor a
0470+  49EE C9              ret
0471+  49EF             
0472+  49EF             
0473+  49EF                 ;=== DSKIO for storage devices - WRITE ===
0474+  49EF             
0475+  49EF             _DSKIO_IMPL_STDEW_WRITE:
0476+  49EF CD E5 4F        call WK_GET_STORAGE_DEV_FLAGS
0477+  49F2 E6 02           and 2   ;Read only?
0478+  49F4 3E 00           ld a,0
0479+  49F6 37              scf
0480+  49F7 C0              ret nz
0481+  49F8             
0482+  49F8 EB              ex de,hl
0483+  49F9 CD 46 4A        call CHECK_XFER_IS_NEEDED
0484+  49FC EB              ex de,hl
0485+  49FD 38 10           jr c,_DSKIO_W_STDEV_XFER
0486+  49FF             
0487+  49FF                 ;* Direct transfer
0488+  49FF             
0489+  49FF             _DSKIO_W_STDEV_DIRECT:
0490+  49FF CB 20           sla b
0491+  4A01 0E 00           ld c,0  ;BC = B*512
0492+  4A03 CD 37 43        call HWF_WRITE_FILE
0493+  4A06 CB 38           srl b  ;B = BC/512
0494+  4A08             
0495+  4A08 B7              or a
0496+  4A09 3E 0C           ld a,12
0497+  4A0B 37              scf
0498+  4A0C C0              ret nz
0499+  4A0D                 
0500+  4A0D AF              xor a
0501+  4A0E C9              ret
0502+  4A0F             
0503+  4A0F                 ;* Transfer using XFER
0504+  4A0F             
0505+  4A0F             _DSKIO_W_STDEV_XFER:
0506+  4A0F 0E 00           ld c,0
0507+  4A11             _DSKIO_W_STDEV_XFER_LOOP:
0508+  4A11 C5              push bc ;B=Sectors left, C=Sectors transferred
0509+  4A12 E5              push hl ;Src address
0510+  4A13             
0511+  4A13 ED 5B 4D F3     ld de,(SECBUF)
0512+  4A17 01 00 02        ld bc,512
0513+  4A1A CD 37 49        call CALL_XFER
0514+  4A1D             
0515+  4A1D 2A 4D F3        ld hl,(SECBUF)
0516+  4A20 01 00 02        ld bc,512
0517+  4A23 CD 37 43        call HWF_WRITE_FILE
0518+  4A26 B7              or a
0519+  4A27 20 0F           jr nz,_DSKIO_IMPL_STDEV_XFER_ERR
0520+  4A29 78              ld a,b
0521+  4A2A FE 02           cp 2
0522+  4A2C 38 0A           jr c,_DSKIO_IMPL_STDEV_XFER_ERR ;Error if less than 1 sector transferred
0523+  4A2E             
0524+  4A2E E1              pop hl
0525+  4A2F C1              pop bc
0526+  4A30 0C              inc c
0527+  4A31 24              inc h
0528+  4A32 24              inc h   ;HL=HL+512
0529+  4A33 10 DC           djnz _DSKIO_W_STDEV_XFER_LOOP
0530+  4A35             
0531+  4A35 41              ld b,c
0532+  4A36 AF              xor a
0533+  4A37 C9              ret
0534+  4A38             
0535+  4A38             
0536+  4A38                 ;=== DSKIO for storage devices - common ===
0537+  4A38             
0538+  4A38             _DSKIO_IMPL_STDEV_XFER_ERR:
0539+  4A38 E1              pop hl
0540+  4A39 C1              pop bc
0541+  4A3A 41              ld b,c
0542+  4A3B 3E 0C           ld a,12
0543+  4A3D 37              scf
0544+  4A3E C9              ret
0545+  4A3F             
0546+  4A3F             _DSKIO_IMPL_POPAF_RET_ERR:
0547+  4A3F F1              pop af
0548+  4A40 06 00           ld b,0
0549+  4A42 3E 02           ld a,2
0550+  4A44 37              scf
0551+  4A45 C9              ret
0552+  4A46             
0553+  4A46             
0554+  4A46                 ;-- Check if transfer can be done directly or if we need to use XFER
0555+  4A46                 ;   (XFER will be needed if page 1 is involved in the transfer).
0556+  4A46                 ;
0557+  4A46                 ;   Input:  DE = Transfer address
0558+  4A46                 ;           B  = How many sectors to transfer
0559+  4A46                 ;   Output: Cy = 0 if direct transfer is possible
0560+  4A46                 ;                1 if XFER is needed
0561+  4A46             
0562+  4A46             CHECK_XFER_IS_NEEDED:
0563+  4A46 3A 6E F3        ld a,(XFER)
0564+  4A49 FE C9           cp 0C9h
0565+  4A4B C8              ret z   ;Sanity check: we can't use XFER if it isn't enabled
0566+  4A4C             
0567+  4A4C CB 7A           bit 7,d
0568+  4A4E 37              scf
0569+  4A4F 3F              ccf
0570+  4A50 C0              ret nz    ;Transfer starts at >= 8000h, so direct ok
0571+  4A51 CB 72           bit 6,d
0572+  4A53 37              scf
0573+  4A54 C0              ret nz    ;Transfer starts at >= 4000h and <8000h, so XFER needed
0574+  4A55 D5              push de
0575+  4A56 C5              push bc
0576+  4A57 EB              ex de,hl
0577+  4A58 CB 20           sla b
0578+  4A5A 0E 00           ld c,0  ;BC = Sectors * 512
0579+  4A5C 09              add hl,bc
0580+  4A5D 2B              dec hl  ;Now HL = Last transfer address
0581+  4A5E C1              pop bc
0582+  4A5F D1              pop de
0583+  4A60 7C              ld a,h
0584+  4A61 FE 40           cp 40h  ;If transfer starts at <4000h, it must end at <4000h for direct transfer
0585+  4A63 3F              ccf
0586+  4A64 C9              ret
0587+  4A65             
0588+  4A65             
0589+  4A65                 ;=== Handle possible disk image file change ===
0590+  4A65             
0591+  4A65             MAYBE_CHANGE_DSK:
0592+  4A65 F5              push af
0593+  4A66 E5          	push	hl
0594+  4A67 D5          	push	de
0595+  4A68 C5          	push	bc
0596+  4A69 DD E5       	push	ix
0597+  4A6B FD E5       	push	iy
0598+  4A6D FD 21 BF FF     ld iy,-65
0599+  4A71 FD 39           add iy,sp
0600+  4A73 FD F9           ld sp,iy
0601+  4A75 CD 89 4A    	call	_MAYBE_CHANGE_DSK
0602+  4A78 FD 21 41 00     ld iy,65
0603+  4A7C FD 39           add iy,sp
0604+  4A7E FD F9           ld sp,iy
0605+  4A80 FD E1       	pop	iy
0606+  4A82 DD E1       	pop	ix
0607+  4A84 C1          	pop	bc
0608+  4A85 D1          	pop	de
0609+  4A86 E1          	pop	hl
0610+  4A87 F1              pop af
0611+  4A88 C9          	ret
0612+  4A89             
0613+  4A89             _MAYBE_CHANGE_DSK:
0614+  4A89 FD E5           push iy
0615+  4A8B CD E5 56        call GETCURKEY
0616+  4A8E FD E1           pop iy
0617+  4A90 B7              or a
0618+  4A91 C8              ret z
0619+  4A92 FE FF           cp 0FFh
0620+  4A94 20 1E           jr nz,CHGF3
0621+  4A96             
0622+  4A96 CD 0C 57        call CAPSON
0623+  4A99 CD 05 57        call WAIT_KEY_RELEASE ;CODE/KANA pressed: wait for other keys to release...
0624+  4A9C             
0625+  4A9C             CHGWA2:
0626+  4A9C CD 0C 57        call CAPSON
0627+  4A9F             CHGWA22:
0628+  4A9F FD E5           push iy
0629+  4AA1 CD E5 56    	call	GETCURKEY	;...then to be pressed again.
0630+  4AA4 FD E1           pop iy
0631+  4AA6 B7          	or	a
0632+  4AA7 28 F6       	jr	z,CHGWA22
0633+  4AA9             
0634+  4AA9 FE FF           cp 0FFh      ;User changed his mind and pressed GRAPH 
0635+  4AAB 20 07           jr nz,CHGF3
0636+  4AAD             
0637+  4AAD CD 05 57        call WAIT_KEY_RELEASE
0638+  4AB0 CD 15 57        call CAPSOFF
0639+  4AB3 C9              ret
0640+  4AB4             
0641+  4AB4             CHGF3:
0642+  4AB4 4F          	ld	c,a
0643+  4AB5 CD 15 57    	call	CAPSOFF
0644+  4AB8             
0645+  4AB8                 ;--- The key with index C is pressed
0646+  4AB8             
0647+  4AB8 C5              push bc
0648+  4AB9 FD E5           push iy
0649+  4ABB E1              pop hl
0650+  4ABC CD 1A 6A        call DSK_GET_CURDIR
0651+  4ABF C1              pop bc
0652+  4AC0             
0653+  4AC0 79              ld a,c
0654+  4AC1 3D              dec a
0655+  4AC2 FD E5           push iy
0656+  4AC4 E1              pop hl
0657+  4AC5 E5              push hl
0658+  4AC6 CD 4C 42        call HWF_FIND_NTH_FILE
0659+  4AC9 E1              pop hl
0660+  4ACA B7              or a
0661+  4ACB 20 CF           jr nz,CHGWA2
0662+  4ACD             
0663+  4ACD 11 0C 00        ld de,12
0664+  4AD0 19              add hl,de
0665+  4AD1 EB              ex de,hl
0666+  4AD2 FD E5           push iy
0667+  4AD4 E1              pop hl
0668+  4AD5 D5              push de
0669+  4AD6 CD 3D 5D        call BM_GENERATE_FILENAME
0670+  4AD9 E1              pop hl
0671+  4ADA             
0672+  4ADA AF              xor a
0673+  4ADB CD 4A 69        call DSK_MOUNT
0674+  4ADE B7              or a
0675+  4ADF 20 BB           jr nz,CHGWA2
0676+  4AE1             
0677+  4AE1             CHGF_END:
0678+  4AE1 CD 05 57        call WAIT_KEY_RELEASE
0679+  4AE4 CD 1E 57        call MYKILBUF
0680+  4AE7 CD 15 57        call CAPSOFF
0681+  4AEA C9              ret
0682+  4AEB             
0683+  4AEB             ; -----------------------------------------------------------------------------
0684+  4AEB             ; DSKCHG
0685+  4AEB             ; -----------------------------------------------------------------------------
0686+  4AEB             ; Input: 	A	Drivenumber
0687+  4AEB             ; 		B	0
0688+  4AEB             ; 		C	Media descriptor
0689+  4AEB             ; 		HL	pointer to DPB
0690+  4AEB             ; Output:	F	Cx set for error
0691+  4AEB             ;			Cx reset for ok
0692+  4AEB             ;		A	if error, errorcode
0693+  4AEB             ;		B	if no error, disk change status
0694+  4AEB             ;			01 disk unchanged
0695+  4AEB             ;			00 unknown
0696+  4AEB             ;			FF disk changed
0697+  4AEB             ; Changed:	AF,BC,DE,HL,IX,IY may be affected
0698+  4AEB             ; Remark:	DOS1 kernel expects the DPB updated when disk change status is
0699+  4AEB             ;               unknown or changed DOS2 kernel does not care if the DPB is
0700+  4AEB             ;               updated or not		
0701+  4AEB             ; -----------------------------------------------------------------------------
0702+  4AEB             
0703+  4AEB             DSKCHG_IMPL:
0704+  4AEB CD 14 55        call CHECK_SAME_DRIVE
0705+  4AEE             
0706+  4AEE FE 02           cp 2
0707+  4AF0 3E 0C           ld a,12
0708+  4AF2 3F              ccf
0709+  4AF3 D8              ret c
0710+  4AF4             
0711+  4AF4 E5              push hl
0712+  4AF5 CD 5B 50        call USB_CHECK_DEV_CHANGE
0713+  4AF8 E1              pop hl
0714+  4AF9 3E 0C           ld a,12
0715+  4AFB D8              ret c   ;No device is connected
0716+  4AFC             
0717+  4AFC F5              push af
0718+  4AFD CD E5 4F        call WK_GET_STORAGE_DEV_FLAGS
0719+  4B00 C2 14 4B        jp nz,_DSKCHG_IMPL_STDEV
0720+  4B03 F1              pop af
0721+  4B04             
0722+  4B04 E5              push hl
0723+  4B05 CD CC 54        call TEST_DISK
0724+  4B08 E1              pop hl
0725+  4B09 D8              ret c
0726+  4B0A             
0727+  4B0A 78              ld a,b
0728+  4B0B 3D              dec a   ;Disk unchanged?
0729+  4B0C C8              ret z
0730+  4B0D             
0731+  4B0D C5              push bc
0732+  4B0E CD 36 4B        call GETDPB_IMPL
0733+  4B11 C1              pop bc
0734+  4B12 AF              xor a
0735+  4B13 C9              ret
0736+  4B14             
0737+  4B14             _DSKCHG_IMPL_STDEV:
0738+  4B14 E6 81           and 81h
0739+  4B16 FE 80           cp 80h
0740+  4B18 CA 3F 4A        jp z,_DSKIO_IMPL_POPAF_RET_ERR  ;Storage device but no disk mounted
0741+  4B1B             
0742+  4B1B CD 65 4A        call MAYBE_CHANGE_DSK
0743+  4B1E             
0744+  4B1E F1              pop af
0745+  4B1F                 
0746+  4B1F CD E5 4F        call WK_GET_STORAGE_DEV_FLAGS
0747+  4B22 E6 04           and 4
0748+  4B24 3E 00           ld a,0
0749+  4B26 06 01           ld b,1  ;Unchanged
0750+  4B28 C8              ret z
0751+  4B29 CD 36 4B        call GETDPB_IMPL
0752+  4B2C AF              xor a
0753+  4B2D 06 FF           ld b,0FFh   ;Changed
0754+  4B2F C9              ret
0755+  4B30             
0756+  4B30             
0757+  4B30             ; -----------------------------------------------------------------------------
0758+  4B30             ; GETDPB
0759+  4B30             ; -----------------------------------------------------------------------------
0760+  4B30             ; Input: 	A	Drivenumber
0761+  4B30             ; 		B	first byte of FAT
0762+  4B30             ; 		C	Media descriptor
0763+  4B30             ; 		HL	pointer to DPB
0764+  4B30             ; Output:	[HL+1]
0765+  4B30             ;		..
0766+  4B30             ;		[HL+18]	updated
0767+  4B30             ; Changed:	AF,BC,DE,HL,IX,IY may be affected
0768+  4B30             ; -----------------------------------------------------------------------------
0769+  4B30             
0770+  4B30             ; This routine was borrowed from https://github.com/joyrex2001/dsk2rom
0771+  4B30             
0772+  4B30             GETDPBERR:
0773+  4B30 C1          	pop  bc
0774+  4B31 F1          	pop  af
0775+  4B32 3E 0C       	ld   a,12
0776+  4B34 37          	scf
0777+  4B35 C9          	ret
0778+  4B36             GETDPB_IMPL:
0779+  4B36 F5          	push af 
0780+  4B37 C5          	push bc 
0781+  4B38 E5          	push hl 
0782+  4B39 2A 4D F3    	ld   hl,(SECBUF)
0783+  4B3C E5          	push hl
0784+  4B3D 06 01       	ld   b,1
0785+  4B3F 11 00 00    	ld   de,0 
0786+  4B42 B7          	or   a 
0787+  4B43 0E FF       	ld   c,0FFh 
0788+  4B45 CD EC 47    	call DSKIO_IMPL
0789+  4B48 FD E1       	pop  iy 
0790+  4B4A E1          	pop  hl 
0791+  4B4B 38 E3       	jr   c,GETDPBERR
0792+  4B4D 23          	inc  hl
0793+  4B4E E5          	push hl
0794+  4B4F EB          	ex   de,hl
0795+  4B50 21 B8 6D    	ld   hl,DEFDPB_1+1
0796+  4B53 01 12 00    	ld   bc,18
0797+  4B56 ED B0       	ldir
0798+  4B58 E1          	pop  hl
0799+  4B59 FD 7E 15    	ld   a,(iy+21)
0800+  4B5C FE F9       	cp   0F9h
0801+  4B5E 28 7E       	jr   z,GETDPBEND 
0802+  4B60 77          	ld   (hl),a
0803+  4B61 23          	inc  hl
0804+  4B62 FD 7E 0B    	ld   a,(iy+11)
0805+  4B65 77          	ld   (hl),a
0806+  4B66 23          	inc  hl
0807+  4B67 FD 7E 0C    	ld   a,(iy+12)
0808+  4B6A 77          	ld   (hl),a
0809+  4B6B 23          	inc  hl
0810+  4B6C 36 0F       	ld   (hl),0Fh
0811+  4B6E 23          	inc  hl
0812+  4B6F 36 04       	ld   (hl),04h
0813+  4B71 23          	inc  hl
0814+  4B72 FD 7E 0D    	ld   a,(iy+0Dh)
0815+  4B75 3D          	dec  a
0816+  4B76 77          	ld   (hl),a
0817+  4B77 23          	inc  hl
0818+  4B78 C6 01       	add  a,1
0819+  4B7A 06 00       	ld   b,0
0820+  4B7C             GETDPB0: 
0821+  4B7C 04          	inc  b
0822+  4B7D 1F          	rra 
0823+  4B7E 30 FC       	jr   nc,GETDPB0
0824+  4B80 70          	ld   (hl),b
0825+  4B81 23          	inc  hl
0826+  4B82 C5          	push bc
0827+  4B83 FD 7E 0E    	ld   a,(iy+0Eh)
0828+  4B86 77          	ld   (hl),a
0829+  4B87 23          	inc  hl
0830+  4B88 FD 56 0F    	ld   d,(iy+0Fh)
0831+  4B8B 72          	ld   (hl),d
0832+  4B8C 23          	inc  hl
0833+  4B8D FD 46 10    	ld   b,(iy+010h)
0834+  4B90 70          	ld   (hl),b
0835+  4B91 23          	inc  hl
0836+  4B92             GETDPB1: 
0837+  4B92 FD 86 16    	add  a,(iy+016h)
0838+  4B95 30 01       	jr   nc,GETDPB2
0839+  4B97 14          	inc  d
0840+  4B98             GETDPB2: 
0841+  4B98 10 F8       	djnz GETDPB1
0842+  4B9A 4F          	ld   c,a
0843+  4B9B 42          	ld   b,d
0844+  4B9C FD 5E 11    	ld   e,(iy+011h)
0845+  4B9F FD 56 12    	ld   d,(iy+012h)
0846+  4BA2 7A          	ld   a,d
0847+  4BA3 B7          	or   a
0848+  4BA4 3E FE       	ld   a,0FEh
0849+  4BA6 20 01       	jr   nz,GETDPB3
0850+  4BA8 7B          	ld   a,e
0851+  4BA9             GETDPB3: 
0852+  4BA9 77          	ld   (hl),a
0853+  4BAA 23          	inc  hl
0854+  4BAB 1B          	dec  de
0855+  4BAC 3E 04       	ld   a,4
0856+  4BAE             GETDPB4: 
0857+  4BAE CB 3A       	srl  d
0858+  4BB0 CB 1B       	rr   e
0859+  4BB2 3D          	dec  a
0860+  4BB3 20 F9       	jr   nz,GETDPB4
0861+  4BB5 13          	inc  de
0862+  4BB6 EB          	ex   de,hl
0863+  4BB7 09          	add  hl,bc
0864+  4BB8 EB          	ex   de,hl
0865+  4BB9 73          	ld   (hl),e
0866+  4BBA 23          	inc  hl
0867+  4BBB 72          	ld   (hl),d
0868+  4BBC 23          	inc  hl
0869+  4BBD FD 7E 13    	ld   a,(iy+013h)
0870+  4BC0 93          	sub  e
0871+  4BC1 5F          	ld   e,a
0872+  4BC2 FD 7E 14    	ld   a,(iy+014h)
0873+  4BC5 9A          	sbc  a,d
0874+  4BC6 57          	ld   d,a
0875+  4BC7 F1          	pop  af
0876+  4BC8             GETDPB5: 
0877+  4BC8 3D          	dec  a
0878+  4BC9 28 06       	jr   z,GETDPB6
0879+  4BCB CB 3A       	srl  d
0880+  4BCD CB 1B       	rr   e
0881+  4BCF 18 F7       	jr   GETDPB5
0882+  4BD1             GETDPB6:
0883+  4BD1 13          	inc  de
0884+  4BD2 73          	ld   (hl),e
0885+  4BD3 23          	inc  hl
0886+  4BD4 72          	ld   (hl),d
0887+  4BD5 23          	inc  hl
0888+  4BD6 FD 7E 16    	ld   a,(iy+016h)
0889+  4BD9 77          	ld   (hl),a
0890+  4BDA 23          	inc  hl
0891+  4BDB 71          	ld   (hl),c
0892+  4BDC 23          	inc  hl
0893+  4BDD 70          	ld   (hl),b
0894+  4BDE             GETDPBEND: 
0895+  4BDE C1          	pop  bc
0896+  4BDF F1          	pop  af 
0897+  4BE0 AF          	xor  a
0898+  4BE1 C9          	ret
0899+  4BE2             
0900+  4BE2             
0901+  4BE2             ;Debug DSKIO
0902+  4BE2             
0903+  4BE2                 if DEBUG_DSKIO=1
0904+  4BE2~            
0905+  4BE2~            CHGCLR: equ 0062h
0906+  4BE2~            INIPLT: equ 0141h
0907+  4BE2~            EXTROM: equ 015Fh
0908+  4BE2~            BEEP:   equ 00C0h
0909+  4BE2~            
0910+  4BE2~            DO_DEBUG_DSKIO:
0911+  4BE2~                push af
0912+  4BE2~                push bc
0913+  4BE2~                push hl
0914+  4BE2~                push de
0915+  4BE2~            
0916+  4BE2~                ld ix,INITXT
0917+  4BE2~                call CALBIOS
0918+  4BE2~            
0919+  4BE2~                ld a,15
0920+  4BE2~                ld (0F3E9h),a
0921+  4BE2~                ld a,1
0922+  4BE2~                ld (0F3EAh),a
0923+  4BE2~                ld ix,CHGCLR
0924+  4BE2~                call CALBIOS
0925+  4BE2~            
0926+  4BE2~                pop hl  ;Secnum (was DE)
0927+  4BE2~                push hl
0928+  4BE2~                call PRINTHEXBIOS_HL
0929+  4BE2~                call PRINTSPACE
0930+  4BE2~            
0931+  4BE2~                pop de
0932+  4BE2~                pop hl
0933+  4BE2~                push hl     ;Dest address
0934+  4BE2~                push de
0935+  4BE2~                call PRINTHEXBIOS_HL
0936+  4BE2~                call PRINTSPACE
0937+  4BE2~            
0938+  4BE2~                pop de
0939+  4BE2~                pop hl
0940+  4BE2~                pop bc
0941+  4BE2~                push bc
0942+  4BE2~                push hl
0943+  4BE2~                push de
0944+  4BE2~                ld a,b  ;Sec count
0945+  4BE2~                call PRINTHEXBIOS
0946+  4BE2~            
0947+  4BE2~                ld ix,CHGET
0948+  4BE2~                call CALBIOS
0949+  4BE2~            
0950+  4BE2~                pop de
0951+  4BE2~                pop hl
0952+  4BE2~                pop bc
0953+  4BE2~                push bc
0954+  4BE2~                push hl
0955+  4BE2~                push de
0956+  4BE2~            
0957+  4BE2~            BEEPS:
0958+  4BE2~                push bc
0959+  4BE2~                ld ix,BEEP
0960+  4BE2~                call CALBIOS
0961+  4BE2~                pop bc
0962+  4BE2~                djnz BEEPS
0963+  4BE2~            
0964+  4BE2~                pop de
0965+  4BE2~                pop hl
0966+  4BE2~                pop bc
0967+  4BE2~                pop af
0968+  4BE2~            
0969+  4BE2~                ret
0970+  4BE2~            
0971+  4BE2~            
0972+  4BE2~            CALBIOS:
0973+  4BE2~                ld iy,0
0974+  4BE2~                jp CALSLT
0975+  4BE2~            
0976+  4BE2~            PRINTSPACE:
0977+  4BE2~                ld a," "
0978+  4BE2~            PRINTBIOS:
0979+  4BE2~                ld ix,CHPUT
0980+  4BE2~                jp CALBIOS
0981+  4BE2~            
0982+  4BE2~            PRINTHEXBIOS_HL:
0983+  4BE2~                ld a,h
0984+  4BE2~                call PRINTHEXBIOS
0985+  4BE2~                ld a,l
0986+  4BE2~            PRINTHEXBIOS:
0987+  4BE2~                push af
0988+  4BE2~            	call	_PRINTHEXBIOS1
0989+  4BE2~            	pop af
0990+  4BE2~            	jr	_PRINTHEXBIOS2
0991+  4BE2~            
0992+  4BE2~            _PRINTHEXBIOS1:	rra
0993+  4BE2~            	rra
0994+  4BE2~            	rra
0995+  4BE2~            	rra
0996+  4BE2~            _PRINTHEXBIOS2:	or	0F0h
0997+  4BE2~            	daa
0998+  4BE2~            	add	a,0A0h
0999+  4BE2~            	adc	a,40h
1000+  4BE2~            
1001+  4BE2~            	call PRINTBIOS
1002+  4BE2~            	ret
1003+  4BE2~            
1004+  4BE2                 endif
0057   4BE2                 include "bank1/choice_dskfmt.asm"    
0001+  4BE2             ; MSXUSB USB FDD BIOS
0002+  4BE2             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003+  4BE2             ; This version is adapted to work with the latest version of the MSXUSB project
0004+  4BE2             ;
0005+  4BE2             ; This file contains the implementation of the CHOICE and DSKFMT
0006+  4BE2             ; driver routines.
0007+  4BE2             
0008+  4BE2             
0009+  4BE2             ; Error codes used by DSKFMT:
0010+  4BE2             ;
0011+  4BE2             ; 0	write protect error
0012+  4BE2             ; 2	not ready error
0013+  4BE2             ; 4	data (crc) error
0014+  4BE2             ; 6	seek error
0015+  4BE2             ; 8	record not found error
0016+  4BE2             ; 10 write fault error
0017+  4BE2             ; 12 bad parameter
0018+  4BE2             ; 14 insufficient memory
0019+  4BE2             ; 16 other error
0020+  4BE2             
0021+  4BE2             
0022+  4BE2             ; -----------------------------------------------------------------------------
0023+  4BE2             ; CHOICE
0024+  4BE2             ; -----------------------------------------------------------------------------
0025+  4BE2             ; Input: 	None
0026+  4BE2             ; Output:	HL	pointer to choice string, 0 if no choice
0027+  4BE2             ; Changed:	AF,BC,DE,HL,IX,IY may be affected
0028+  4BE2             ; -----------------------------------------------------------------------------
0029+  4BE2             
0030+  4BE2             CHOICE_IMPL:
0031+  4BE2 CD E5 4F        call WK_GET_STORAGE_DEV_FLAGS
0032+  4BE5 21 00 00        ld hl,0
0033+  4BE8 C0              ret nz
0034+  4BE9             
0035+  4BE9 21 D9 74        ld hl,CHOICE_S
0036+  4BEC C9              ret
0037+  4BED             
0038+  4BED             
0039+  4BED             ; -----------------------------------------------------------------------------
0040+  4BED             ; DSKFMT
0041+  4BED             ; -----------------------------------------------------------------------------
0042+  4BED             ; Input: 	A	choicecode (1-9)
0043+  4BED             ;		D	drivenumber
0044+  4BED             ;		HL	begin of workarea
0045+  4BED             ;		BC	length of workarea
0046+  4BED             ; Output:	F	Cx set for error
0047+  4BED             ;			Cx reset for ok
0048+  4BED             ;		A	if error, errorcode
0049+  4BED             ; Changed:	AF,BC,DE,HL,IX,IY may be affected
0050+  4BED             ; -----------------------------------------------------------------------------
0051+  4BED             
0052+  4BED             DSKFMT_IMPL:
0053+  4BED 4F              ld c,a
0054+  4BEE 7A              ld a,d
0055+  4BEF CD 14 55        call CHECK_SAME_DRIVE
0056+  4BF2             
0057+  4BF2 CD E5 4F        call WK_GET_STORAGE_DEV_FLAGS
0058+  4BF5 3E 10           ld a,16
0059+  4BF7 37              scf
0060+  4BF8 C0              ret nz
0061+  4BF9             
0062+  4BF9 C5              push bc
0063+  4BFA CD EB 4A        call DSKCHG_IMPL    ;To eat a possible "not ready" error reported by
0064+  4BFD C1              pop bc              ;the device on disk change
0065+  4BFE             
0066+  4BFE 0D              dec c
0067+  4BFF             
0068+  4BFF                 ;Now C = bit 0: 0 for full format, 1 for quick format
0069+  4BFF                 ;        bit 1: 0 for 720K, 1 for 1440K
0070+  4BFF             
0071+  4BFF CB 19           rr c
0072+  4C01 38 09           jr c,_DSKFMT_QUICK
0073+  4C03             
0074+  4C03             _DSKFMT_FULL:
0075+  4C03 C5              push bc
0076+  4C04 CB 19           rr c
0077+  4C06 CD 20 4C        call PHYSICAL_FORMAT
0078+  4C09 C1              pop bc
0079+  4C0A 38 0C           jr c,_DSKFMT_END_ERR
0080+  4C0C             
0081+  4C0C             _DSKFMT_QUICK:
0082+  4C0C CB 19           rr c
0083+  4C0E CD 0E 4D        call LOGICAL_FORMAT
0084+  4C11 38 05           jr c,_DSKFMT_END_ERR
0085+  4C13 C9              ret
0086+  4C14             
0087+  4C14             _DSKFMT_BAD_PARAM:
0088+  4C14 3E 0C           ld a,12
0089+  4C16 37              scf
0090+  4C17 C9              ret
0091+  4C18             
0092+  4C18             _DSKFMT_END_ERR:
0093+  4C18 FE 0C           cp 12
0094+  4C1A 20 02           jr nz,_DSKFMT_END_ERR2
0095+  4C1C 3E 10           ld a,16
0096+  4C1E             _DSKFMT_END_ERR2:
0097+  4C1E 37              scf
0098+  4C1F C9              ret
0099+  4C20             
0100+  4C20             
0101+  4C20             ; ----------------------------------------------------------------------------
0102+  4C20             ; PHYSICAL_FORMAT
0103+  4C20             ; ----------------------------------------------------------------------------
0104+  4C20             ; Input:  Cy = 0 for 720K disk, 1 for 1.44M disk
0105+  4C20             ; Output: Cy = 0 if ok
0106+  4C20             ;         Cy = 1 and A=DSKFMT error code on error
0107+  4C20             
0108+  4C20             _PHYSICAL_FORMAT_STACK_SPACE: equ 12
0109+  4C20             _PHYSICAL_FORMAT_TRACKS_PER_SIDE_COUNT: equ 80
0110+  4C20             
0111+  4C20             PHYSICAL_FORMAT:
0112+  4C20                 if HW_IMPL_CONFIGURE_NAK_RETRY=1
0113+  4C20             
0114+  4C20 F5              push af
0115+  4C21 37              scf
0116+  4C22 CD E0 43        call HW_CONFIGURE_NAK_RETRY
0117+  4C25 F1              pop af
0118+  4C26 CD 30 4C        call _PHYSICAL_FORMAT
0119+  4C29 F5              push af
0120+  4C2A B7              or a
0121+  4C2B CD E0 43        call HW_CONFIGURE_NAK_RETRY
0122+  4C2E F1              pop af
0123+  4C2F C9              ret
0124+  4C30             _PHYSICAL_FORMAT:
0125+  4C30             
0126+  4C30                 endif
0127+  4C30             
0128+  4C30 21 C6 4C        ld hl,_UFI_FORMAT_UNIT_DATA_720K_SIDE_0
0129+  4C33 30 03           jr nc,_PHYSICAL_FORMAT_2
0130+  4C35 21 EA 4C        ld hl,_UFI_FORMAT_UNIT_DATA_1440K_SIDE_0
0131+  4C38             _PHYSICAL_FORMAT_2:
0132+  4C38             
0133+  4C38 3E 06           ld a,6
0134+  4C3A CD 38 55        call DO_SNSMAT
0135+  4C3D E6 01           and 1
0136+  4C3F 20 1C           jr nz,_PHYSICAL_FORMAT_DO_TRACK_BY_TRACK
0137+  4C41             
0138+  4C41                 ;Usually devices implement single track formatting only,
0139+  4C41                 ;so by default we'll format all the tracks one by one in a loop.
0140+  4C41                 ;However the single all tracks format command will be used
0141+  4C41                 ;if SHIFT is pressed (together with any other key)
0142+  4C41                 ;when the "Strike a key when ready" command is presented.
0143+  4C41             
0144+  4C41             _PHYSICAL_FORMAT_DO_ALL_TRACKS:
0145+  4C41 01 18 00        ld bc,24
0146+  4C44 09              add hl,bc   ;Point to the _ALL_TRACKS command data
0147+  4C45             
0148+  4C45 EB              ex de,hl
0149+  4C46 21 BA 4C        ld hl,_UFI_FORMAT_UNIT_CMD
0150+  4C49 01 0C 00        ld bc,12
0151+  4C4C 3E 01           ld a,1
0152+  4C4E 37              scf
0153+  4C4F CD 7C 53        call USB_EXECUTE_CBI_WITH_RETRY
0154+  4C52             
0155+  4C52 B7              or a
0156+  4C53 3E 0C           ld a,12
0157+  4C55 37              scf
0158+  4C56 C0              ret nz
0159+  4C57             
0160+  4C57 7A              ld a,d  ;non-zero ASC?
0161+  4C58 B7              or a
0162+  4C59 C8              ret z
0163+  4C5A             
0164+  4C5A C3 A7 54        jp ASC_TO_ERR
0165+  4C5D             
0166+  4C5D             _PHYSICAL_FORMAT_DO_TRACK_BY_TRACK:
0167+  4C5D DD 21 F4 FF     ld ix,-_PHYSICAL_FORMAT_STACK_SPACE
0168+  4C61 DD 39           add ix,sp
0169+  4C63 DD F9           ld sp,ix
0170+  4C65             
0171+  4C65 E5              push hl
0172+  4C66 DD E5           push ix
0173+  4C68 D1              pop de
0174+  4C69 21 BA 4C        ld hl,_UFI_FORMAT_UNIT_CMD
0175+  4C6C 01 0C 00        ld bc,12
0176+  4C6F ED B0           ldir
0177+  4C71 E1              pop hl
0178+  4C72             
0179+  4C72 E5              push hl
0180+  4C73 CD 8D 4C        call _PHYSICAL_FORMAT_ONE_SIDE
0181+  4C76 E1              pop hl
0182+  4C77 38 07           jr c,_PHYSICAL_FORMAT_END
0183+  4C79 01 0C 00        ld bc,12
0184+  4C7C 09              add hl,bc   ;Switch to the _SIDE_1 command
0185+  4C7D CD 8D 4C        call _PHYSICAL_FORMAT_ONE_SIDE
0186+  4C80             
0187+  4C80             _PHYSICAL_FORMAT_END:
0188+  4C80 F5              push af
0189+  4C81 E1              pop hl
0190+  4C82 DD 21 0C 00     ld ix,_PHYSICAL_FORMAT_STACK_SPACE
0191+  4C86 DD 39           add ix,sp
0192+  4C88 DD F9           ld sp,ix
0193+  4C8A E5              push hl
0194+  4C8B F1              pop af
0195+  4C8C C9              ret
0196+  4C8D             
0197+  4C8D                 ;Format all the tracks on one side of the disk
0198+  4C8D                 ;Input: IX=Command, HL=Data
0199+  4C8D             
0200+  4C8D             _PHYSICAL_FORMAT_ONE_SIDE:
0201+  4C8D 06 00           ld b,0  ;Track number
0202+  4C8F             
0203+  4C8F             _PHYSICAL_FORMAT_TRACK_LOOP:
0204+  4C8F DD 70 02        ld (ix+2),b
0205+  4C92             
0206+  4C92 DD E5           push ix
0207+  4C94 E5              push hl
0208+  4C95 C5              push bc
0209+  4C96             
0210+  4C96 EB              ex de,hl
0211+  4C97 DD E5           push ix
0212+  4C99 E1              pop hl
0213+  4C9A 01 0C 00        ld bc,12
0214+  4C9D 3E 01           ld a,1
0215+  4C9F 37              scf
0216+  4CA0 CD 7C 53        call USB_EXECUTE_CBI_WITH_RETRY
0217+  4CA3             
0218+  4CA3 C1              pop bc
0219+  4CA4 E1              pop hl
0220+  4CA5 DD E1           pop ix
0221+  4CA7             
0222+  4CA7 B7              or a
0223+  4CA8 3E 0C           ld a,12
0224+  4CAA 37              scf
0225+  4CAB C0              ret nz
0226+  4CAC             
0227+  4CAC 7A              ld a,d  ;non-zero ASC?
0228+  4CAD B7              or a
0229+  4CAE 28 03           jr z,_PHYSICAL_FORMAT_NEXT_TRACK
0230+  4CB0             
0231+  4CB0 C3 A7 54        jp ASC_TO_ERR
0232+  4CB3             
0233+  4CB3             _PHYSICAL_FORMAT_NEXT_TRACK:
0234+  4CB3 04              inc b
0235+  4CB4 78              ld a,b
0236+  4CB5 FE 50           cp _PHYSICAL_FORMAT_TRACKS_PER_SIDE_COUNT
0237+  4CB7 38 D6           jr c,_PHYSICAL_FORMAT_TRACK_LOOP
0238+  4CB9 C9              ret
0239+  4CBA             
0240+  4CBA             
0241+  4CBA             _UFI_FORMAT_UNIT_CMD:
0242+  4CBA                 db 4, 17h, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0
0242+  4CBA 04170000000000000C000000
0243+  4CC6             
0244+  4CC6             _UFI_FORMAT_UNIT_DATA_720K_SIDE_0:
0245+  4CC6                 db 0, 0B0h, 0, 8, 0, 0, 05h, 0A0h, 0, 0, 2, 0
0245+  4CC6 00B00008000005A000000200
0246+  4CD2             _UFI_FORMAT_UNIT_DATA_720K_SIDE_1:
0247+  4CD2                 db 0, 0B1h, 0, 8, 0, 0, 05h, 0A0h, 0, 0, 2, 0
0247+  4CD2 00B10008000005A000000200
0248+  4CDE             _UFI_FORMAT_UNIT_DATA_720K_ALL_TRACKS:
0249+  4CDE                 db 0, 0A0h, 0, 8, 0, 0, 05h, 0A0h, 0, 0, 2, 0
0249+  4CDE 00A00008000005A000000200
0250+  4CEA             
0251+  4CEA             _UFI_FORMAT_UNIT_DATA_1440K_SIDE_0:
0252+  4CEA                 db 0, 0B0h, 0, 8, 0, 0, 0Bh, 040h, 0, 0, 2, 0
0252+  4CEA 00B0000800000B4000000200
0253+  4CF6             _UFI_FORMAT_UNIT_DATA_1440K_SIDE_1:
0254+  4CF6                 db 0, 0B1h, 0, 8, 0, 0, 0Bh, 040h, 0, 0, 2, 0
0254+  4CF6 00B1000800000B4000000200
0255+  4D02             _UFI_FORMAT_UNIT_DATA_1440K_ALL_TRACKS:
0256+  4D02                 db 0, 0A0h, 0, 8, 0, 0, 0Bh, 040h, 0, 0, 2, 0    
0256+  4D02 00A0000800000B4000000200
0257+  4D0E             
0258+  4D0E             
0259+  4D0E             ; ----------------------------------------------------------------------------
0260+  4D0E             ; LOGICAL_FORMAT
0261+  4D0E             ;
0262+  4D0E             ; Initializes boot sector, FAT and root directory of the disk.
0263+  4D0E             ;
0264+  4D0E             ; MSX-DOS 1 doesn't support the standard 1.44MB format because this format
0265+  4D0E             ; uses 9 sectors per FAT, but DOS 1 loads the entire FAT in memory after
0266+  4D0E             ; having allocated just 1.5K (worth 3 sectors) for it.
0267+  4D0E             ; There isn't any validation so the computer just crashes.
0268+  4D0E             ;
0269+  4D0E             ; As a workaround for the above, this BIOS will apply a custom format
0270+  4D0E             ; of 3 sectors/FAT and 4 sectors/cluster when a 1.44MB is formatted
0271+  4D0E             ; in DOS 1 mode (I know, the driver shouldn't be aware of the DOS version
0272+  4D0E             ; under which it exists, but this is not a perfect world); in DOS2 mode
0273+  4D0E             ; the standard 9 sectors/FAT and 1 sector/cluster format will be applied.
0274+  4D0E             ; ----------------------------------------------------------------------------
0275+  4D0E             ; Input:  Cy = 0 for 720K disk
0276+  4D0E             ;              1 for 1.44M disk
0277+  4D0E             ; Output: Cy = 0 if ok
0278+  4D0E             ;         Cy = 1 and A=DSKFMT error code on error
0279+  4D0E             
0280+  4D0E             LOGICAL_FORMAT:
0281+  4D0E 21 76 4E        ld hl,BOOT_PARAMETERS_720K
0282+  4D11 30 0C           jr nc,_LOGICAL_FORMAT_DO
0283+  4D13 21 8E 4E        ld hl,BOOT_PARAMETERS_1440K_DOS1
0284+  4D16 3A 13 F3        ld a,(DOSVER)   ;We shouldn't do this but :shrug:
0285+  4D19 B7              or a
0286+  4D1A 28 03           jr z,_LOGICAL_FORMAT_DO
0287+  4D1C 21 82 4E        ld hl,BOOT_PARAMETERS_1440K
0288+  4D1F             
0289+  4D1F             _LOGICAL_FORMAT_DO:
0290+  4D1F             
0291+  4D1F                 ;>>> Step 1: write boot sector
0292+  4D1F             
0293+  4D1F E5              push hl
0294+  4D20 CD BD 4D        call _LOGICAL_FORMAT_ZERO_SECBUF
0295+  4D23 21 CB 4D        ld hl,BOOT_SECTOR
0296+  4D26 ED 5B 4D F3     ld de,(SECBUF)
0297+  4D2A 01 AB 00        ld bc,BOOT_SECTOR_END-BOOT_SECTOR
0298+  4D2D ED B0           ldir
0299+  4D2F             
0300+  4D2F 2A 4D F3        ld hl,(SECBUF)
0301+  4D32 01 0D 00        ld bc,BOOT_DISK_PARAMETERS-BOOT_SECTOR
0302+  4D35 09              add hl,bc
0303+  4D36 EB              ex de,hl    ;DE = Position of variable disk parameters in SECBUF
0304+  4D37 E1              pop hl
0305+  4D38 E5              push hl
0306+  4D39 01 0C 00        ld bc,BOOT_DISK_PARAMETERS_END-BOOT_DISK_PARAMETERS
0307+  4D3C ED B0           ldir
0308+  4D3E             
0309+  4D3E 11 00 00        ld de,0
0310+  4D41 06 01           ld b,1
0311+  4D43 CD 9B 4D        call _LOGICAL_FORMAT_WR_SECTORS
0312+  4D46 DD E1           pop ix
0313+  4D48 D8              ret c
0314+  4D49             
0315+  4D49                 ;>>> Step 2: write first sector of both copies of FAT
0316+  4D49             
0317+  4D49 CD BD 4D        call _LOGICAL_FORMAT_ZERO_SECBUF
0318+  4D4C             
0319+  4D4C 2A 4D F3        ld hl,(SECBUF)
0320+  4D4F DD 7E 08        ld a,(ix+8) ;Media ID
0321+  4D52 77              ld (hl),a
0322+  4D53 23              inc hl
0323+  4D54 3E FF           ld a,0FFh
0324+  4D56 77              ld (hl),a
0325+  4D57 23              inc hl
0326+  4D58 77              ld (hl),a   ;SECBUF contains now the initialized first FAT sector
0327+  4D59             
0328+  4D59 11 01 00        ld de,1
0329+  4D5C 06 01           ld b,1
0330+  4D5E CD 9B 4D        call _LOGICAL_FORMAT_WR_SECTORS  ;Write first sector of first FAT
0331+  4D61 D8              ret c
0332+  4D62             
0333+  4D62 DD 5E 09        ld e,(ix+9) ;Sectors per FAT
0334+  4D65 1C              inc e  ;DE = First sector of second FAT (skip boot sector + 1st FAT)
0335+  4D66 16 00           ld d,0
0336+  4D68 06 01           ld b,1
0337+  4D6A CD 9B 4D        call _LOGICAL_FORMAT_WR_SECTORS
0338+  4D6D D8              ret c
0339+  4D6E             
0340+  4D6E                 ;>>> Step 3: clear the rest of the first FAT
0341+  4D6E             
0342+  4D6E CD BD 4D        call _LOGICAL_FORMAT_ZERO_SECBUF
0343+  4D71             
0344+  4D71 DD 46 09        ld b,(ix+9) ;Sectors per FAT
0345+  4D74 05              dec b   ;First sector is already initialized
0346+  4D75 11 02 00        ld de,2 ;Skip boot sector + 1st sector of first FAT
0347+  4D78 CD 9B 4D        call _LOGICAL_FORMAT_WR_SECTORS
0348+  4D7B D8              ret c
0349+  4D7C             
0350+  4D7C                 ;>>> Step 4: clear the rest of the second FAT and the root directory
0351+  4D7C             
0352+  4D7C 06 00           ld b,0
0353+  4D7E DD 4E 04        ld c,(ix+4)   ;Root directory entries
0354+  4D81 CB 39           srl c
0355+  4D83 CB 39           srl c
0356+  4D85 CB 39           srl c
0357+  4D87 CB 39           srl c   ;BC = sectors for the root directory
0358+  4D89             
0359+  4D89 26 00           ld h,0
0360+  4D8B DD 6E 09        ld l,(ix+9) ;Sectors per FAT
0361+  4D8E 2B              dec hl  ;First sector is already initialized
0362+  4D8F 09              add hl,bc
0363+  4D90 45              ld b,l  ;B = How many sectors to clear (second FAT except 1st sector + root directory)
0364+  4D91             
0365+  4D91 16 00           ld d,0
0366+  4D93 DD 5E 09        ld e,(ix+9)
0367+  4D96 1C              inc e
0368+  4D97 1C              inc e   ;DE = First sector to clear (skip 1st FAT + boot sector + 1st sector of second FAT)
0369+  4D98             
0370+  4D98 C3 9B 4D        jp _LOGICAL_FORMAT_WR_SECTORS
0371+  4D9B             
0372+  4D9B             
0373+  4D9B                 ;--- Write the contents of SECBUF repeatedly in a range of sectors
0374+  4D9B                 ;    Input: DE = first sector, B = how many sectors
0375+  4D9B             
0376+  4D9B             _LOGICAL_FORMAT_WR_SECTORS:
0377+  4D9B DD E5           push ix
0378+  4D9D D5              push de
0379+  4D9E C5              push bc
0380+  4D9F CD 9C 4F        call WK_GET_LAST_REL_DRIVE
0381+  4DA2 C1              pop bc
0382+  4DA3 D1              pop de
0383+  4DA4 67              ld h,a
0384+  4DA5             _LOGICAL_FORMAT_WR_SECTORS_LOOP:    
0385+  4DA5 C5              push bc
0386+  4DA6 D5              push de
0387+  4DA7 E5              push hl
0388+  4DA8 7C              ld a,h
0389+  4DA9 2A 4D F3        ld hl,(SECBUF)
0390+  4DAC 06 01           ld b,1
0391+  4DAE 37              scf
0392+  4DAF CD EC 47        call DSKIO_IMPL
0393+  4DB2 E1              pop hl
0394+  4DB3 D1              pop de
0395+  4DB4 C1              pop bc
0396+  4DB5 38 03           jr c,_LOGICAL_FORMAT_WR_SECTORS_LOOP_END
0397+  4DB7 13              inc de
0398+  4DB8 10 EB           djnz _LOGICAL_FORMAT_WR_SECTORS_LOOP
0399+  4DBA             _LOGICAL_FORMAT_WR_SECTORS_LOOP_END:
0400+  4DBA DD E1           pop ix
0401+  4DBC C9              ret
0402+  4DBD             
0403+  4DBD             _LOGICAL_FORMAT_ZERO_SECBUF:
0404+  4DBD 2A 4D F3        ld hl,(SECBUF)
0405+  4DC0 E5              push hl
0406+  4DC1 D1              pop de
0407+  4DC2 13              inc de
0408+  4DC3 36 00           ld (hl),0
0409+  4DC5 01 FF 01        ld bc,512-1
0410+  4DC8 ED B0           ldir
0411+  4DCA C9              ret
0412+  4DCB             
0413+  4DCB             
0414+  4DCB             BOOT_SECTOR:
0415+  4DCB             	db	0EBh,0FEh,90h,"ROOKIENX"
0415+  4DCB EBFE90524F4F4B49454E58
0416+  4DD6 00 02       	db	00h,02h
0417+  4DD8             BOOT_DISK_PARAMETERS:    
0418+  4DD8                 db  02h,01h,00h,02h,70h,00h,0A0h,05h,0F9h,03h,00h,09h
0418+  4DD8 020100027000A005F9030009
0419+  4DE4             BOOT_DISK_PARAMETERS_END:    
0420+  4DE4                 db  00h,02h,00h,00h,00h,0D0h,0EDh
0420+  4DE4 0002000000D0ED
0421+  4DEB             	db	53h,59h,0C0h,32h,0C4h,0C0h,36h,56h,23h,36h,0C0h,31h,1Fh,0F5h,11h,9Fh
0421+  4DEB 5359C032C4C036562336C0311FF5119F
0422+  4DFB             	db	0C0h,0Eh,0Fh,0CDh,7Dh,0F3h,3Ch,0CAh,63h,0C0h,11h,00h,01h,0Eh,1Ah,0CDh
0422+  4DFB C00E0FCD7DF33CCA63C01100010E1ACD
0423+  4E0B             	db	7Dh,0F3h,21h,01h,00h,22h,0ADh,0C0h,21h,00h,3Fh,11h,9Fh,0C0h,0Eh,27h
0423+  4E0B 7DF321010022ADC021003F119FC00E27
0424+  4E1B             	db	0CDh,7Dh,0F3h,0C3h,00h,01h,58h,0C0h,0CDh,00h,00h,79h,0E6h,0FEh,0FEh,02h
0424+  4E1B CD7DF3C3000158C0CD000079E6FEFE02
0425+  4E2B             	db	0C2h,6Ah,0C0h,3Ah,0C4h,0C0h,0A7h,0CAh,22h,40h,11h,79h,0C0h,0Eh,09h,0CDh
0425+  4E2B C26AC03AC4C0A7CA22401179C00E09CD
0426+  4E3B             	db	7Dh,0F3h,0Eh,07h,0CDh,7Dh,0F3h,18h,0B2h
0426+  4E3B 7DF30E07CD7DF318B2
0427+  4E44             	db	"Boot error",13,10
0427+  4E44 426F6F74206572726F720D0A
0428+  4E50             	db	"Press any key for retry",13,10,"$",0
0428+  4E50 507265737320616E79206B657920666F722072657472790D0A2400
0429+  4E6B             	db	"MSXDOS  SYS"
0429+  4E6B 4D5358444F532020535953
0430+  4E76             BOOT_SECTOR_END:
0431+  4E76             
0432+  4E76             
0433+  4E76             ;Disk parameters that are different for each disk format:
0434+  4E76             ;+0: Sectors per cluster
0435+  4E76             ;+4: Root directory entries
0436+  4E76             ;+6,7: Sector count
0437+  4E76             ;+8: Media ID
0438+  4E76             ;+9: Sectors per FAT
0439+  4E76             ;+11: Sectors per track
0440+  4E76             
0441+  4E76             BOOT_PARAMETERS_720K:
0442+  4E76             	db	02h,01h,00h,02h,70h,00h,0A0h,05h,0F9h,03h,00h,09h
0442+  4E76 020100027000A005F9030009
0443+  4E82             
0444+  4E82             BOOT_PARAMETERS_1440K:
0445+  4E82                 ;Media ID should be F0h here, but then DOS 2 complains with
0446+  4E82                 ;"Not a DOS disk" after format finishes. Go figure.
0447+  4E82             	db	01h,01h,00h,02h,0E0h,00h,40h,0Bh,0F8h,09h,00h,12h
0447+  4E82 01010002E000400BF8090012
0448+  4E8E             
0449+  4E8E             BOOT_PARAMETERS_1440K_DOS1:
0450+  4E8E             	db	04h,01h,00h,02h,0E0h,00h,40h,0Bh,0F8h,03h,00h,12h
0450+  4E8E 04010002E000400BF8030012
0451+  4E9A             
0452+  4E9A             
0453+  4E9A                 if 0
0454+  4E9A~            
0455+  4E9A~            ; -----------------------------------------------------------------------------
0456+  4E9A~            ; Get information about the disk currently in the drive
0457+  4E9A~            ; -----------------------------------------------------------------------------
0458+  4E9A~            ; Input:  A = 1 to retry "disk changed" error
0459+  4E9A~            ; Output: A = DSKIO error code (if Cy=1)
0460+  4E9A~            ;         Cy = 1 on error
0461+  4E9A~            ;         B = FFh if disk changed
0462+  4E9A~            ;              1 if disk unchanged
0463+  4E9A~            ;              (only if A=0 at input)
0464+  4E9A~            ;         C = bit 0: 1 if disk is already formatted
0465+  4E9A~            ;             bit 1: 0 if disk is 720k, 1 if disk is 1.44M
0466+  4E9A~            ;             (only if Cy=0 and B=1)
0467+  4E9A~            
0468+  4E9A~            _GET_DISK_INFO_STACK_SPACE: equ 12
0469+  4E9A~            
0470+  4E9A~            GET_DISK_INFO:
0471+  4E9A~            
0472+  4E9A~                if HW_IMPL_CONFIGURE_NAK_RETRY=1
0473+  4E9A~            
0474+  4E9A~                push af
0475+  4E9A~                scf
0476+  4E9A~                call HW_CONFIGURE_NAK_RETRY
0477+  4E9A~                pop af
0478+  4E9A~                call _GET_DISK_INFO
0479+  4E9A~                push af
0480+  4E9A~                or a
0481+  4E9A~                call HW_CONFIGURE_NAK_RETRY
0482+  4E9A~                pop af
0483+  4E9A~                ret
0484+  4E9A~            _GET_DISK_INFO:
0485+  4E9A~            
0486+  4E9A~                endif
0487+  4E9A~            
0488+  4E9A~                ld ix,-_GET_DISK_INFO_STACK_SPACE
0489+  4E9A~                add ix,sp
0490+  4E9A~                ld sp,ix
0491+  4E9A~            
0492+  4E9A~                push ix
0493+  4E9A~                pop de
0494+  4E9A~                ld hl,_UFI_READ_FORMAT_CAPACITIES_CMD
0495+  4E9A~                ld bc,12
0496+  4E9A~                or a
0497+  4E9A~                ld a,1
0498+  4E9A~                push ix
0499+  4E9A~                call USB_EXECUTE_CBI_WITH_RETRY
0500+  4E9A~                pop ix
0501+  4E9A~            
0502+  4E9A~                or a
0503+  4E9A~                ld a,12
0504+  4E9A~                scf
0505+  4E9A~                jr nz,_GET_DISK_INFO_END   ;Return "other error" on USB error
0506+  4E9A~            
0507+  4E9A~                ld a,d
0508+  4E9A~                or a
0509+  4E9A~                jr z,_GET_DISK_INFO_NO_ERR
0510+  4E9A~                cp 28h  ;"Disk changed" error
0511+  4E9A~                ld b,0FFh
0512+  4E9A~                jr z,_GET_DISK_INFO_OK
0513+  4E9A~                jr _GET_DISK_INFO_ASC_ERR
0514+  4E9A~            
0515+  4E9A~            _GET_DISK_INFO_NO_ERR:
0516+  4E9A~            
0517+  4E9A~                ;Useful information returned by the Read Format Capacities command:
0518+  4E9A~                ;+6: High byte of disk capacity in sectors:
0519+  4E9A~                ;    5h: 720K
0520+  4E9A~                ;    4h: 1.25M
0521+  4E9A~                ;    Bh: 1.44M 
0522+  4E9A~                ;+8: Disk format status:
0523+  4E9A~                ;    01b: unformatted
0524+  4E9A~                ;    10b: formatted
0525+  4E9A~                ;    11b: no disk in drive
0526+  4E9A~            
0527+  4E9A~                ld a,(ix+8)
0528+  4E9A~                and 11b
0529+  4E9A~                cp 3
0530+  4E9A~                ld a,2
0531+  4E9A~                scf
0532+  4E9A~                jr z,_GET_DISK_INFO_END     ;Return "not ready" if no disk present
0533+  4E9A~            
0534+  4E9A~                ld a,(ix+8)
0535+  4E9A~                and 1
0536+  4E9A~                xor 1
0537+  4E9A~                ld c,a  ;Now C = 0 for unformatted disk, 1 for formatted disk
0538+  4E9A~            
0539+  4E9A~                ld b,1  ;Disk not changed
0540+  4E9A~                ld a,(ix+6)
0541+  4E9A~                cp 05h
0542+  4E9A~                jr z,_GET_DISK_INFO_OK
0543+  4E9A~                set 1,c
0544+  4E9A~                cp 0Bh
0545+  4E9A~                jr z,_GET_DISK_INFO_OK
0546+  4E9A~            
0547+  4E9A~                ld c,10b    ;If the disk is 1.25M, report it as unformatted 1.44M
0548+  4E9A~                jr _GET_DISK_INFO_END
0549+  4E9A~            
0550+  4E9A~            _GET_DISK_INFO_ASC_ERR:
0551+  4E9A~                call ASC_TO_ERR
0552+  4E9A~                scf
0553+  4E9A~                jr _GET_DISK_INFO_END
0554+  4E9A~            _GET_DISK_INFO_OK:
0555+  4E9A~                xor a
0556+  4E9A~            _GET_DISK_INFO_END:
0557+  4E9A~                push af
0558+  4E9A~                pop hl
0559+  4E9A~                ld ix,_GET_DISK_INFO_STACK_SPACE
0560+  4E9A~                add ix,sp
0561+  4E9A~                ld sp,ix
0562+  4E9A~                push hl
0563+  4E9A~                pop af
0564+  4E9A~                ret
0565+  4E9A~            
0566+  4E9A~            _UFI_READ_FORMAT_CAPACITIES_CMD:
0567+  4E9A~                db 23h, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0
0568+  4E9A~            
0569+  4E9A                 endif
0058   4E9A                 include "bank1/work_area.asm"
0001+  4E9A             ; MSXUSB USB FDD BIOS
0002+  4E9A             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003+  4E9A             ; This version is adapted to work with the latest version of the MSXUSB project
0004+  4E9A             ;
0005+  4E9A             ; This file contains the work area handling cod.
0006+  4E9A             ; We use the 8 bytes available for our slot at SLTWRK.
0007+  4E9A             
0008+  4E9A             
0009+  4E9A             ; Work area definition when a FDD is connected:
0010+  4E9A             ;
0011+  4E9A             ; +0: Bulk OUT endpoint parameters
0012+  4E9A             ; +1: Bulk IN endpoint parameters
0013+  4E9A             ; +2: Interrupt IN endpoint parameters
0014+  4E9A             ; +3: Interface number for the ADSC setup packet
0015+  4E9A             ; +4: Bits 0-3: Last relative drive accessed
0016+  4E9A             ;     Bits 4-7: Misc flags
0017+  4E9A             ;               0: set if USB hub found
0018+  4E9A             ; +5: Last USB error (for CALL USBERROR)
0019+  4E9A             ; +6: Last ASC (for CALL USBERROR)
0020+  4E9A             ; +7: Last ASCQ (for CALL USBERROR)
0021+  4E9A             ;
0022+  4E9A             ; Endpoint parameters are:
0023+  4E9A             ;   bits 7 and 3-0: Endpoint number
0024+  4E9A             ;   bit 4: Toggle bit state
0025+  4E9A             ;   bits 6-5: Endpoint max packet size
0026+  4E9A             ;
0027+  4E9A             ; For +2 what 6-5 actually stores is the endpoint 0 max packet size,
0028+  4E9A             ; the max packet size of the interrupt IN endpoint is assumed to be 2.
0029+  4E9A             ;
0030+  4E9A             ; Max packet size is stored encoded as follows:
0031+  4E9A             ;  00 = 8 bytes
0032+  4E9A             ;  01 = 16 bytes
0033+  4E9A             ;  10 = 32 bytes
0034+  4E9A             ;  11 = 64 bytes
0035+  4E9A             ;
0036+  4E9A             ; Work area definition when a storage device is connected:
0037+  4E9A             ;
0038+  4E9A             ; +0: flags:
0039+  4E9A             ;     bit 7: set to 1, indicates a storage device is connected
0040+  4E9A             ;            (if a floppy is connected it'll be 0 since the byte holds
0041+  4E9A             ;             the OUT endpoint number)
0042+  4E9A             ;     bit 0: set to 1 if there's a file mounted
0043+  4E9A             ;     bit 1: set if mounted in read only mode
0044+  4E9A             ;     bit 2: set if file has changed
0045+  4E9A             ;     bit 3: set to enable CAPS lit on disk access
0046+  4E9A             ; +1: Current directory depth:
0047+  4E9A             ;     0: no directory currently open
0048+  4E9A             ;     1: root directory, etc
0049+  4E9A             ; 
0050+  4E9A             ; If no device is connected or the connected device is not a CBI FDD,
0051+  4E9A             ; or if some error occurred during USB hardware or device initialization,
0052+  4E9A             ; the work area contents is all zero 
0053+  4E9A             ; (the last relative drive accessed is always preserved)
0054+  4E9A             
0055+  4E9A             
0056+  4E9A             ; -----------------------------------------------------------------------------
0057+  4E9A             ; Store the size of an endpoint.
0058+  4E9A             ;
0059+  4E9A             ; Input: A = Size
0060+  4E9A             ;        B = work area byte (0-2)
0061+  4E9A             
0062+  4E9A             WK_SET_EP_SIZE:
0063+  4E9A DD E5           push ix
0064+  4E9C CD 1D 50        call _WK_GET_POINTER
0065+  4E9F             
0066+  4E9F 0E 00           ld c,0
0067+  4EA1 FE 08           cp 8
0068+  4EA3 28 0B           jr z,_WK_SET_EP_SIZE_DO
0069+  4EA5 0C              inc c
0070+  4EA6 FE 10           cp 16
0071+  4EA8 28 06           jr z,_WK_SET_EP_SIZE_DO
0072+  4EAA 0C              inc c
0073+  4EAB FE 20           cp 32
0074+  4EAD 28 01           jr z,_WK_SET_EP_SIZE_DO
0075+  4EAF 0C              inc c
0076+  4EB0             
0077+  4EB0             _WK_SET_EP_SIZE_DO:
0078+  4EB0 CB 09           rrc c
0079+  4EB2 CB 09           rrc c
0080+  4EB4 CB 09           rrc c
0081+  4EB6 7E              ld a,(hl)
0082+  4EB7 E6 CF           and 11001111b
0083+  4EB9 B1              or c
0084+  4EBA 77              ld (hl),a
0085+  4EBB DD E1           pop ix
0086+  4EBD C9              ret
0087+  4EBE             
0088+  4EBE             
0089+  4EBE             ; -----------------------------------------------------------------------------
0090+  4EBE             ; Zero the entire work area except the last relative drive accessed
0091+  4EBE             
0092+  4EBE             WK_ZERO:
0093+  4EBE DD E5           push ix
0094+  4EC0 CD 29 50        call _WK_GETWRK
0095+  4EC3 DD 36 00 00     ld (ix),0
0096+  4EC7 DD 36 01 00     ld (ix+1),0
0097+  4ECB DD 36 02 00     ld (ix+2),0
0098+  4ECF DD 36 03 00     ld (ix+3),0
0099+  4ED3 DD 36 05 00     ld (ix+5),0
0100+  4ED7 DD 36 06 00     ld (ix+6),0
0101+  4EDB DD 36 07 00     ld (ix+7),0
0102+  4EDF DD 7E 04        ld a,(ix+4)
0103+  4EE2 E6 0F           and 0Fh
0104+  4EE4 DD 77 04        ld (ix+4),a
0105+  4EE7 DD E1           pop ix
0106+  4EE9 C9              ret
0107+  4EEA             
0108+  4EEA             
0109+  4EEA             ; -----------------------------------------------------------------------------
0110+  4EEA             ; Retrieve the stored size of an endpoint.
0111+  4EEA             ;
0112+  4EEA             ; Input:  B = work area byte (0-2)
0113+  4EEA             ; Output: B = size
0114+  4EEA             
0115+  4EEA             WK_GET_EP_SIZE:
0116+  4EEA DD E5           push ix
0117+  4EEC CD 1D 50        call _WK_GET_POINTER
0118+  4EEF DD E1           pop ix
0119+  4EF1 7E              ld a,(hl)
0120+  4EF2 07              rlca
0121+  4EF3 07              rlca
0122+  4EF4 07              rlca
0123+  4EF5 E6 03           and 11b
0124+  4EF7             
0125+  4EF7 06 08           ld b,8
0126+  4EF9 B7              or a
0127+  4EFA C8              ret z
0128+  4EFB CB 20           sla b
0129+  4EFD 3D              dec a
0130+  4EFE C8              ret z
0131+  4EFF CB 20           sla b
0132+  4F01 3D              dec a
0133+  4F02 C8              ret z
0134+  4F03 CB 20           sla b
0135+  4F05             
0136+  4F05 C9              ret
0137+  4F06             
0138+  4F06             
0139+  4F06             ; -----------------------------------------------------------------------------
0140+  4F06             ; Check if the work area has content 
0141+  4F06             ; (meaning that a proper device is initialized and ready to use)
0142+  4F06             ;
0143+  4F06             ; Output: Z and NC if work area is zeroed
0144+  4F06             ;         NZ if work area has contents
0145+  4F06             
0146+  4F06             WK_HAS_CONTENTS:
0147+  4F06 DD E5           push ix
0148+  4F08 CD 29 50        call _WK_GETWRK
0149+  4F0B 7E              ld a,(hl)
0150+  4F0C B7              or a
0151+  4F0D DD E1           pop ix
0152+  4F0F C9              ret
0153+  4F10             
0154+  4F10             
0155+  4F10             ; -----------------------------------------------------------------------------
0156+  4F10             ; Store the number of an endpoint
0157+  4F10             ;
0158+  4F10             ; Input: A = endpoint number
0159+  4F10             ;        B = work area byte (0-2)
0160+  4F10             
0161+  4F10             WK_SET_EP_NUMBER:
0162+  4F10 DD E5           push ix
0163+  4F12 CD 1D 50        call _WK_GET_POINTER
0164+  4F15 E6 8F           and 10001111b
0165+  4F17 4F              ld c,a
0166+  4F18 7E              ld a,(hl)
0167+  4F19 E6 F0           and 11110000b
0168+  4F1B B1              or c
0169+  4F1C 77              ld (hl),a
0170+  4F1D DD E1           pop ix
0171+  4F1F C9              ret
0172+  4F20             
0173+  4F20             
0174+  4F20             ; -----------------------------------------------------------------------------
0175+  4F20             ; Retrieve the stored number of an endpoint
0176+  4F20             ;
0177+  4F20             ; Input:  B = work area byte (0-2)
0178+  4F20             ; Output: A = endpoint number
0179+  4F20             
0180+  4F20             WK_GET_EP_NUMBER:
0181+  4F20 DD E5           push ix
0182+  4F22 CD 1D 50        call _WK_GET_POINTER
0183+  4F25 7E              ld a,(hl)
0184+  4F26 E6 8F           and 10001111b
0185+  4F28 DD E1           pop ix
0186+  4F2A C9              ret
0187+  4F2B             
0188+  4F2B             
0189+  4F2B             ; -----------------------------------------------------------------------------
0190+  4F2B             ; Store the toggle bit status for an endpoint
0191+  4F2B             ;
0192+  4F2B             ; Input: Cy = toggle bit status
0193+  4F2B             ;        B  = work area byte (0-2)
0194+  4F2B             
0195+  4F2B             WK_SET_TOGGLE_BIT:
0196+  4F2B DD E5           push ix
0197+  4F2D CD 1D 50        call _WK_GET_POINTER
0198+  4F30 38 05           jr c,_WK_SET_TOGGLE_BIT_1
0199+  4F32 CB A6           res 4,(hl)
0200+  4F34 DD E1           pop ix
0201+  4F36 C9              ret
0202+  4F37             _WK_SET_TOGGLE_BIT_1:
0203+  4F37 CB E6           set 4,(hl)
0204+  4F39 DD E1           pop ix
0205+  4F3B C9              ret
0206+  4F3C             
0207+  4F3C             
0208+  4F3C             ; -----------------------------------------------------------------------------
0209+  4F3C             ; Retrieve the stored toggle bit status for an endpoint
0210+  4F3C             ;
0211+  4F3C             ; Input: B  = work area byte (0-2)
0212+  4F3C             ; Output: Cy = toggle bit status
0213+  4F3C             
0214+  4F3C             WK_GET_TOGGLE_BIT:
0215+  4F3C DD E5           push ix
0216+  4F3E CD 1D 50        call _WK_GET_POINTER
0217+  4F41 CB 66           bit 4,(hl)
0218+  4F43 DD E1           pop ix
0219+  4F45 37              scf
0220+  4F46 C0              ret nz
0221+  4F47 3F              ccf
0222+  4F48 C9              ret
0223+  4F49             
0224+  4F49             
0225+  4F49             ; -----------------------------------------------------------------------------
0226+  4F49             ; Store the interface number for the ADSC command
0227+  4F49             ;
0228+  4F49             ; Input: A = interface number
0229+  4F49             
0230+  4F49             WK_SET_IFACE_NUMBER:
0231+  4F49 DD E5           push ix
0232+  4F4B F5              push af
0233+  4F4C CD 29 50        call _WK_GETWRK
0234+  4F4F F1              pop af
0235+  4F50 DD 77 03        ld (ix+3),a
0236+  4F53 DD E1           pop ix
0237+  4F55 C9              ret
0238+  4F56             
0239+  4F56             
0240+  4F56             ; -----------------------------------------------------------------------------
0241+  4F56             ; Retrieve the stored interface number for the ADSC command
0242+  4F56             ;
0243+  4F56             ; Output: A = interface number
0244+  4F56             
0245+  4F56             WK_GET_IFACE_NUMBER:
0246+  4F56 DD E5           push ix
0247+  4F58 CD 29 50        call _WK_GETWRK
0248+  4F5B DD 7E 03        ld a,(ix+3)
0249+  4F5E DD E1           pop ix
0250+  4F60 C9              ret
0251+  4F61             
0252+  4F61             
0253+  4F61             ; -----------------------------------------------------------------------------
0254+  4F61             ; Store information about the last USB error
0255+  4F61             ; Input: A = USB error
0256+  4F61             ;        D = ASC
0257+  4F61             ;        E = ASCQ
0258+  4F61             
0259+  4F61             WK_SET_ERROR:
0260+  4F61 DD E5           push ix
0261+  4F63 F5              push af
0262+  4F64 D5              push de
0263+  4F65 CD 29 50        call _WK_GETWRK
0264+  4F68 D1              pop de
0265+  4F69 F1              pop af
0266+  4F6A DD 77 05        ld (ix+5),a
0267+  4F6D DD 72 06        ld (ix+6),d
0268+  4F70 DD 73 07        ld (ix+7),e
0269+  4F73 DD E1           pop ix
0270+  4F75 C9              ret
0271+  4F76             
0272+  4F76             
0273+  4F76             ; -----------------------------------------------------------------------------
0274+  4F76             ; Retrieve the stored information about the last USB error
0275+  4F76             ; Output: A = USB error
0276+  4F76             ;         D = ASC
0277+  4F76             ;         E = ASCQ
0278+  4F76             
0279+  4F76             WK_GET_ERROR:
0280+  4F76 DD E5           push ix
0281+  4F78 CD 29 50        call _WK_GETWRK
0282+  4F7B DD 7E 05        ld a,(ix+5)
0283+  4F7E DD 56 06        ld d,(ix+6)
0284+  4F81 DD 5E 07        ld e,(ix+7)
0285+  4F84 DD E1           pop ix
0286+  4F86 C9              ret
0287+  4F87             
0288+  4F87             
0289+  4F87             ; -----------------------------------------------------------------------------
0290+  4F87             ; Store the last accessed relative drive
0291+  4F87             ;
0292+  4F87             ; Input: A = relative drive number
0293+  4F87             
0294+  4F87             WK_SET_LAST_REL_DRIVE:
0295+  4F87 C5              push bc
0296+  4F88 DD E5           push ix
0297+  4F8A F5              push af
0298+  4F8B CD 29 50        call _WK_GETWRK
0299+  4F8E DD 7E 04        ld a,(ix+4)
0300+  4F91 E6 F0           and 11110000b
0301+  4F93 C1              pop bc
0302+  4F94 B0              or b
0303+  4F95 DD 77 04        ld (ix+4),a
0304+  4F98 DD E1           pop ix
0305+  4F9A C1              pop bc
0306+  4F9B C9              ret
0307+  4F9C             
0308+  4F9C             
0309+  4F9C             ; -----------------------------------------------------------------------------
0310+  4F9C             ; Retrieve the stored last accessed relative drive
0311+  4F9C             ;
0312+  4F9C             ; Output: A = relative drive number
0313+  4F9C             
0314+  4F9C             WK_GET_LAST_REL_DRIVE:
0315+  4F9C DD E5           push ix
0316+  4F9E CD 29 50        call _WK_GETWRK
0317+  4FA1 DD 7E 04        ld a,(ix+4)
0318+  4FA4 E6 0F           and 00001111b
0319+  4FA6 DD E1           pop ix
0320+  4FA8 C9              ret
0321+  4FA9             
0322+  4FA9             
0323+  4FA9             ; -----------------------------------------------------------------------------
0324+  4FA9             ; Store the misc flags (lower four bits only)
0325+  4FA9             ;
0326+  4FA9             ; Input: A = misc flags
0327+  4FA9             
0328+  4FA9             WK_SET_MISC_FLAGS:
0329+  4FA9 C5              push bc
0330+  4FAA DD E5           push ix
0331+  4FAC 07              rlca
0332+  4FAD 07              rlca
0333+  4FAE 07              rlca
0334+  4FAF 07              rlca
0335+  4FB0 E6 F0           and 11110000b
0336+  4FB2 F5              push af
0337+  4FB3 CD 29 50        call _WK_GETWRK
0338+  4FB6 DD 7E 04        ld a,(ix+4)
0339+  4FB9 E6 0F           and 00001111b
0340+  4FBB C1              pop bc
0341+  4FBC B0              or b
0342+  4FBD DD 77 04        ld (ix+4),a
0343+  4FC0 DD E1           pop ix
0344+  4FC2 C1              pop bc
0345+  4FC3 C9              ret
0346+  4FC4             
0347+  4FC4             
0348+  4FC4             ; -----------------------------------------------------------------------------
0349+  4FC4             ; Retrieve the misc flags
0350+  4FC4             ;
0351+  4FC4             ; Input: A = misc flags (in low nibble)
0352+  4FC4             
0353+  4FC4             WK_GET_MISC_FLAGS:
0354+  4FC4 DD E5           push ix
0355+  4FC6 CD 29 50        call _WK_GETWRK
0356+  4FC9 DD 7E 04        ld a,(ix+4)
0357+  4FCC DD E1           pop ix
0358+  4FCE E6 F0           and 11110000b
0359+  4FD0 C8              ret z
0360+  4FD1 0F              rrca
0361+  4FD2 0F              rrca
0362+  4FD3 0F              rrca
0363+  4FD4 0F              rrca
0364+  4FD5 C9              ret
0365+  4FD6             
0366+  4FD6             
0367+  4FD6             ; -----------------------------------------------------------------------------
0368+  4FD6             ; Initialize work area for a storage device
0369+  4FD6             
0370+  4FD6             WK_INIT_FOR_STORAGE_DEV:
0371+  4FD6 CD BE 4E        call WK_ZERO
0372+  4FD9 CD 29 50        call _WK_GETWRK
0373+  4FDC DD 36 00 80     ld (ix),80h
0374+  4FE0 DD 36 01 00     ld (ix+1),0
0375+  4FE4 C9              ret
0376+  4FE5             
0377+  4FE5             
0378+  4FE5             ; -----------------------------------------------------------------------------
0379+  4FE5             ; Retrieve the storage device flags
0380+  4FE5             ;
0381+  4FE5             ; Output: A = storage device flags byte
0382+  4FE5             ;         NZ if a storage device is connected, Z otherwise
0383+  4FE5             
0384+  4FE5             WK_GET_STORAGE_DEV_FLAGS:
0385+  4FE5 E5              push hl
0386+  4FE6 D5              push de
0387+  4FE7 C5              push bc
0388+  4FE8 DD E5           push ix
0389+  4FEA CD 29 50        call _WK_GETWRK
0390+  4FED DD 7E 00        ld a,(ix)
0391+  4FF0 DD E1           pop ix
0392+  4FF2 C1              pop bc
0393+  4FF3 D1              pop de
0394+  4FF4 E1              pop hl
0395+  4FF5 CB 7F           bit 7,a
0396+  4FF7 C9              ret
0397+  4FF8             
0398+  4FF8             
0399+  4FF8             ; -----------------------------------------------------------------------------
0400+  4FF8             ; Set the storage device flags
0401+  4FF8             ;
0402+  4FF8             ; Input: A = storage device flags byte
0403+  4FF8             
0404+  4FF8             WK_SET_STORAGE_DEV_FLAGS:
0405+  4FF8 DD E5           push ix
0406+  4FFA F5              push af
0407+  4FFB CD 29 50        call _WK_GETWRK
0408+  4FFE F1              pop af
0409+  4FFF DD 77 00        ld (ix),a
0410+  5002 DD E1           pop ix
0411+  5004 C9              ret
0412+  5005             
0413+  5005             
0414+  5005             ; -----------------------------------------------------------------------------
0415+  5005             ; Retrieve the current directory depth for the storage device
0416+  5005             ;
0417+  5005             ; Output: A = current directory depth
0418+  5005             
0419+  5005             WK_GET_CUR_DIR_DEPTH:
0420+  5005 DD E5           push ix
0421+  5007 CD 29 50        call _WK_GETWRK
0422+  500A DD 7E 01        ld a,(ix+1)
0423+  500D DD E1           pop ix
0424+  500F C9              ret
0425+  5010             
0426+  5010             
0427+  5010             ; -----------------------------------------------------------------------------
0428+  5010             ; Set the current directory depth for the storage device
0429+  5010             ;
0430+  5010             ; Input: A = directory depth to set
0431+  5010             
0432+  5010             WK_SET_CUR_DIR_DEPTH:
0433+  5010 DD E5           push ix
0434+  5012 F5              push af
0435+  5013 CD 29 50        call _WK_GETWRK
0436+  5016 F1              pop af
0437+  5017 DD 77 01        ld (ix+1),a
0438+  501A DD E1           pop ix
0439+  501C C9              ret
0440+  501D             
0441+  501D             
0442+  501D             ; -----------------------------------------------------------------------------
0443+  501D             ; Get the storage address for a given work area value
0444+  501D             ;
0445+  501D             ; Input: B = value index (0-7)
0446+  501D             ; Output: HL = storage address for that value in work area
0447+  501D             
0448+  501D             _WK_GET_POINTER:
0449+  501D F5              push af
0450+  501E C5              push bc
0451+  501F CD 29 50        call _WK_GETWRK
0452+  5022 C1              pop bc
0453+  5023 48              ld c,b
0454+  5024 06 00           ld b,0
0455+  5026 09              add hl,bc
0456+  5027 F1              pop af
0457+  5028 C9              ret
0458+  5029             
0459+  5029             
0460+  5029             ; -----------------------------------------------------------------------------
0461+  5029             ; Get the base address of work area for our slot
0462+  5029             ;
0463+  5029             ; This is the GETWRK routine copied from the kernel code with a small change:
0464+  5029             ; the address of the SLTWRK entry is returned directly, the original code
0465+  5029             ; assumes that at offset +2 there's a pointer for allocated space in page 3
0466+  5029             ; and returns this pointer.
0467+  5029             ;
0468+  5029             ; Output: HL = IX = pointer to 8 byte area for the slot in SLTWRK
0469+  5029             
0470+  5029             _WK_GETWRK:
0471+  5029 CD 32 50    	call _WK_GETSLTWRK			; get my SLTWRK entry
0472+  502C 2B              dec hl
0473+  502D 2B              dec hl
0474+  502E E5          	push hl
0475+  502F DD E1       	pop	ix
0476+  5031 C9          	ret
0477+  5032             
0478+  5032             ;	Subroutine	get my SLTWRK entry
0479+  5032             ;	Inputs		-
0480+  5032             ;	Outputs		HL = pointer to SLTWRK entry
0481+  5032             
0482+  5032             _WK_GETSLTWRK:
0483+  5032 CD 4C 50    	call _WK_GETEXPTBL			; get my primairy slot
0484+  5035 87          	add	a,a
0485+  5036 87          	add	a,a
0486+  5037 87          	add	a,a
0487+  5038 37          	scf
0488+  5039 8F          	adc	a,a			; primary slot*4 + 1
0489+  503A 4F          	ld c,a
0490+  503B 7E          	ld a,(hl)
0491+  503C 87          	add	a,a
0492+  503D 9F          	sbc	a,a
0493+  503E E6 0C       	and	00CH			; 0 for non expanded, 0CH for expanded
0494+  5040 23          	inc	hl
0495+  5041 23          	inc	hl
0496+  5042 23          	inc	hl
0497+  5043 23          	inc	hl
0498+  5044 A6          	and	(hl)
0499+  5045 B1          	or c
0500+  5046 87          	add	a,a			; word entries
0501+  5047 21 09 FD    	ld hl,SLTWRK
0502+  504A 18 0C       	jr _WK_ADDHLA
0503+  504C             
0504+  504C             ;	Subroutine	get my EXPTBL entry
0505+  504C             ;	Inputs		-
0506+  504C             ;	Outputs		HL = pointer to SLTWRK entry
0507+  504C             
0508+  504C             _WK_GETEXPTBL:
0509+  504C CD 65 F3    	call 0F365h  ;read primary slotregister
0510+  504F 0F          	rrca
0511+  5050 0F          	rrca
0512+  5051 E6 03       	and	003H
0513+  5053 21 C1 FC    	ld hl,EXPTBL
0514+  5056 06 00       	ld b,000H
0515+  5058             _WK_ADDHLA:
0516+  5058 4F          	ld c,a
0517+  5059 09          	add hl,bc
0518+  505A C9          	ret    
0059   505B                 include "bank1/usb.asm"
0001+  505B             ; MSXUSB USB FDD BIOS
0002+  505B             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003+  505B             ; This version is adapted to work with the latest version of the MSXUSB project
0004+  505B             ;
0005+  505B             ; This file contains the "high level" (hardware independent)
0006+  505B             ; USB operation routines, including the ones related to the CBI protocol.
0007+  505B             ; It also contains the code that detects if the connected device is a proper FDD
0008+  505B             ; and initializes the work area accordingly.
0009+  505B             ;
0010+  505B             ; Connecting a FDD via a hub is allowed since v2.1, useful when the MSX itself
0011+  505B             ; can't provide enough power for it. A simplified approach to hub initializttion
0012+  505B             ; and handling is taken:
0013+  505B             ;
0014+  505B             ; - Number of ports isn't checked, max 7 ports are assumed. If powering a port results
0015+  505B             ;   in error, it is assumed that there are no more ports remaining.
0016+  505B             ; - No actual check is done for a device being a attached to a given port.
0017+  505B             ;   If resetting the port fails, it is assumed that there is no device in that port.
0018+  505B             ; - Ports are powered one by one until one is found having an attached device,
0019+  505B             ;   even if that device isn't an FDD.
0020+  505B             ; - The change notification endpoint isn't used. If trying to accessing the device 
0021+  505B             ;   (via hub or not) throws an error, a full reset and initialization is done again.
0022+  505B             
0023+  505B             
0024+  505B             USB_DEVICE_ADDRESS: equ 1
0025+  505B             HUB_DEVICE_ADDRESS: equ 2
0026+  505B             
0027+  505B             USB_CLASS_MASS: equ 8
0028+  505B             USB_SUBCLASS_CBI: equ 4
0029+  505B             USB_PROTO_WITH_INT_EP: equ 0
0030+  505B             
0031+  505B             USB_CLASS_HUB: equ 9
0032+  505B             
0033+  505B             
0034+  505B             ; -----------------------------------------------------------------------------
0035+  505B             ; USB_CHECK_DEV_CHANGE
0036+  505B             ;
0037+  505B             ; Check if a device connection or disconnection has happened.
0038+  505B             ; On device connection, initialize it.
0039+  505B             ; On device disconnection, clear work area.
0040+  505B             ; -----------------------------------------------------------------------------
0041+  505B             ; Output: Cy = 0 if a properly initialized CBI or storage device is connected
0042+  505B             ;              1 if not
0043+  505B             
0044+  505B             USB_CHECK_DEV_CHANGE:
0045+  505B CD 67 40        call HW_DEV_CHANGE
0046+  505E 38 2B           jr c,_USB_CHECK_DEV_CHANGE_NO_DEV   ;Device present, but bus reset failed
0047+  5060             
0048+  5060 B7              or a
0049+  5061 20 06           jr nz,_USB_CHECK_DEV_CHANGE_CHANGED
0050+  5063             
0051+  5063                 ;* No device change detected, rely on work area
0052+  5063             
0053+  5063 CD 06 4F        call WK_HAS_CONTENTS
0054+  5066 D0              ret nc
0055+  5067 37              scf
0056+  5068 C9              ret
0057+  5069             
0058+  5069                 ;* Device change detected, act accordingly
0059+  5069             
0060+  5069             _USB_CHECK_DEV_CHANGE_CHANGED:
0061+  5069 3C              inc a
0062+  506A 28 1F           jr z,_USB_CHECK_DEV_CHANGE_NO_DEV   ;Disconnected
0063+  506C             
0064+  506C CD 90 50        call USB_INIT_DEV
0065+  506F B7              or a
0066+  5070 C8              ret z   ;Initialization OK
0067+  5071 3D              dec a
0068+  5072 20 17           jr nz,_USB_CHECK_DEV_CHANGE_NO_DEV
0069+  5074             
0070+  5074                 ;* Device present but it's not a FDD: check if it's a storage device
0071+  5074             
0072+  5074 CD E5 4F        call WK_GET_STORAGE_DEV_FLAGS   ;No disk mounted for now
0073+  5077 E6 FE           and 0FEh
0074+  5079 CD F8 4F        call WK_SET_STORAGE_DEV_FLAGS
0075+  507C                 
0076+  507C CD 9C 41        call HWF_MOUNT_DISK
0077+  507F 38 0A           jr c,_USB_CHECK_DEV_CHANGE_NO_DEV
0078+  5081 CD B0 6D        call DSK_INIT_WK_FOR_STORAGE_DEV
0079+  5084 3E 01           ld a,1
0080+  5086 CD 3C 6C        call DSK_DO_BOOT_PROC
0081+  5089 B7              or a
0082+  508A C9              ret
0083+  508B             
0084+  508B                 ;* No device, or device initialization failed
0085+  508B             
0086+  508B             _USB_CHECK_DEV_CHANGE_NO_DEV:
0087+  508B CD BE 4E        call WK_ZERO
0088+  508E 37              scf
0089+  508F C9              ret
0090+  5090             
0091+  5090             
0092+  5090             ; -----------------------------------------------------------------------------
0093+  5090             ; USB_INIT_DEV: Initialize USB device and work area
0094+  5090             ;
0095+  5090             ; This routine is invoked after a device connections is detected.
0096+  5090             ; If checks if the device is a CBI FDD, and if so, configures it
0097+  5090             ; and initializes the work area; if not, it empties the work area.
0098+  5090             ; -----------------------------------------------------------------------------
0099+  5090             ; Output: A = Initialization result
0100+  5090             ;             0: Ok, device is a CBI FDD
0101+  5090             ;             1: The device is not a CBI FDD
0102+  5090             ;             2: Error when querying or initializing the device
0103+  5090             ;         B = USB error code if A = 2
0104+  5090             
0105+  5090             USB_INIT_DEV_STACK_SPACE: equ 64
0106+  5090             
0107+  5090             USB_INIT_DEV:
0108+  5090 DD 21 C0 FF     ld ix,-USB_INIT_DEV_STACK_SPACE
0109+  5094 DD 39           add ix,sp
0110+  5096 DD F9           ld sp,ix
0111+  5098 DD E5           push ix
0112+  509A E1              pop hl
0113+  509B             
0114+  509B E5              push hl
0115+  509C CD BE 4E        call WK_ZERO
0116+  509F             
0117+  509F                 ;--- Initialize work area: assume max endpoint 0 packet size is 8 bytes
0118+  509F             
0119+  509F 3E 08           ld a,8
0120+  50A1 06 02           ld b,2
0121+  50A3 CD 9A 4E        call WK_SET_EP_SIZE
0122+  50A6             
0123+  50A6                 ;--- Get 8 first bytes of device descriptor, grab max endpoint 0 packet size
0124+  50A6             
0125+  50A6 D1              pop de
0126+  50A7             _USB_INIT_DEV_RESTART:  ;Jumps here after hub init if hub is detected
0127+  50A7 D5              push de
0128+  50A8             
0129+  50A8                 if HW_IMPL_GET_DEV_DESCR = 1
0130+  50A8             
0131+  50A8 AF              xor a
0132+  50A9 CD A1 43        call HW_GET_DEV_DESCR
0133+  50AC             
0134+  50AC                 else
0135+  50AC~            
0136+  50AC~                ld hl,USB_CMD_GET_DEV_DESC_8
0137+  50AC~                call USB_CONTROL_TRANSFER_0
0138+  50AC~            
0139+  50AC                 endif
0140+  50AC             
0141+  50AC DD E1           pop ix
0142+  50AE B7              or a
0143+  50AF C2 A7 51        jp nz,_USB_INIT_DEV_ERR
0144+  50B2             
0145+  50B2 CD C4 4F        call WK_GET_MISC_FLAGS
0146+  50B5 E6 01           and 1
0147+  50B7 20 08           jr nz,_USB_INIT_DONT_CHECK_HUB ;To prevent infinite loops in case of hub init error
0148+  50B9 DD 7E 04        ld a,(ix+4)
0149+  50BC FE 09           cp USB_CLASS_HUB
0150+  50BE CA BF 51        jp z,_USB_INIT_HUB_FOUND
0151+  50C1             _USB_INIT_DONT_CHECK_HUB:
0152+  50C1             
0153+  50C1 DD 7E 07        ld a,(ix+7)
0154+  50C4 DD E5           push ix
0155+  50C6 06 02           ld b,2
0156+  50C8 CD 9A 4E        call WK_SET_EP_SIZE
0157+  50CB             
0158+  50CB                 ;* HACK: Store VID and PID to allow Konamiman's non-standard FDD unit to be used
0159+  50CB             
0160+  50CB                 ;TODO: Get full device descriptor if HW_IMPL_GET_DEV_DESCR=0
0161+  50CB             
0162+  50CB DD 6E 08        ld l,(ix+8)
0163+  50CE DD 66 09        ld h,(ix+9)
0164+  50D1 22 89 FD        ld (PROCNM),hl
0165+  50D4 DD 6E 0A        ld l,(ix+10)
0166+  50D7 DD 66 0B        ld h,(ix+11)
0167+  50DA 22 8B FD        ld (PROCNM+2),hl
0168+  50DD             
0169+  50DD                 ;--- Get configuration descriptor (we'll look at the first configuration only)
0170+  50DD             
0171+  50DD D1              pop de
0172+  50DE D5              push de
0173+  50DF             
0174+  50DF                 if HW_IMPL_GET_CONFIG_DESCR = 1
0175+  50DF             
0176+  50DF AF              xor a
0177+  50E0 CD A5 43        call HW_GET_CONFIG_DESCR
0178+  50E3             
0179+  50E3                 else
0180+  50E3~            
0181+  50E3~                ld hl,USB_CMD_GET_CONFIG_DESC
0182+  50E3~                call USB_CONTROL_TRANSFER_0
0183+  50E3~            
0184+  50E3                 endif
0185+  50E3             
0186+  50E3 DD E1           pop ix
0187+  50E5 B7              or a
0188+  50E6 C2 A7 51        jp nz,_USB_INIT_DEV_ERR
0189+  50E9             
0190+  50E9 DD 46 04        ld b,(ix+4) ;Number of interfaces
0191+  50EC             
0192+  50EC DD E5           push ix
0193+  50EE FD E1           pop iy  ;Save pointer to beginning of descriptor
0194+  50F0             
0195+  50F0 CD B7 51        call _INIT_USB_SKIP_DESC ;Now IX points to the first interface descriptor 
0196+  50F3             
0197+  50F3                 ;-- Loop for all interfaces, searching a CBI+UFI compliant one
0198+  50F3             
0199+  50F3             _INIT_USB_CHECK_IFACE:
0200+  50F3 C5              push bc
0201+  50F4             
0202+  50F4 DD 7E 03        ld a,(ix+3) ;Alternate setting
0203+  50F7 B7              or a
0204+  50F8 20 2E           jr nz,_INIT_USB_SKIP_IFACE
0205+  50FA             
0206+  50FA                 ;* HACK: Check if it's Konamiman's non-standard FDD (VID=0644h, PID=0001h)
0207+  50FA             
0208+  50FA 2A 89 FD        ld hl,(PROCNM)
0209+  50FD 7D              ld a,l
0210+  50FE FE 44           cp 44h
0211+  5100 20 10           jr nz,_INIT_USB_CHECK_IFACE_2
0212+  5102 7C              ld a,h
0213+  5103 FE 06           cp 6
0214+  5105 20 0B           jr nz,_INIT_USB_CHECK_IFACE_2
0215+  5107 2A 8B FD        ld hl,(PROCNM+2)
0216+  510A 7D              ld a,l
0217+  510B 3D              dec a   ;cp 1
0218+  510C 20 04           jr nz,_INIT_USB_CHECK_IFACE_2
0219+  510E 7C              ld a,h
0220+  510F B7              or a
0221+  5110 28 2A           jr z,_INIT_USB_FOUND_CBI
0222+  5112                 
0223+  5112             _INIT_USB_CHECK_IFACE_2:
0224+  5112 DD 7E 05        ld a,(ix+5)
0225+  5115 FE 08           cp USB_CLASS_MASS
0226+  5117 20 0F           jr nz,_INIT_USB_SKIP_IFACE
0227+  5119 DD 7E 06        ld a,(ix+6)
0228+  511C FE 04           cp USB_SUBCLASS_CBI
0229+  511E 20 08           jr nz,_INIT_USB_SKIP_IFACE
0230+  5120 DD 7E 07        ld a,(ix+7)
0231+  5123 FE 00           cp USB_PROTO_WITH_INT_EP
0232+  5125 CA 3C 51        jp z,_INIT_USB_FOUND_CBI
0233+  5128             
0234+  5128             _INIT_USB_SKIP_IFACE:   ; Not a CBI+UFI interface: skip it
0235+  5128 DD 46 04        ld b,(ix+4)     ;Number of endpoints
0236+  512B 04              inc b           ;To include the interface descriptor itself
0237+  512C             _INIT_USB_SKIP_IFACE_LOOP:
0238+  512C CD B7 51        call _INIT_USB_SKIP_DESC
0239+  512F 10 FB           djnz _INIT_USB_SKIP_IFACE_LOOP
0240+  5131             
0241+  5131 C1              pop bc
0242+  5132 10 BF           djnz _INIT_USB_CHECK_IFACE
0243+  5134             
0244+  5134                 ;* No suitable interface found
0245+  5134             
0246+  5134 CD BE 4E        call WK_ZERO
0247+  5137 3E 01           ld a,1
0248+  5139 C3 AE 51        jp _USB_INIT_DEV_END
0249+  513C             
0250+  513C                 ;--- We found a suitable descriptor, now let's setup work area
0251+  513C             
0252+  513C             _INIT_USB_FOUND_CBI:
0253+  513C C1              pop bc  ;Throw away interfaces counter
0254+  513D             
0255+  513D DD 7E 02        ld a,(ix+2)
0256+  5140 CD 49 4F        call WK_SET_IFACE_NUMBER    ;bInterfaceNumber
0257+  5143             
0258+  5143 DD 46 04        ld b,(ix+4) ;Number of endpoints
0259+  5146 CD B7 51        call _INIT_USB_SKIP_DESC    ;Now IX points to the first endpoint descriptor
0260+  5149             
0261+  5149             _INIT_USB_CONFIG_EP_LOOP:
0262+  5149 C5              push bc
0263+  514A DD 7E 03        ld a,(ix+3) ;Endpoint type
0264+  514D E6 03           and 11b
0265+  514F FE 02           cp 2
0266+  5151 38 36           jr c,_INIT_USB_NEXT_EP  ;Control or isochronous EP? Skip it
0267+  5153             
0268+  5153 FE 02           cp 2
0269+  5155 28 16           jr z,_INIT_USB_BULK_EP
0270+  5157             
0271+  5157             _INIT_USB_INT_EP:
0272+  5157 DD 7E 02        ld a,(ix+2) ;EP address + type
0273+  515A CB 7F           bit 7,a
0274+  515C 28 2B           jr z,_INIT_USB_NEXT_EP  ;Skip if interrupt OUT endpoint
0275+  515E             
0276+  515E E6 8F           and 10001111b
0277+  5160 06 02           ld b,2
0278+  5162 CD 10 4F        call WK_SET_EP_NUMBER
0279+  5165             
0280+  5165 B7              or a
0281+  5166 06 02           ld b,2
0282+  5168 CD 2B 4F        call WK_SET_TOGGLE_BIT
0283+  516B             
0284+  516B 18 1C           jr _INIT_USB_NEXT_EP
0285+  516D             
0286+  516D             _INIT_USB_BULK_EP:
0287+  516D DD 7E 02        ld a,(ix+2) ;EP address + type
0288+  5170 4F              ld c,a
0289+  5171 07              rlca
0290+  5172 E6 01           and 1 ;Now B = index in the work area
0291+  5174 47              ld b,a
0292+  5175             
0293+  5175 79              ld a,c
0294+  5176 E6 8F           and 10001111b
0295+  5178 C5              push bc
0296+  5179 CD 10 4F        call WK_SET_EP_NUMBER
0297+  517C C1              pop bc
0298+  517D             
0299+  517D DD 7E 04        ld a,(ix+4) ;Endpoint size
0300+  5180 C5              push bc
0301+  5181 CD 9A 4E        call WK_SET_EP_SIZE
0302+  5184 C1              pop bc
0303+  5185             
0304+  5185 B7              or a
0305+  5186 CD 2B 4F        call WK_SET_TOGGLE_BIT
0306+  5189             
0307+  5189             _INIT_USB_NEXT_EP:
0308+  5189 C1              pop bc
0309+  518A CD B7 51        call _INIT_USB_SKIP_DESC
0310+  518D 10 BA           djnz _INIT_USB_CONFIG_EP_LOOP
0311+  518F             
0312+  518F                 ;--- Assign an address to the device
0313+  518F             
0314+  518F                 if HW_IMPL_SET_ADDRESS = 1
0315+  518F             
0316+  518F 3E 01           ld a,USB_DEVICE_ADDRESS
0317+  5191 CD D0 43        call HW_SET_ADDRESS
0318+  5194 FD E5           push iy
0319+  5196 DD E1           pop ix
0320+  5198             
0321+  5198                 else
0322+  5198~            
0323+  5198~                push iy
0324+  5198~                ld hl,USB_CMD_SET_ADDRESS
0325+  5198~                ld de,0 ;No data will be actually transferred
0326+  5198~                call USB_CONTROL_TRANSFER_0
0327+  5198~                pop ix
0328+  5198~            
0329+  5198                 endif
0330+  5198             
0331+  5198 B7              or a
0332+  5199 20 0C           jr nz,_USB_INIT_DEV_ERR
0333+  519B             
0334+  519B                 ;* We must use USB_CONTROL_TRANSFER (not _0) from this point
0335+  519B             
0336+  519B                 ;--- Assign the first configuration to the device
0337+  519B             
0338+  519B DD 7E 05        ld a,(ix+5) ;bConfigurationValue in the configuration descriptor
0339+  519E             
0340+  519E                 if HW_IMPL_SET_CONFIG = 1
0341+  519E             
0342+  519E 47              ld b,a
0343+  519F 3E 01           ld a,USB_DEVICE_ADDRESS
0344+  51A1 CD C2 43        call HW_SET_CONFIG
0345+  51A4             
0346+  51A4                 else
0347+  51A4~            
0348+  51A4~                push ix
0349+  51A4~                pop de
0350+  51A4~                ld hl,USB_CMD_SET_CONFIGURATION
0351+  51A4~                ld bc,8
0352+  51A4~                push de
0353+  51A4~                ldir
0354+  51A4~                pop hl
0355+  51A4~            
0356+  51A4~                ld (ix+2),a ;wValue in the SET_CONFIGURATION command
0357+  51A4~            
0358+  51A4~                ld de,0 ;No data will be actually transferred
0359+  51A4~                call USB_CONTROL_TRANSFER
0360+  51A4~            
0361+  51A4                 endif
0362+  51A4             
0363+  51A4 B7              or a
0364+  51A5 28 07           jr z,_USB_INIT_DEV_END
0365+  51A7             
0366+  51A7             _USB_INIT_DEV_ERR:
0367+  51A7 F5              push af
0368+  51A8 CD BE 4E        call WK_ZERO
0369+  51AB C1              pop bc
0370+  51AC 3E 02           ld a,2
0371+  51AE             
0372+  51AE             _USB_INIT_DEV_END:
0373+  51AE DD 21 40 00     ld ix,USB_INIT_DEV_STACK_SPACE
0374+  51B2 DD 39           add ix,sp
0375+  51B4 DD F9           ld sp,ix
0376+  51B6 C9              ret
0377+  51B7             
0378+  51B7                 ;* Skip the current descriptor
0379+  51B7             
0380+  51B7             _INIT_USB_SKIP_DESC:
0381+  51B7 DD 5E 00        ld e,(ix)
0382+  51BA 16 00           ld d,0
0383+  51BC DD 19           add ix,de
0384+  51BE C9              ret
0385+  51BF             
0386+  51BF             
0387+  51BF                 ;>>> USB hub found!
0388+  51BF             
0389+  51BF             _USB_INIT_HUB_FOUND:
0390+  51BF             
0391+  51BF 3E 01           ld a,1
0392+  51C1 CD A9 4F        call WK_SET_MISC_FLAGS  ;Set "hub found" flag
0393+  51C4             
0394+  51C4                 ;--- Get configuration descriptor
0395+  51C4             
0396+  51C4 DD E5           push ix
0397+  51C6 D1              pop de
0398+  51C7             
0399+  51C7                 if HW_IMPL_GET_CONFIG_DESCR = 1
0400+  51C7             
0401+  51C7 AF              xor a
0402+  51C8 CD A5 43        call HW_GET_CONFIG_DESCR
0403+  51CB             
0404+  51CB                 else
0405+  51CB~            
0406+  51CB~                ld hl,USB_CMD_GET_CONFIG_DESC
0407+  51CB~                push ix
0408+  51CB~                call USB_CONTROL_TRANSFER_0
0409+  51CB~                pop ix
0410+  51CB~            
0411+  51CB                 endif
0412+  51CB             
0413+  51CB B7              or a
0414+  51CC C2 20 52        jp nz,_USB_HUB_INIT_END
0415+  51CF             
0416+  51CF                 ;--- Assign hub address
0417+  51CF             
0418+  51CF                 if HW_IMPL_SET_ADDRESS = 1
0419+  51CF             
0420+  51CF 3E 02           ld a,HUB_DEVICE_ADDRESS
0421+  51D1 CD D0 43        call HW_SET_ADDRESS
0422+  51D4             
0423+  51D4                 else
0424+  51D4~            
0425+  51D4~                ld hl,USB_CMD_SET_HUB_ADDRESS
0426+  51D4~                ld de,0 ;No data will be actually transferred
0427+  51D4~                push ix
0428+  51D4~                call USB_CONTROL_TRANSFER_0
0429+  51D4~                pop ix
0430+  51D4~            
0431+  51D4                 endif
0432+  51D4             
0433+  51D4 B7              or a
0434+  51D5 C2 20 52        jp nz,_USB_HUB_INIT_END
0435+  51D8             
0436+  51D8                 ;--- Set hub configuration
0437+  51D8             
0438+  51D8 DD 7E 05        ld a,(ix+5) ;bConfigurationValue in the configuration descriptor
0439+  51DB             
0440+  51DB                 if HW_IMPL_SET_CONFIG = 1
0441+  51DB             
0442+  51DB 47              ld b,a
0443+  51DC 3E 02           ld a,HUB_DEVICE_ADDRESS
0444+  51DE CD C2 43        call HW_SET_CONFIG
0445+  51E1             
0446+  51E1                 else
0447+  51E1~            
0448+  51E1~                push ix
0449+  51E1~                pop de
0450+  51E1~                ld hl,USB_CMD_SET_CONFIGURATION
0451+  51E1~                ld bc,8
0452+  51E1~                push de
0453+  51E1~                ldir
0454+  51E1~                pop hl
0455+  51E1~            
0456+  51E1~                ld (ix+2),a ;wValue in the SET_CONFIGURATION command
0457+  51E1~            
0458+  51E1~                ld de,0 ;No data will be actually transferred
0459+  51E1~                ld a,HUB_DEVICE_ADDRESS
0460+  51E1~                push ix
0461+  51E1~                call _USB_CONTROL_TRANSFER_DO
0462+  51E1~                pop ix
0463+  51E1~            
0464+  51E1                 endif
0465+  51E1             
0466+  51E1 B7              or a
0467+  51E2 C2 20 52        jp nz,_USB_HUB_INIT_END
0468+  51E5             
0469+  51E5                 ;--- For ports 1 to 7, attempt port power + port reset + get device descriptor
0470+  51E5             
0471+  51E5 06 01           ld b,1
0472+  51E7             _USB_HUB_PORT_LOOP:
0473+  51E7             
0474+  51E7 C5              push bc
0475+  51E8             
0476+  51E8                 ;* Power port
0477+  51E8             
0478+  51E8 21 5F 52        ld hl,USB_CMD_HUB_PORT_POWER
0479+  51EB F1              pop af
0480+  51EC F5              push af
0481+  51ED             
0482+  51ED CD 26 52        call _USB_DO_HUB_CMD
0483+  51F0 C2 44 52        jp nz,_USB_HUB_INIT_ERR ;An error here means that the port doesn't exist
0484+  51F3             
0485+  51F3                 ;* Reset port
0486+  51F3             
0487+  51F3 21 67 52        ld hl,USB_CMD_HUB_PORT_RESET
0488+  51F6 F1              pop af
0489+  51F7 F5              push af
0490+  51F8 CD 26 52        call _USB_DO_HUB_CMD
0491+  51FB C2 44 52        jp nz,_USB_HUB_INIT_ERR ;An error here means that the port doesn't exist
0492+  51FE             
0493+  51FE 76              halt
0494+  51FF 76              halt
0495+  5200 76              halt    ;Max reset time for a USB hub port is 20ms, that'll be enough
0496+  5201             
0497+  5201                 ;* Try to get the device descriptor of the actual device,
0498+  5201                 ;  just to see if there's a device at all
0499+  5201             
0500+  5201 21 47 52        ld hl,USB_CMD_GET_DEV_DESC_8
0501+  5204 DD E5           push ix
0502+  5206 D1              pop de
0503+  5207 AF              xor a
0504+  5208 06 08           ld b,8
0505+  520A DD E5           push ix
0506+  520C CD 7C 40        call HW_CONTROL_TRANSFER
0507+  520F DD E1           pop ix
0508+  5211             
0509+  5211                 ;* Device found? Then let's go and resume normal processing
0510+  5211             
0511+  5211 B7              or a
0512+  5212 20 04           jr nz,_USB_HUB_NEXT_PORT
0513+  5214             
0514+  5214 F1              pop af
0515+  5215 C3 20 52        jp _USB_HUB_INIT_END
0516+  5218             
0517+  5218                 ;--- Next port, if any
0518+  5218             
0519+  5218             _USB_HUB_NEXT_PORT:
0520+  5218 F1              pop af
0521+  5219 3C              inc a
0522+  521A FE 08           cp 8
0523+  521C 47              ld b,a
0524+  521D DA E7 51        jp c,_USB_HUB_PORT_LOOP
0525+  5220             
0526+  5220             _USB_HUB_INIT_END:
0527+  5220 DD E5           push ix
0528+  5222 D1              pop de
0529+  5223 C3 A7 50        jp _USB_INIT_DEV_RESTART
0530+  5226             
0531+  5226             
0532+  5226                 ;--- Execute a dataless command for the hub
0533+  5226                 ;    In: HL=Command address, IX=Buffer address, A=port number (for +4 in command)
0534+  5226                 ;    Out: Z if ok, NZ if error
0535+  5226             
0536+  5226             _USB_DO_HUB_CMD:
0537+  5226 DD E5           push ix
0538+  5228 D1              pop de
0539+  5229 01 08 00        ld bc,8
0540+  522C ED B0           ldir
0541+  522E DD 77 04        ld (ix+4),a ;Set the port number in the command
0542+  5231             
0543+  5231 DD E5           push ix
0544+  5233 E1              pop hl
0545+  5234 11 00 00        ld de,0 ;No data will be actually transferred
0546+  5237 3E 02           ld a,HUB_DEVICE_ADDRESS
0547+  5239 06 08           ld b,8
0548+  523B DD E5           push ix
0549+  523D CD 7C 40        call HW_CONTROL_TRANSFER
0550+  5240 DD E1           pop ix
0551+  5242             
0552+  5242 B7              or a
0553+  5243 C9              ret
0554+  5244             
0555+  5244             _USB_HUB_INIT_ERR:
0556+  5244 C1              pop bc
0557+  5245 18 D9           jr _USB_HUB_INIT_END
0558+  5247             
0559+  5247             
0560+  5247             
0561+  5247             ; -----------------------------------------------------------------------------
0562+  5247             ; USB commands used for initialization
0563+  5247             ; -----------------------------------------------------------------------------
0564+  5247             
0565+  5247             USB_CMD_GET_DEV_DESC_8:
0566+  5247                 db 80h, 6, 0, 1, 0, 0, 8, 0
0566+  5247 8006000100000800
0567+  524F             
0568+  524F                 if HW_IMPL_GET_CONFIG_DESCR = 0
0569+  524F~            
0570+  524F~            USB_CMD_GET_CONFIG_DESC:
0571+  524F~                db 80h, 6, 0, 2, 0, 0, 128, 0
0572+  524F~            
0573+  524F                 endif
0574+  524F             
0575+  524F             USB_CMD_SET_ADDRESS:
0576+  524F                 db 0, 5, USB_DEVICE_ADDRESS, 0, 0, 0, 0, 0
0576+  524F 0005010000000000
0577+  5257             
0578+  5257             USB_CMD_SET_HUB_ADDRESS:
0579+  5257                 db 0, 5, HUB_DEVICE_ADDRESS, 0, 0, 0, 0, 0
0579+  5257 0005020000000000
0580+  525F             
0581+  525F                 if HW_IMPL_SET_CONFIG = 0
0582+  525F~            
0583+  525F~            USB_CMD_SET_CONFIGURATION:
0584+  525F~                db 0, 9, 255, 0, 0, 0, 0, 0 ;Needs actual configuration value in 3rd byte
0585+  525F~            
0586+  525F                 endif
0587+  525F             
0588+  525F             USB_CMD_HUB_PORT_POWER:
0589+  525F                 db  00100011b, 3, 8, 0, 1, 0, 0, 0
0589+  525F 2303080001000000
0590+  5267             
0591+  5267             USB_CMD_HUB_PORT_RESET:
0592+  5267                 db  00100011b, 3, 4, 0, 1, 0, 0, 0
0592+  5267 2303040001000000
0593+  526F             
0594+  526F             
0595+  526F             ; -----------------------------------------------------------------------------
0596+  526F             ; USB_CONTROL_TRANSFER: Perform a USB control transfer on endpoint 0
0597+  526F             ;
0598+  526F             ; The size and direction of the transfer are taken from the contents
0599+  526F             ; of the setup packet.
0600+  526F             ;
0601+  526F             ; This routine differs from HW_CONTROL_TRANSFER in that:
0602+  526F             ;
0603+  526F             ; - Passing the device address is not needed
0604+  526F             ; - Passing endpoint 0 max packet size is not needed, it's taken from work area
0605+  526F             ; -----------------------------------------------------------------------------
0606+  526F             ; Input:  HL = Address of a 8 byte buffer with the setup packet
0607+  526F             ;         DE = Address of the input or output data buffer
0608+  526F             ; Output: A  = USB error code
0609+  526F             ;         BC = Amount of data actually transferred (if IN transfer and no error)
0610+  526F             
0611+  526F             ;This entry point is used before SET_ADDRESS has been executed
0612+  526F             USB_CONTROL_TRANSFER_0:
0613+  526F AF              xor a
0614+  5270 18 02           jr _USB_CONTROL_TRANSFER_DO
0615+  5272             
0616+  5272             USB_CONTROL_TRANSFER:
0617+  5272 3E 01           ld a,USB_DEVICE_ADDRESS
0618+  5274             
0619+  5274             _USB_CONTROL_TRANSFER_DO:
0620+  5274 D5              push de
0621+  5275 E5              push hl
0622+  5276             
0623+  5276 F5              push af
0624+  5277 06 02           ld b,2
0625+  5279 CD EA 4E        call WK_GET_EP_SIZE ;Now B = Max endpoint 0 packet size
0626+  527C F1              pop af
0627+  527D             
0628+  527D E1              pop hl
0629+  527E D1              pop de
0630+  527F             
0631+  527F CD 7C 40        call HW_CONTROL_TRANSFER
0632+  5282 B7              or a
0633+  5283 C4 5B 53        call nz,USB_PROCESS_ERROR
0634+  5286 C9              ret
0635+  5287             
0636+  5287             
0637+  5287             ; -----------------------------------------------------------------------------
0638+  5287             ; USB_DATA_IN_TRANSFER: Perform a USB data IN transfer
0639+  5287             ;
0640+  5287             ; This routine differs from HW_DATA_IN_TRANSFER in that:
0641+  5287             ;
0642+  5287             ; - Passing the device address is not needed
0643+  5287             ; - Passing endpoint max packet size is not needed, it's taken from work area
0644+  5287             ; - Endpoint number is not (directly) passed
0645+  5287             ; - It manages the state of the toggle bit in work area
0646+  5287             ; -----------------------------------------------------------------------------
0647+  5287             ; Input:  HL = Address of a buffer for the received data
0648+  5287             ;         BC = Data length
0649+  5287             ;         Cy = 0 for bulk IN endpoint, 1 for interrupt endpoint
0650+  5287             ; Output: A  = USB error code
0651+  5287             ;         BC = Amount of data actually received
0652+  5287             
0653+  5287             USB_DATA_IN_TRANSFER:
0654+  5287 F5              push af
0655+  5288 78              ld a,b
0656+  5289 B1              or c
0657+  528A 20 02           jr nz,_USB_DATA_IN_NZ
0658+  528C D1              pop de
0659+  528D C9              ret
0660+  528E             _USB_DATA_IN_NZ:
0661+  528E F1              pop af
0662+  528F             
0663+  528F E5              push hl
0664+  5290 C5              push bc
0665+  5291             
0666+  5291 06 01           ld b,1
0667+  5293 38 0E           jr c,_USB_DATA_IN_INT
0668+  5295             
0669+  5295             _USB_DATA_IN_BULK:
0670+  5295 CD 20 4F        call WK_GET_EP_NUMBER
0671+  5298 5F              ld e,a
0672+  5299 06 01           ld b,1
0673+  529B CD EA 4E        call WK_GET_EP_SIZE
0674+  529E 50              ld d,b
0675+  529F 06 01           ld b,1
0676+  52A1 18 08           jr _USB_DATA_IN_GO
0677+  52A3             
0678+  52A3             _USB_DATA_IN_INT:
0679+  52A3 04              inc b
0680+  52A4 CD 20 4F        call WK_GET_EP_NUMBER
0681+  52A7 5F              ld e,a
0682+  52A8 16 02           ld d,2  ;Endpoint size
0683+  52AA 42              ld b,d
0684+  52AB             
0685+  52AB             _USB_DATA_IN_GO:
0686+  52AB             
0687+  52AB                 ;* Here E = Endpoint number, D = Endpoint size, B=1 for bulk or 2 for int
0688+  52AB             
0689+  52AB C5              push bc ;We'll need B to update the toggle bit
0690+  52AC             
0691+  52AC D5              push de
0692+  52AD CD 3C 4F        call WK_GET_TOGGLE_BIT
0693+  52B0 D1              pop de
0694+  52B1             
0695+  52B1 DD E1           pop ix  ;Was B
0696+  52B3             
0697+  52B3 C1              pop bc
0698+  52B4 E1              pop hl
0699+  52B5 DD E5           push ix
0700+  52B7 3E 01           ld a,USB_DEVICE_ADDRESS
0701+  52B9 CD E1 40        call HW_DATA_IN_TRANSFER
0702+  52BC DD E1           pop ix
0703+  52BE F5              push af
0704+  52BF B7              or a
0705+  52C0 D1              pop de
0706+  52C1 7A              ld a,d
0707+  52C2 28 11           jr z,_USB_DATA_IN_OK
0708+  52C4             
0709+  52C4                 ;* On STALL error, clear endpoint HALT
0710+  52C4             
0711+  52C4 FE 02           cp USB_ERR_STALL
0712+  52C6 C2 5B 53        jp nz,USB_PROCESS_ERROR
0713+  52C9             
0714+  52C9 DD E5           push ix
0715+  52CB F1              pop af
0716+  52CC B7              or a
0717+  52CD C5              push bc
0718+  52CE CD 1F 53        call USB_CLEAR_ENDPOINT_HALT
0719+  52D1 C1              pop bc
0720+  52D2 3E 02           ld a,USB_ERR_STALL
0721+  52D4 C9              ret
0722+  52D5             
0723+  52D5                 ;* On success, update toggle bit
0724+  52D5             
0725+  52D5             _USB_DATA_IN_OK:
0726+  52D5 C5              push bc ;Save retrieved data count
0727+  52D6 DD E5           push ix
0728+  52D8 C1              pop bc
0729+  52D9 D5              push de
0730+  52DA F1              pop af
0731+  52DB CD 2B 4F        call WK_SET_TOGGLE_BIT
0732+  52DE AF              xor a
0733+  52DF C1              pop bc
0734+  52E0 C9              ret
0735+  52E1             
0736+  52E1             
0737+  52E1             ; -----------------------------------------------------------------------------
0738+  52E1             ; USB_DATA_OUT_TRANSFER: Perform a USB data IN transfer
0739+  52E1             ;
0740+  52E1             ; This routine differs from HW_DATA_OUT_TRANSFER in that:
0741+  52E1             ;
0742+  52E1             ; - Passing the device address is not needed
0743+  52E1             ; - Passing endpoint max packet size is not needed, it's taken from work area
0744+  52E1             ; - Endpoint number is assumed to be the bulk out one
0745+  52E1             ; - It manages the state of the toggle bit in work area
0746+  52E1             ; -----------------------------------------------------------------------------
0747+  52E1             ; Input:  HL = Address of a buffer for the data to send data
0748+  52E1             ;         BC = Data length
0749+  52E1             ; Output: A  = USB error code
0750+  52E1             
0751+  52E1             USB_DATA_OUT_TRANSFER:
0752+  52E1 78              ld a,b
0753+  52E2 B1              or c
0754+  52E3 C8              ret z
0755+  52E4             
0756+  52E4 E5              push hl
0757+  52E5 C5              push bc
0758+  52E6             
0759+  52E6 06 00           ld b,0
0760+  52E8 CD 20 4F        call WK_GET_EP_NUMBER
0761+  52EB 5F              ld e,a
0762+  52EC 06 00           ld b,0
0763+  52EE CD EA 4E        call WK_GET_EP_SIZE
0764+  52F1 50              ld d,b
0765+  52F2             
0766+  52F2                 ;* Here E = Endpoint number, D = Endpoint size
0767+  52F2             
0768+  52F2 06 00           ld b,0
0769+  52F4 D5              push de
0770+  52F5 CD 3C 4F        call WK_GET_TOGGLE_BIT
0771+  52F8 D1              pop de
0772+  52F9             
0773+  52F9 C1              pop bc
0774+  52FA E1              pop hl
0775+  52FB 3E 01           ld a,USB_DEVICE_ADDRESS
0776+  52FD CD 2B 41        call HW_DATA_OUT_TRANSFER
0777+  5300 F5              push af
0778+  5301 B7              or a
0779+  5302 D1              pop de
0780+  5303 7A              ld a,d
0781+  5304 28 0E           jr z,_USB_DATA_OUT_OK
0782+  5306             
0783+  5306                 ;* On STALL error, clear endpoint HALT
0784+  5306             
0785+  5306 FE 02           cp USB_ERR_STALL
0786+  5308 C2 5B 53        jp nz,USB_PROCESS_ERROR
0787+  530B             
0788+  530B AF              xor a
0789+  530C C5              push bc
0790+  530D CD 1F 53        call USB_CLEAR_ENDPOINT_HALT
0791+  5310 C1              pop bc
0792+  5311 3E 02           ld a,USB_ERR_STALL
0793+  5313 C9              ret
0794+  5314             
0795+  5314                 ;* On success, update toggle bit
0796+  5314             
0797+  5314             _USB_DATA_OUT_OK:
0798+  5314 C5              push bc ;Save retrieved data count
0799+  5315 D5              push de
0800+  5316 F1              pop af
0801+  5317 06 00           ld b,0
0802+  5319 CD 2B 4F        call WK_SET_TOGGLE_BIT
0803+  531C AF              xor a
0804+  531D C1              pop bc
0805+  531E C9              ret
0806+  531F             
0807+  531F             
0808+  531F             ; -----------------------------------------------------------------------------
0809+  531F             ; USB_CLEAR_ENDPOINT_HALT
0810+  531F             ;
0811+  531F             ; Also clears the toggle bit in the work area.
0812+  531F             ; -----------------------------------------------------------------------------
0813+  531F             ; Input: A = which endpoint to clear:
0814+  531F             ;            0: bulk OUT
0815+  531F             ;            1: bulk IN
0816+  531F             ;            2: interrupt IN
0817+  531F             
0818+  531F             USB_CLEAR_ENDPOINT_HALT_STACK_SPACE: equ 8
0819+  531F             
0820+  531F             USB_CLEAR_ENDPOINT_HALT:
0821+  531F F5              push af
0822+  5320 E1              pop hl
0823+  5321 DD 21 F8 FF     ld ix,-USB_CLEAR_ENDPOINT_HALT_STACK_SPACE
0824+  5325 DD 39           add ix,sp
0825+  5327 DD F9           ld sp,ix
0826+  5329 E5              push hl ;Was A
0827+  532A             
0828+  532A EB              ex de,hl
0829+  532B D5              push de
0830+  532C 21 53 53        ld hl,USB_CMD_CLEAR_ENDPOINT_HALT
0831+  532F 01 08 00        ld bc,8
0832+  5332 ED B0           ldir
0833+  5334 DD E1           pop ix
0834+  5336 47              ld b,a
0835+  5337 CD 20 4F        call WK_GET_EP_NUMBER
0836+  533A DD 77 04        ld (ix+4),a
0837+  533D             
0838+  533D DD E5           push ix
0839+  533F E1              pop hl
0840+  5340 CD 72 52        call USB_CONTROL_TRANSFER
0841+  5343             
0842+  5343 C1              pop bc ;was A
0843+  5344 B7              or a
0844+  5345 CC 2B 4F        call z,WK_SET_TOGGLE_BIT
0845+  5348             
0846+  5348 57              ld d,a
0847+  5349 DD 21 08 00     ld ix,USB_CLEAR_ENDPOINT_HALT_STACK_SPACE
0848+  534D DD 39           add ix,sp
0849+  534F DD F9           ld sp,ix
0850+  5351 7A              ld a,d
0851+  5352 C9              ret
0852+  5353             
0853+  5353             USB_CMD_CLEAR_ENDPOINT_HALT:
0854+  5353                 db 2, 1, 0, 0, 255, 0, 0, 0     ;byte 4 is the endpoint to be cleared
0854+  5353 02010000FF000000
0855+  535B             
0856+  535B                 ;Experiments with endpoint halting
0857+  535B                 if 0
0858+  535B~            SET_HALT:
0859+  535B~                push bc,de,hl,ix,iy
0860+  535B~                ld hl,USB_CMD_SET_ENDPOINT_HALT
0861+  535B~                call USB_CONTROL_TRANSFER
0862+  535B~                pop bc,de,hl,ix,iy
0863+  535B~                ret
0864+  535B~            
0865+  535B~            ENDPOINT_HALTED: equ 81h
0866+  535B~            
0867+  535B~            USB_CMD_SET_ENDPOINT_HALT:
0868+  535B~                db 2, 3, 0, 0, ENDPOINT_HALTED, 0, 0, 0    
0869+  535B                 endif
0870+  535B             
0871+  535B             
0872+  535B             ; -----------------------------------------------------------------------------
0873+  535B             ; USB_PROCESS_ERROR
0874+  535B             ;
0875+  535B             ; If USB error is "device disconnected", clear work area.
0876+  535B             ; Otherwise, if it's not STALL, reset device.
0877+  535B             ; -----------------------------------------------------------------------------
0878+  535B             ; Does not modify registers
0879+  535B             
0880+  535B             USB_PROCESS_ERROR:
0881+  535B C5              push bc
0882+  535C D5              push de
0883+  535D E5              push hl
0884+  535E F5              push af
0885+  535F 21 6D 53        ld hl,_USB_PROCESS_ERROR_END
0886+  5362 E5              push hl
0887+  5363 FE 05           cp USB_ERR_NO_DEVICE
0888+  5365 CA BE 4E        jp z,WK_ZERO
0889+  5368 FE 02           cp USB_ERR_STALL
0890+  536A 20 09           jr nz,_USB_PROCESS_ERROR_RESET
0891+  536C E1              pop hl
0892+  536D             _USB_PROCESS_ERROR_END:
0893+  536D F1              pop af
0894+  536E CD 61 4F        call WK_SET_ERROR
0895+  5371 E1              pop hl
0896+  5372 D1              pop de
0897+  5373 C1              pop bc
0898+  5374 C9              ret
0899+  5375             
0900+  5375             _USB_PROCESS_ERROR_RESET:
0901+  5375 CD 74 41        call HW_BUS_RESET
0902+  5378 CD 90 50        call USB_INIT_DEV
0903+  537B C9              ret
0904+  537C             
0905+  537C             
0906+  537C             ; -----------------------------------------------------------------------------
0907+  537C             ; USB_EXECUTE_CBI_WITH_RETRY: Execute a command using CBI transport with error retry
0908+  537C             ;
0909+  537C             ; Retried errors are those of type "device powered" or "not ready to
0910+  537C             ; ready transition", plus optionally "media changed"
0911+  537C             ; -----------------------------------------------------------------------------
0912+  537C             ; Input:  Same as USB_EXECUTE_CBI, plus:
0913+  537C             ;         A = 1 to retry "media changed" errors, 0 to no retry them
0914+  537C             ; Output: Same as USB_EXECUTE_CBI
0915+  537C             
0916+  537C             USB_EXECUTE_CBI_WITH_RETRY:
0917+  537C CD 8A 53        call _USB_EXECUTE_CBI_WITH_RETRY
0918+  537F B7              or a
0919+  5380 C0              ret nz  ;USB error will already have been logged by USB_PROCESS_ERROR
0920+  5381 C5              push bc
0921+  5382 D5              push de
0922+  5383 CD 61 4F        call WK_SET_ERROR
0923+  5386 D1              pop de
0924+  5387 C1              pop bc
0925+  5388 AF              xor a
0926+  5389 C9              ret
0927+  538A             
0928+  538A             _USB_EXECUTE_CBI_WITH_RETRY:
0929+  538A E5              push hl
0930+  538B D5              push de
0931+  538C C5              push bc
0932+  538D F5              push af
0933+  538E             
0934+  538E CD C9 53        call USB_EXECUTE_CBI
0935+  5391 B7              or a
0936+  5392 20 30           jr nz,_USB_ECBIR_POPALL_END_NZ   ;USB level error: do not retry
0937+  5394             
0938+  5394 7A              ld a,d
0939+  5395 B7              or a    ;No error at all
0940+  5396 28 2C           jr z,_USB_ECBIR_POPALL_END_NZ
0941+  5398             
0942+  5398                 ;Report success if the error is one of the "recovered data" (17h or 18h)
0943+  5398             
0944+  5398 FE 17           cp 17h
0945+  539A 28 27           jr z,_USB_ECBIR_POPALL_END
0946+  539C FE 18           cp 18h
0947+  539E 28 23           jr z,_USB_ECBIR_POPALL_END
0948+  53A0             
0949+  53A0                 ;Retry if ASC=4 and ASCQ=1 (unit becoming ready) or FFh (unit busy)
0950+  53A0             
0951+  53A0 FE 04           cp 4
0952+  53A2 20 0B           jr nz,_USB_ECBIR_NO_ASC_4
0953+  53A4 7B              ld a,e
0954+  53A5 FE 01           cp 1
0955+  53A7 28 14           jr z,_USB_ECBIR_DO_RETRY
0956+  53A9 FE FF           cp 0FFh
0957+  53AB 28 10           jr z,_USB_ECBIR_DO_RETRY
0958+  53AD 18 14           jr _USB_ECBIR_POPALL_END
0959+  53AF             _USB_ECBIR_NO_ASC_4:
0960+  53AF             
0961+  53AF                 ;Retry "device powered" error
0962+  53AF             
0963+  53AF 7A              ld a,d
0964+  53B0 FE 29           cp 29h
0965+  53B2 28 09           jr z,_USB_ECBIR_DO_RETRY
0966+  53B4             
0967+  53B4                 ;Retry "media changed" only if we were instructed to do so
0968+  53B4             
0969+  53B4 FE 28           cp 28h
0970+  53B6 20 0B           jr nz,_USB_ECBIR_POPALL_END
0971+  53B8 F1              pop af
0972+  53B9 F5              push af
0973+  53BA B7              or a
0974+  53BB 28 06           jr z,_USB_ECBIR_POPALL_END
0975+  53BD             
0976+  53BD                 ;Here we know we must retry
0977+  53BD             
0978+  53BD             _USB_ECBIR_DO_RETRY:
0979+  53BD F1              pop af
0980+  53BE C1              pop bc
0981+  53BF D1              pop de
0982+  53C0 E1              pop hl    
0983+  53C1 18 C7           jr _USB_EXECUTE_CBI_WITH_RETRY
0984+  53C3             
0985+  53C3                 ;Success, or do not retry
0986+  53C3             
0987+  53C3             _USB_ECBIR_POPALL_END:
0988+  53C3 AF              xor a
0989+  53C4             _USB_ECBIR_POPALL_END_NZ:
0990+  53C4 E1              pop hl
0991+  53C5 E1              pop hl
0992+  53C6 E1              pop hl
0993+  53C7 E1              pop hl
0994+  53C8 C9              ret
0995+  53C9             
0996+  53C9             
0997+  53C9             ; -----------------------------------------------------------------------------
0998+  53C9             ; USB_EXECUTE_CBI: Execute a command using CBI transport
0999+  53C9             ; -----------------------------------------------------------------------------
1000+  53C9             ; Input:  HL = Address of the 12 byte command to execute
1001+  53C9             ;         DE = Address of the input or output data buffer
1002+  53C9             ;         BC = Length of data to send or receive
1003+  53C9             ;         Cy = 0 to receive data, 1 to send data
1004+  53C9             ; Output: A  = USB error code
1005+  53C9             ;         BC = Amount of data actually transferred (if IN transfer)
1006+  53C9             ;         D  = ASC (if no error)
1007+  53C9             ;         E  = ASCQ (if no error)
1008+  53C9             
1009+  53C9             USB_EXECUTE_CBI_STACK_SPACE: equ 8+18
1010+  53C9             
1011+  53C9             USB_EXECUTE_CBI:
1012+  53C9 F5              push af
1013+  53CA FD E1           pop iy
1014+  53CC DD 21 E6 FF     ld ix,-USB_EXECUTE_CBI_STACK_SPACE
1015+  53D0 DD 39           add ix,sp
1016+  53D2 DD F9           ld sp,ix
1017+  53D4             
1018+  53D4 E5              push hl
1019+  53D5 D5              push de
1020+  53D6 C5              push bc
1021+  53D7             
1022+  53D7 DD E5           push ix
1023+  53D9 D1              pop de
1024+  53DA 21 93 54        ld hl,CBI_ADSC
1025+  53DD 01 08 00        ld bc,8
1026+  53E0 ED B0           ldir
1027+  53E2 CD 56 4F        call WK_GET_IFACE_NUMBER
1028+  53E5 DD 77 04        ld (ix+4),a
1029+  53E8             
1030+  53E8 C1              pop bc
1031+  53E9 D1              pop de
1032+  53EA E1              pop hl
1033+  53EB FD E5           push iy
1034+  53ED F1              pop af
1035+  53EE             
1036+  53EE DD E5           push ix
1037+  53F0 CD 2F 54        call _USB_EXECUTE_CBI_CORE
1038+  53F3 DD E1           pop ix
1039+  53F5 FE 02           cp USB_ERR_STALL
1040+  53F7 11 00 00        ld de,0 ;ASC+ASCQ in case we return now
1041+  53FA 20 2A           jr nz,_USB_EXE_CBI_END  ;Return on succes or USB error other than stall
1042+  53FC             
1043+  53FC             _USB_EXECUTE_REQUEST_SENSE:
1044+  53FC C5              push bc ;Data actually transferred
1045+  53FD             
1046+  53FD DD E5           push ix 
1047+  53FF 01 08 00        ld bc,8
1048+  5402 DD 09           add ix,bc
1049+  5404 DD E5           push ix
1050+  5406 D1              pop de  ;DE = Buffer for request sense data
1051+  5407             
1052+  5407 DD E1           pop ix  ;IX = Prepared ADSC
1053+  5409 D5              push de
1054+  540A 21 9B 54        ld hl,UFI_CMD_REQUEST_SENSE
1055+  540D 01 12 00        ld bc,18
1056+  5410 B7              or a    ;receive data
1057+  5411 CD 2F 54        call _USB_EXECUTE_CBI_CORE
1058+  5414             
1059+  5414                 ;Request sense does not modify the sense status of the device,
1060+  5414                 ;this means that it's going to return the same ASC and ASQ
1061+  5414                 ;of the previous command, therefore we need to ignore them
1062+  5414                 ;and assume success.
1063+  5414 FE 02           cp USB_ERR_STALL
1064+  5416 20 05           jr nz,_USB_REQUEST_SENSE_DONE
1065+  5418 7A              ld a,d
1066+  5419 B7              or a
1067+  541A 28 01           jr z,_USB_REQUEST_SENSE_DONE    ;Was it a real stall?
1068+  541C AF              xor a   ;Assume success
1069+  541D             _USB_REQUEST_SENSE_DONE:
1070+  541D             
1071+  541D DD E1           pop ix
1072+  541F C1              pop bc
1073+  5420 DD 56 0C        ld d,(ix+12)
1074+  5423 DD 5E 0D        ld e,(ix+13)
1075+  5426             
1076+  5426             _USB_EXE_CBI_END:
1077+  5426 DD 21 1A 00     ld ix,USB_EXECUTE_CBI_STACK_SPACE
1078+  542A DD 39           add ix,sp
1079+  542C DD F9           ld sp,ix
1080+  542E C9              ret
1081+  542F             
1082+  542F                 ;Does not retry, nor request sense
1083+  542F                 ;In: IX=Prepared ADSC, HL = command, DE=data buffer, BC=data length, Cy=0 to receive
1084+  542F                 ;Out: A=USB error code (STALL if non-zero ASC), BC=data transferred, D=ASC if STALL (0 if not available)
1085+  542F             _USB_EXECUTE_CBI_CORE:
1086+  542F 38 15           jr c,_USB_EXECUTE_CBI_CORE_NO_CLEAR
1087+  5431             
1088+  5431                 ;When reading data we need to clear HALT on bulk IN endpoint if INT endpoint reports an error (ASC!=0),
1089+  5431                 ;since the bulk IN endpoint could have been stalled after the last data byte was transferred
1090+  5431                 ;(per the CBI specification)
1091+  5431             
1092+  5431             _USB_EXECUTE_CBI_CORE_READ:
1093+  5431 CD 46 54        call _USB_EXECUTE_CBI_CORE_NO_CLEAR
1094+  5434 FE 02           cp USB_ERR_STALL
1095+  5436 C0              ret nz
1096+  5437             
1097+  5437 7A              ld a,d
1098+  5438 B7              or a
1099+  5439 3E 02           ld a,USB_ERR_STALL
1100+  543B C0              ret nz  ;No ASC available: was a stall of control or bulk endpoint (and then it's already cleared)
1101+  543C             
1102+  543C C5              push bc
1103+  543D 3E 01           ld a,1
1104+  543F CD 1F 53        call USB_CLEAR_ENDPOINT_HALT
1105+  5442 C1              pop bc
1106+  5443 3E 02           ld a,USB_ERR_STALL
1107+  5445 C9              ret
1108+  5446             
1109+  5446             _USB_EXECUTE_CBI_CORE_NO_CLEAR:
1110+  5446             
1111+  5446                 ;>>> STEP 1: Send command
1112+  5446             
1113+  5446             _USB_EXE_CBI_STEP_1:
1114+  5446 F5              push af ;Send or receive flag
1115+  5447 D5              push de ;Data buffer address
1116+  5448 C5              push bc ;Data length
1117+  5449             
1118+  5449 EB              ex de,hl    ;Now DE = UFI command (data for the USB ADSC)
1119+  544A DD E5           push ix
1120+  544C E1              pop hl      ;HL = Prepared ADSC
1121+  544D CD 72 52        call USB_CONTROL_TRANSFER
1122+  5450 B7              or a
1123+  5451 28 09           jr z,_USB_EXE_CBI_STEP_2
1124+  5453             
1125+  5453 E1              pop hl
1126+  5454 E1              pop hl
1127+  5455 E1              pop hl
1128+  5456 01 00 00        ld bc,0
1129+  5459 16 00           ld d,0
1130+  545B C9              ret
1131+  545C             
1132+  545C                 ;>>> STEP 2: Send or receive data
1133+  545C             
1134+  545C             _USB_EXE_CBI_STEP_2:
1135+  545C C1              pop bc  ;Data length
1136+  545D E1              pop hl  ;was DE, data buffer
1137+  545E F1              pop af
1138+  545F 38 0A           jr c,_USB_EXE_CBI_DATA_OUT
1139+  5461             
1140+  5461             _USB_EXE_CBI_DATA_IN:
1141+  5461 B7              or a    ;From bulk endpoint
1142+  5462 CD 87 52        call USB_DATA_IN_TRANSFER
1143+  5465                 
1144+  5465 B7              or a
1145+  5466 28 0C           jr z,_USB_EXE_CBI_STEP_3
1146+  5468 16 00           ld d,0
1147+  546A C9              ret
1148+  546B             
1149+  546B             _USB_EXE_CBI_DATA_OUT:
1150+  546B CD E1 52        call USB_DATA_OUT_TRANSFER
1151+  546E             
1152+  546E B7              or a
1153+  546F 28 03           jr z,_USB_EXE_CBI_STEP_3
1154+  5471 16 00           ld d,0
1155+  5473 C9              ret
1156+  5474             
1157+  5474                 ;>>> STEP 3: Get status from INT endpoint
1158+  5474             
1159+  5474             _USB_EXE_CBI_STEP_3:
1160+  5474 C5              push bc ;We need to save the amount of data received
1161+  5475 C5              push bc ;Allocate 2 bytes on stack
1162+  5476 21 00 00        ld hl,0
1163+  5479 39              add hl,sp   ;HL = 2 byte buffer for INT data
1164+  547A 01 02 00        ld bc,2
1165+  547D 37              scf
1166+  547E CD 87 52        call USB_DATA_IN_TRANSFER
1167+  5481 E1              pop hl ;L = ASC, H = ASCQ
1168+  5482 C5              push bc
1169+  5483 D1              pop de  ;Amount of data transferred from INT endpoint
1170+  5484 C1              pop bc  ;Amount of data received from bulk in
1171+  5485 B7              or a
1172+  5486 C0              ret nz  ;Return on any USB error
1173+  5487             
1174+  5487 7A              ld a,d
1175+  5488 B3              or e
1176+  5489 3E 02           ld a,USB_ERR_STALL
1177+  548B C8              ret z   ;Return if no data transferred from INT endpoint
1178+  548C             
1179+  548C 7C              ld a,h  ;ASC or ASCQ not zero?
1180+  548D B5              or l
1181+  548E C8              ret z
1182+  548F 54              ld d,h
1183+  5490 3E 02           ld a,USB_ERR_STALL
1184+  5492 C9              ret
1185+  5493             
1186+  5493             CBI_ADSC:
1187+  5493                 db 21h, 0, 0, 0, 255, 0, 12, 0 ;4th byte is interface number, 6th byte is command length
1187+  5493 21000000FF000C00
1188+  549B             
1189+  549B             UFI_CMD_REQUEST_SENSE:
1190+  549B                 db 3, 0, 0, 0, 18, 0, 0, 0, 0, 0, 0, 0
1190+  549B 030000001200000000000000
0060   54A7                 include "bank1/misc.asm"
0001+  54A7             ; MSXUSB USB FDD BIOS
0002+  54A7             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003+  54A7             ; This version is adapted to work with the latest version of the MSXUSB project
0004+  54A7             ;
0005+  54A7             ; This file contains miscellaneous routines used by other modules.
0006+  54A7             
0007+  54A7             
0008+  54A7             ; -----------------------------------------------------------------------------
0009+  54A7             ; ASC_TO_ERR: Convert UFI ASC to DSKIO error
0010+  54A7             ; -----------------------------------------------------------------------------
0011+  54A7             ; Input:  A = ASC
0012+  54A7             ; Output: A = Error
0013+  54A7             ;         Cy = 1
0014+  54A7             
0015+  54A7             ASC_TO_ERR:
0016+  54A7 CD AD 54        call _ASC_TO_ERR
0017+  54AA 7C              ld a,h
0018+  54AB 37              scf
0019+  54AC C9              ret
0020+  54AD             
0021+  54AD             _ASC_TO_ERR:
0022+  54AD FE 27           cp 27h      ;Write protected
0023+  54AF 26 00           ld h,0
0024+  54B1 C8              ret z
0025+  54B2 FE 3A           cp 3Ah      ;Not ready
0026+  54B4 26 02           ld h,2
0027+  54B6 C8              ret z
0028+  54B7 FE 10           cp 10h      ;CRC error
0029+  54B9 26 04           ld h,4
0030+  54BB C8              ret z
0031+  54BC FE 21           cp 21h      ;Invalid logical block
0032+  54BE 26 06           ld h,6
0033+  54C0 C8              ret z
0034+  54C1 FE 02           cp 02h      ;Seek error
0035+  54C3 C8              ret z
0036+  54C4 FE 03           cp 03h
0037+  54C6 26 0A           ld h,10
0038+  54C8 C8              ret z
0039+  54C9 26 0C           ld h,12     ;Other error
0040+  54CB C9              ret
0041+  54CC             
0042+  54CC             
0043+  54CC             ; -----------------------------------------------------------------------------
0044+  54CC             ; TEST_DISK: Test if disk is present and if it has changed
0045+  54CC             ;
0046+  54CC             ; We need to call this before any attempt to access the disk,
0047+  54CC             ; not only to actually check if it has changed,
0048+  54CC             ; before some drives fail the READ and WRITE commands the first time
0049+  54CC             ; they are executed after a disk change otherwise.
0050+  54CC             ; -----------------------------------------------------------------------------
0051+  54CC             ; Output:	F	Cx set for error
0052+  54CC             ;			Cx reset for ok
0053+  54CC             ;		A	if error, errorcode
0054+  54CC             ;		B	if no error, disk change status
0055+  54CC             ;			01 disk unchanged
0056+  54CC             ;			00 unknown
0057+  54CC             ;			FF disk changed
0058+  54CC             
0059+  54CC             TEST_DISK:
0060+  54CC CD EF 54        call _RUN_TEST_UNIT_READY
0061+  54CF D8              ret c
0062+  54D0             
0063+  54D0 7A              ld a,d
0064+  54D1 B7              or a
0065+  54D2 06 01           ld b,1  ;No error: disk unchanged
0066+  54D4 C8              ret z
0067+  54D5             
0068+  54D5 7A              ld a,d
0069+  54D6 FE 28           cp 28h  ;Disk changed if ASC="Media changed"
0070+  54D8 06 FF           ld b,0FFh
0071+  54DA C8              ret z
0072+  54DB             
0073+  54DB FE 3A           cp 3Ah  ;"Disk not present"
0074+  54DD C2 A7 54        jp nz,ASC_TO_ERR
0075+  54E0             
0076+  54E0                 ;Some units report "Disk not present" instead of "medium changed"
0077+  54E0                 ;the first time TEST UNIT READY is executed after a disk change.
0078+  54E0                 ;So let's execute it again, and if no error is returned,
0079+  54E0                 ;report "disk changed".
0080+  54E0             
0081+  54E0 CD EF 54        call _RUN_TEST_UNIT_READY
0082+  54E3 D8              ret c
0083+  54E4             
0084+  54E4 06 FF           ld b,0FFh
0085+  54E6 7A              ld a,d
0086+  54E7 B7              or a
0087+  54E8 C8              ret z
0088+  54E9 FE 28           cp 28h  ;Test "Media changed" ASC again just in case
0089+  54EB C8              ret z
0090+  54EC                 
0091+  54EC C3 A7 54        jp ASC_TO_ERR
0092+  54EF             
0093+  54EF             
0094+  54EF             ; Output: Cy=1 and A=12 on USB error
0095+  54EF             ;         Cy=0 and DE=ASC+ASCQ on USB success
0096+  54EF             _RUN_TEST_UNIT_READY:
0097+  54EF 06 03           ld b,3  ;Some drives stall on first command after reset so try a few times
0098+  54F1             TRY_TEST:
0099+  54F1 C5              push bc    
0100+  54F2 AF              xor a   ;Receive data + don't retry "Media changed"
0101+  54F3 21 08 55        ld hl,_UFI_TEST_UNIT_READY_CMD
0102+  54F6 01 00 00        ld bc,0
0103+  54F9 11 00 00        ld de,0
0104+  54FC CD 7C 53        call USB_EXECUTE_CBI_WITH_RETRY
0105+  54FF C1              pop bc
0106+  5500 B7              or a
0107+  5501 C8              ret z
0108+  5502 10 ED           djnz TRY_TEST
0109+  5504             
0110+  5504 3E 0C           ld a,12
0111+  5506 37              scf
0112+  5507 C9              ret
0113+  5508             
0114+  5508             _UFI_TEST_UNIT_READY_CMD:
0115+  5508                 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
0115+  5508 000000000000000000000000
0116+  5514             
0117+  5514             
0118+  5514             ; -----------------------------------------------------------------------------
0119+  5514             ; CHECK_SAME_DRIVE
0120+  5514             ;
0121+  5514             ; If the drive passed in A is not the same that was passed last time,
0122+  5514             ; display the "Insert disk for drive X:" message.
0123+  5514             ; This is needed for phantom drive emulation.
0124+  5514             ; -----------------------------------------------------------------------------
0125+  5514             ; Input: 	A	Drive number
0126+  5514             ; Preserves AF, BC, DE, HL
0127+  5514             ; -----------------------------------------------------------------------------
0128+  5514             
0129+  5514             CHECK_SAME_DRIVE:
0130+  5514 E5              push hl
0131+  5515 D5              push de
0132+  5516 C5              push bc
0133+  5517 F5              push af
0134+  5518                 
0135+  5518 FE 02           cp 2
0136+  551A 30 17           jr nc,_CHECK_SAME_DRIVE_END ;Bad drive number, let the caller handle the error
0137+  551C             
0138+  551C CD 9C 4F        call WK_GET_LAST_REL_DRIVE
0139+  551F C1              pop bc
0140+  5520 B8              cp b
0141+  5521 C5              push bc
0142+  5522 28 0F           jr z,_CHECK_SAME_DRIVE_END
0143+  5524             
0144+  5524 78              ld a,b
0145+  5525 CD 87 4F        call WK_SET_LAST_REL_DRIVE
0146+  5528 DD 21 5A 62     ld ix,PROMPT
0147+  552C FD 21 00 00     ld iy,ROM_BANK_0
0148+  5530 CD D2 7F        call CALL_BANK
0149+  5533             
0150+  5533             _CHECK_SAME_DRIVE_END:
0151+  5533 F1              pop af
0152+  5534 C1              pop bc
0153+  5535 D1              pop de
0154+  5536 E1              pop hl
0155+  5537 C9              ret
0156+  5538             
0157+  5538             
0158+  5538             ; -----------------------------------------------------------------------------
0159+  5538             ; SNSMAT: Read the keyboard matrix
0160+  5538             ;
0161+  5538             ; This is the same SNSMAT provided by BIOS, it's copied here to avoid
0162+  5538             ; having to do an interslot call every time it's used
0163+  5538             ; -----------------------------------------------------------------------------
0164+  5538             
0165+  5538             DO_SNSMAT:
0166+  5538 4F              ld c,a
0167+  5539 F3              di
0168+  553A DB AA           in a,(0AAh)
0169+  553C E6 F0           and 0F0h
0170+  553E 81              add c
0171+  553F D3 AA           out (0AAh),a
0172+  5541 FB              ei
0173+  5542 DB A9           in a,(0A9h)
0174+  5544 C9              ret
0175+  5545             
0176+  5545                 ;row 6:  F3     F2       F1  CODE    CAPS  GRAPH  CTRL   SHIFT
0177+  5545                 ;row 7:  RET    SELECT   BS  STOP    TAB   ESC    F5     F4
0178+  5545                 ;row 8:	 right  down     up  left    DEL   INS    HOME  SPACE
0179+  5545             
0180+  5545             
0181+  5545             ; -----------------------------------------------------------------------------
0182+  5545             ; BYTE2ASC: Convert a byte to ASCII
0183+  5545             ; -----------------------------------------------------------------------------
0184+  5545             ; Input: 	A  = Number to convert
0185+  5545             ;           IX = Destination address for the string
0186+  5545             ; Output:   IX points after the string
0187+  5545             ; Modifies: AF, C
0188+  5545             ; -----------------------------------------------------------------------------
0189+  5545             
0190+  5545             ;--- Convert a 1-byte number to an unterminated ASCII string
0191+  5545             ;    Input:  A  = Number to convert
0192+  5545             ;            IX = Destination address for the string
0193+  5545             ;    Output: IX points after the string
0194+  5545             ;    Modifies: AF, C
0195+  5545             
0196+  5545 FE 0A       BYTE2ASC:  cp  10
0197+  5547 38 0A         jr  c,B2A_1D
0198+  5549 FE 64         cp  100
0199+  554B 38 0E         jr  c,B2A_2D
0200+  554D FE C8         cp  200
0201+  554F 38 1A         jr  c,B2A_1XX
0202+  5551 18 2C         jr  B2A_2XX
0203+  5553             
0204+  5553               ; One digit
0205+  5553             
0206+  5553 C6 30       B2A_1D:  add  "0"
0207+  5555 DD 77 00      ld  (ix),a
0208+  5558 DD 23         inc  ix
0209+  555A C9            ret
0210+  555B             
0211+  555B               ; Two digits
0212+  555B             
0213+  555B 0E 30       B2A_2D:  ld  c,"0"
0214+  555D 0C          B2A_2D2:  inc  c
0215+  555E D6 0A         sub  10
0216+  5560 FE 0A         cp  10
0217+  5562 30 F9         jr  nc,B2A_2D2
0218+  5564             
0219+  5564 DD 71 00      ld  (ix),c
0220+  5567 DD 23         inc  ix
0221+  5569 18 E8         jr  B2A_1D
0222+  556B             
0223+  556B               ; Between 100 and 199
0224+  556B             
0225+  556B DD 36 00 31 B2A_1XX:  ld  (ix),"1"
0226+  556F D6 64         sub  100
0227+  5571 DD 23       B2A_XXX:  inc  ix
0228+  5573 FE 0A         cp  10
0229+  5575 30 E4         jr  nc,B2A_2D  ;If 1XY with X>0
0230+  5577 DD 36 00 30   ld  (ix),"0"  ;If 10Y
0231+  557B DD 23         inc  ix
0232+  557D 18 D4         jr  B2A_1D
0233+  557F             
0234+  557F               ;--- Between 200 and 255
0235+  557F             
0236+  557F DD 36 00 32 B2A_2XX:  ld  (ix),"2"
0237+  5583 D6 C8         sub  200
0238+  5585 18 EA         jr  B2A_XXX
0239+  5587             
0240+  5587             
0241+  5587             ;
0242+  5587             ; Divide 16-bit values (with 16-bit result)
0243+  5587             ; In: Divide BC by divider DE
0244+  5587             ; Out: BC = result, HL = rest
0245+  5587             ;
0246+  5587             DIVIDE_16:
0247+  5587 21 00 00        ld hl,0
0248+  558A 78              ld a,b
0249+  558B 06 08           ld b,8
0250+  558D             Div16_Loop1:
0251+  558D 17              rla
0252+  558E ED 6A           adc hl,hl
0253+  5590 ED 52           sbc hl,de
0254+  5592 30 01           jr nc,Div16_NoAdd1
0255+  5594 19              add hl,de
0256+  5595             Div16_NoAdd1:
0257+  5595 10 F6           djnz Div16_Loop1
0258+  5597 17              rla
0259+  5598 2F              cpl
0260+  5599 47              ld b,a
0261+  559A 79              ld a,c
0262+  559B 48              ld c,b
0263+  559C 06 08           ld b,8
0264+  559E             Div16_Loop2:
0265+  559E 17              rla
0266+  559F ED 6A           adc hl,hl
0267+  55A1 ED 52           sbc hl,de
0268+  55A3 30 01           jr nc,Div16_NoAdd2
0269+  55A5 19              add hl,de
0270+  55A6             Div16_NoAdd2:
0271+  55A6 10 F6           djnz Div16_Loop2
0272+  55A8 17              rla
0273+  55A9 2F              cpl
0274+  55AA 41              ld b,c
0275+  55AB 4F              ld c,a
0276+  55AC C9              ret
0277+  55AD             
0278+  55AD             
0279+  55AD             ; -----------------------------------------------------------------------------
0280+  55AD             ; SCANKEYS: Scan all the numeric and alphabetic keys,
0281+  55AD             ;           including the numeric keyboard.
0282+  55AD             ; -----------------------------------------------------------------------------
0283+  55AD             ; Input: 	A = 0 for international keyboard, 1 for Russian keyboard
0284+  55AD             ; Output:   Keys in HLDEB (1 bit each, set if pressed):
0285+  55AD             ;           B: 76543210
0286+  55AD             ;           E: FEDCBA98
0287+  55AD             ;           D: NMLKJIHG
0288+  55AD             ;           L: VUTSRQPO
0289+  55AD             ;           H: ....ZYXW
0290+  55AD             ;
0291+  55AD             ;           H holds also the status of CODE/KANA, GRAPH, CTRL and SHIFT
0292+  55AD             ;           on bits 7,6,5,4 respectively.
0293+  55AD             ; Mofifies: AF, C
0294+  55AD             ; -----------------------------------------------------------------------------
0295+  55AD             
0296+  55AD             SK_ROW_0: equ 0
0297+  55AD             SK_ROW_1: equ 1
0298+  55AD             SK_ROW_2: equ 2
0299+  55AD             SK_ROW_3: equ 3
0300+  55AD             SK_ROW_4: equ 4
0301+  55AD             SK_ROW_5: equ 5
0302+  55AD             SK_ROW_6: equ 6
0303+  55AD             SK_ROW_9: equ 7
0304+  55AD             SK_ROW_10: equ 8
0305+  55AD             SK_B: equ 9
0306+  55AD             SK_E: equ 10
0307+  55AD             SK_D: equ 11
0308+  55AD             SK_L: equ 12
0309+  55AD             SK_H: equ 13
0310+  55AD             
0311+  55AD             SK_SIZE: equ 14
0312+  55AD             
0313+  55AD             SCANKEYS:
0314+  55AD FD E5           push iy
0315+  55AF FD 21 F2 FF     ld iy,-SK_SIZE
0316+  55B3 FD 39           add iy,sp
0317+  55B5 FD F9           ld sp,iy
0318+  55B7             
0319+  55B7 F5              push af
0320+  55B8 01 00 07        ld bc,0700h
0321+  55BB FD E5           push iy
0322+  55BD E1              pop hl
0323+  55BE CD A5 56        call SK_GET_ROWS
0324+  55C1             
0325+  55C1 01 09 02        ld bc,0209h
0326+  55C4 CD A5 56        call SK_GET_ROWS
0327+  55C7             
0328+  55C7 F1              pop af
0329+  55C8 B7              or a
0330+  55C9 20 05           jr nz,SCANK_RUSSIAN
0331+  55CB CD ED 55        call SK_INTERNATIONAL
0332+  55CE 18 03           jr SCANK_DONE
0333+  55D0             SCANK_RUSSIAN:
0334+  55D0 CD 75 56        call SK_RUSSIAN
0335+  55D3             SCANK_DONE:
0336+  55D3             
0337+  55D3 FD 46 09        ld b,(iy+SK_B)
0338+  55D6 FD 5E 0A        ld e,(iy+SK_E)
0339+  55D9 FD 56 0B        ld d,(iy+SK_D)
0340+  55DC FD 6E 0C        ld l,(iy+SK_L)
0341+  55DF FD 66 0D        ld h,(iy+SK_H)
0342+  55E2             
0343+  55E2 FD 21 0E 00     ld iy,SK_SIZE
0344+  55E6 FD 39           add iy,sp
0345+  55E8 FD F9           ld sp,iy
0346+  55EA FD E1           pop iy
0347+  55EC C9              ret
0348+  55ED             
0349+  55ED             
0350+  55ED                 ;* International keyboard layout version
0351+  55ED             
0352+  55ED             ;0: 76543210
0353+  55ED             ;1: ......98
0354+  55ED             ;2: BA......
0355+  55ED             ;3: JIHGFEDC
0356+  55ED             ;4: RQPONMLK 
0357+  55ED             ;5: ZYXWVUTS
0358+  55ED             ;6: .... CODE/KANA GRAPH CTRL SHIFT
0359+  55ED             ;Numeric:
0360+  55ED             ;9:  43210...
0361+  55ED             ;10: ...98765
0362+  55ED             
0363+  55ED             SK_INTERNATIONAL:
0364+  55ED             
0365+  55ED                 ;* 0-7
0366+  55ED             
0367+  55ED FD 7E 00        ld a,(iy+SK_ROW_0)    ;76543210
0368+  55F0 FD 77 09        ld (iy+SK_B),a
0369+  55F3             
0370+  55F3                 ;* 8-F
0371+  55F3             
0372+  55F3 FD 7E 01        ld a,(iy+SK_ROW_1)
0373+  55F6 E6 03           and 00000011b
0374+  55F8 47              ld b,a              ;......89
0375+  55F9             
0376+  55F9 FD 7E 02        ld a,(iy+SK_ROW_2)  ;BA......
0377+  55FC 0F              rrca
0378+  55FD 0F              rrca
0379+  55FE 0F              rrca
0380+  55FF 0F              rrca
0381+  5600 E6 0C           and 00001100b       ;....BA..
0382+  5602 B0              or b
0383+  5603 47              ld b,a              ;....BA89
0384+  5604             
0385+  5604 FD 7E 03        ld a,(iy+SK_ROW_3)
0386+  5607 07              rlca
0387+  5608 07              rlca
0388+  5609 07              rlca
0389+  560A 07              rlca
0390+  560B 4F              ld c,a              ;FEDCJIHG
0391+  560C E6 F0           and 11110000b       ;FEDC....
0392+  560E B0              or b                ;FEDCBA89
0393+  560F             
0394+  560F FD 77 0A        ld (iy+SK_E),a
0395+  5612             
0396+  5612                 ;* G-N
0397+  5612             
0398+  5612 79              ld a,c
0399+  5613 E6 0F           and 00001111b       ;....JIHG
0400+  5615 47              ld b,a
0401+  5616             
0402+  5616 FD 7E 04        ld a,(iy+SK_ROW_4)
0403+  5619 07              rlca
0404+  561A 07              rlca
0405+  561B 07              rlca
0406+  561C 07              rlca
0407+  561D 4F              ld c,a              ;NMLKRQPO
0408+  561E E6 F0           and 11110000b       ;NMLK....
0409+  5620 B0              or b                ;NMLKJIHG
0410+  5621             
0411+  5621 FD 77 0B        ld (iy+SK_D),a
0412+  5624             
0413+  5624                 ;* O-V
0414+  5624             
0415+  5624 79              ld a,c
0416+  5625 E6 0F           and 00001111b       ;....RQPO
0417+  5627 47              ld b,a
0418+  5628             
0419+  5628 FD 7E 05        ld a,(iy+SK_ROW_5)
0420+  562B 07              rlca
0421+  562C 07              rlca
0422+  562D 07              rlca
0423+  562E 07              rlca
0424+  562F 4F              ld c,a              ;VUTSZYXW
0425+  5630 E6 F0           and 11110000b       ;VUTS....
0426+  5632 B0              or b                ;VUTSRQPO
0427+  5633             
0428+  5633 FD 77 0C        ld (iy+SK_L),a
0429+  5636             
0430+  5636                 ;* W-Z 
0431+  5636             
0432+  5636 79              ld a,c
0433+  5637 E6 0F           and 00001111b       ;....ZYXW
0434+  5639 FD 77 0D        ld (iy+SK_H),a
0435+  563C 67              ld h,a
0436+  563D             
0437+  563D             SK_COMMON:
0438+  563D                 ;Input: H = (SK_H)
0439+  563D             
0440+  563D                 ;* CAPS-GRAPH-CTRL-SHIFT
0441+  563D             
0442+  563D FD 7E 06        ld a,(iy+SK_ROW_6)
0443+  5640 07              rlca
0444+  5641 07              rlca
0445+  5642 07              rlca
0446+  5643 07              rlca
0447+  5644 E6 71           and 01110001b       ;0-GRAPH-CTRL-SHIFT-000-CODE/KANA
0448+  5646 CB 47           bit 0,a
0449+  5648 28 02           jr z,SK_COMMON_2    ;CODE/KANA pressed?
0450+  564A EE 81           xor 10000001b       ;Set bit 7 and reset bit 0
0451+  564C             SK_COMMON_2:
0452+  564C B4              or  h               ;CODE/KANA-GRAPH-CTRL-SHIFT-ZYXW
0453+  564D             
0454+  564D FD 77 0D        ld (iy+SK_H),a
0455+  5650             
0456+  5650                 ;* Numeric keyboard
0457+  5650             
0458+  5650 FD 7E 07        ld a,(iy+SK_ROW_9)     ;43210... from numeric keyboard
0459+  5653 0F              rrca
0460+  5654 0F              rrca
0461+  5655 0F              rrca
0462+  5656 E6 1F           and 00011111b
0463+  5658 47              ld b,a                 ;...43210 from numeric keyboard
0464+  5659             
0465+  5659 FD 7E 08        ld a,(iy+SK_ROW_10)    ;...98765 from numeric keyboard
0466+  565C 07              rlca
0467+  565D 07              rlca
0468+  565E 07              rlca
0469+  565F 07              rlca
0470+  5660 07              rlca
0471+  5661 4F              ld c,a              ;C = 765...98, we'll use it later
0472+  5662 E6 E0           and 11100000b       ;765..... from numeric keyboard
0473+  5664 B0              or b                ;76543210 from numeric keyboard
0474+  5665             
0475+  5665 FD B6 09        or (iy+SK_B)    ;76543210 from either the regular or the numeric keyboard
0476+  5668 FD 77 09        ld (iy+SK_B),a
0477+  566B             
0478+  566B 79              ld a,c
0479+  566C E6 03           and 00000011b       ;......98 from numeric keyboard
0480+  566E FD B6 0A        or (iy+SK_E)        
0481+  5671 FD 77 0A        ld (iy+SK_E),a      ;FEDCBA98, with 98 from either the regular or the numeric keyboard 
0482+  5674             
0483+  5674 C9              ret
0484+  5675             
0485+  5675             
0486+  5675                 ;* Russian keyboard layout version
0487+  5675             
0488+  5675             ;0: 654321.9
0489+  5675             ;1: V.H..087
0490+  5675             ;2: IF...B..
0491+  5675             ;3: O.RPAUWS
0492+  5675             ;4: KJZ.TXDL 
0493+  5675             ;5: QN.CMGEY
0494+  5675             ;6: .... CAPS GRAPH CTRL SHIFT
0495+  5675             ;Numeric:
0496+  5675             ;9:  43210...
0497+  5675             ;10: ...98765
0498+  5675             
0499+  5675             SK_RUSSIAN:
0500+  5675 FD 7E 00        ld a,(iy+SK_ROW_0)
0501+  5678 4F              ld c,a
0502+  5679 FD 46 01        ld b,(iy+SK_ROW_1)
0503+  567C 1E 00           ld e,0
0504+  567E             
0505+  567E E6 FC           and 11111100b   ;654321..
0506+  5680             
0507+  5680 CB 38           srl b   ;Cy = 7
0508+  5682 1F              rra     ;7654321.
0509+  5683 CB 3F           srl a   ;.7654321
0510+  5685             
0511+  5685 CB 39           srl c   ;Cy = 9
0512+  5687 CB 13           rl e    ;E = .......9
0513+  5689             
0514+  5689 CB 38           srl b   ;Cy = 8
0515+  568B CB 13           rl e    ;E = ......98
0516+  568D             
0517+  568D CB 38           srl b   ;Cy = 0
0518+  568F CB 17           rl a    ;76543210
0519+  5691             
0520+  5691 FD 77 09        ld (iy+SK_B),a
0521+  5694 FD 73 0A        ld (iy+SK_E),e
0522+  5697             
0523+  5697                 ;I'm sorry but that's it, only 9 disk image files supported in Russian keyboards.
0524+  5697                 ;Pull request implementing the (hellish) conversion of the rest of the keys will be welcome.
0525+  5697             
0526+  5697 AF              xor a
0527+  5698 FD 77 0B        ld (iy+SK_D),a
0528+  569B FD 77 0C        ld (iy+SK_L),a
0529+  569E FD 77 0D        ld (iy+SK_H),a
0530+  56A1             
0531+  56A1 67              ld h,a
0532+  56A2 C3 3D 56        jp SK_COMMON
0533+  56A5             
0534+  56A5             
0535+  56A5                 ;Input:  HL = First work area address, B=Rows count, C=First row
0536+  56A5                 ;Output: HL = Last work area address used + 1
0537+  56A5             SK_GET_ROWS:
0538+  56A5 79              ld a,c
0539+  56A6 C5              push bc
0540+  56A7 CD 38 55        call DO_SNSMAT
0541+  56AA C1              pop bc
0542+  56AB 2F              cpl
0543+  56AC 77              ld (hl),a
0544+  56AD 23              inc hl
0545+  56AE 0C              inc c
0546+  56AF 10 F4           djnz SK_GET_ROWS
0547+  56B1 C9              ret
0548+  56B2             
0549+  56B2             
0550+  56B2                 ;Returns A=1 if we have a Russian keyboard, A=0 otherwise
0551+  56B2             CHECK_IS_RUSSIAN: ; in case of ZF
0552+  56B2 F3              DI
0553+  56B3 CD 56 01        CALL KILBUF
0554+  56B6 2A AB FC        LD HL,(CAPST)
0555+  56B9 3A DB F3        LD A,(CLIKSW)
0556+  56BC F5              PUSH AF
0557+  56BD E5              PUSH HL
0558+  56BE AF              XOR A
0559+  56BF 32 AC FC        LD (KANAST),A   ; KANA OFF
0560+  56C2 32 DB F3        LD (CLIKSW),A   ; Shut up!
0561+  56C5 3D              DEC A
0562+  56C6 32 AB FC        LD (CAPST),A    ; CAPS ON
0563+  56C9 32 EB FB        LD (NEWKEY+6),A ; No SHIFT, CTRL etc.
0564+  56CC 3E 40           LD A,64
0565+  56CE 06 07           LD B,7
0566+  56D0 CD 89 0D        CALL 0D89H
0567+  56D3 E1              POP HL
0568+  56D4 F1              POP AF
0569+  56D5 32 DB F3        LD (CLIKSW),A
0570+  56D8 22 AB FC        LD (CAPST),HL
0571+  56DB CD 9F 00        CALL CHGET
0572+  56DE FE 4A           CP "J"
0573+  56E0 3E 01           ld a,1
0574+  56E2 C8              RET z
0575+  56E3 3D              dec a
0576+  56E4 C9              ret
0577+  56E5             
0578+  56E5             
0579+  56E5             	;--- Return in A the index of currently pressed key, 0 if none, FFh if CODE/KANA
0580+  56E5             
0581+  56E5             GETCURKEY:
0582+  56E5 AF              xor a ;TODO: For now don't support russian keyboard
0583+  56E6 CD AD 55        call SCANKEYS
0584+  56E9 CB 7C           bit 7,h
0585+  56EB 3E FF           ld a,0FFh
0586+  56ED C0              ret nz
0587+  56EE 48              ld c,b
0588+  56EF 06 24       	ld b,36
0589+  56F1 3E 01           ld a,1
0590+  56F3             
0591+  56F3                 ;HLDEC = key statuses
0592+  56F3                 ;B = Keys left to check
0593+  56F3                 ;A = Current key index
0594+  56F3                 ;We do an initial rotation because we want to start at key 1.
0595+  56F3             CHGLOOP:
0596+  56F3 CB 29           sra c
0597+  56F5 CB 1B           rr e
0598+  56F7 CB 1A           rr d
0599+  56F9 CB 1D           rr l
0600+  56FB CB 1C           rr h
0601+  56FD CB 41           bit 0,c
0602+  56FF C0              ret nz
0603+  5700             
0604+  5700 3C              inc a
0605+  5701 10 F0           djnz CHGLOOP
0606+  5703             
0607+  5703 AF              xor a
0608+  5704 C9              ret
0609+  5705             
0610+  5705             
0611+  5705             ; -----------------------------------------------------------------------------
0612+  5705             ; WAIT_KEY_RELEASE: Wait until none of the numeric and alphabetic keys
0613+  5705             ;                   or CODE/KANA, GRAPH, CTRL, SHIFT is pressed.
0614+  5705             ; -----------------------------------------------------------------------------
0615+  5705             
0616+  5705             WAIT_KEY_RELEASE:
0617+  5705 CD E5 56        call GETCURKEY
0618+  5708 B7              or  a
0619+  5709 20 FA           jr  nz,WAIT_KEY_RELEASE
0620+  570B C9              ret
0621+  570C             
0622+  570C             
0623+  570C             ; -----------------------------------------------------------------------------
0624+  570C             ; CAPSON and CAPSOFF: Turn the CAPS led on or off.
0625+  570C             ; -----------------------------------------------------------------------------
0626+  570C             
0627+  570C             CAPSON:
0628+  570C F5              push af
0629+  570D DB AA           in  a,(0AAh)
0630+  570F E6 BF           and 10111111b
0631+  5711 D3 AA           out (0AAh),a
0632+  5713 F1              pop af
0633+  5714 C9              ret
0634+  5715             
0635+  5715             CAPSOFF:
0636+  5715 F5              push af
0637+  5716 DB AA           in a,(0AAh)
0638+  5718 F6 40           or 01000000b
0639+  571A D3 AA           out (0AAh),a
0640+  571C F1              pop af
0641+  571D C9              ret
0642+  571E             
0643+  571E             
0644+  571E             ; -----------------------------------------------------------------------------
0645+  571E             ; MYKILBUF: Empty the keyboard buffer (copy of BIOS routine KILBUF)
0646+  571E             ; Modifies: HL
0647+  571E             ; -----------------------------------------------------------------------------
0648+  571E             
0649+  571E             MYKILBUF:
0650+  571E 2A F8 F3        ld hl,(PUTPNT)
0651+  5721 22 FA F3        ld (GETPNT),hl
0652+  5724 C9              ret
0061   5725                 include "bank1/boot_menu.asm"
0001+  5725             ; MSXUSB USB FDD BIOS
0002+  5725             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003+  5725             ; This version is adapted to work with the latest version of the MSXUSB project
0004+  5725             ;
0005+  5725             ; This file contains the code for the boot menu that displays
0006+  5725             ; a navigable list of disk image files (available only when a
0007+  5725             ; standard USB mass storage device is plugged in).
0008+  5725             
0009+  5725             BM_MAX_DIR_NAME_LENGTH: equ 64
0010+  5725             
0011+  5725             ; -----------------------------------------------------------------------------
0012+  5725             ; Boot menu entry point
0013+  5725             ; 
0014+  5725             ; The starting point is CURDIR, or if it isn't set, the main directory.
0015+  5725             ;
0016+  5725             ; Input:  A  = Where is this called from:
0017+  5725             ;              0: Computer boot
0018+  5725             ;              1: CALL USBMENU/SUBRESET
0019+  5725             ; Output: A = 0 if a file was actually mounted
0020+  5725             ;             1 if ESC or CTRL+STOP was pressed
0021+  5725             ;             2 if not enough memory to start the menu
0022+  5725             ;             3 if no storage device is present
0023+  5725             ;             4 if error setting initial directory (not when F5-ing)
0024+  5725             ; -----------------------------------------------------------------------------
0025+  5725             
0026+  5725             DO_BOOT_MENU:
0027+  5725             
0028+  5725                 ;Return with error if no storage device was found
0029+  5725             
0030+  5725 F5              push af
0031+  5726 CD 5B 50        call USB_CHECK_DEV_CHANGE
0032+  5729 E1              pop hl
0033+  572A             
0034+  572A CD E5 4F        call WK_GET_STORAGE_DEV_FLAGS
0035+  572D 3E 03           ld a,3
0036+  572F C8              ret z
0037+  5730             
0038+  5730                 ;Return with error if we have less than 1.5K of free space
0039+  5730             
0040+  5730 E5              push hl
0041+  5731 21 00 00        ld hl,0
0042+  5734 39              add hl,sp
0043+  5735 ED 5B C6 F6     ld de,(STREND)
0044+  5739 B7              or a
0045+  573A ED 52           sbc hl,de
0046+  573C 7C              ld a,h
0047+  573D FE 06           cp 6
0048+  573F 3E 02           ld a,2
0049+  5741 D1              pop de
0050+  5742 D8              ret c
0051+  5743             
0052+  5743 01 8F 03        ld bc,100+660+BM_VARS_LEN   ;Work stack space + space for one page of 0s + space for variables
0053+  5746 B7              or a
0054+  5747 ED 42           sbc hl,bc
0055+  5749 E5              push hl
0056+  574A C1              pop bc
0057+  574B D5              push de
0058+  574C 11 0B 00        ld de,11
0059+  574F CD 87 55        call DIVIDE_16
0060+  5752 D1              pop de
0061+  5753             
0062+  5753 FD E5           push iy
0063+  5755 FD 21 69 FF     ld iy,-BM_VARS_LEN
0064+  5759 FD 39           add iy,sp
0065+  575B FD F9           ld sp,iy
0066+  575D             
0067+  575D FD 71 4F        ld (iy+BM_MAX_FILES_TO_ENUM),c
0068+  5760 FD 70 50        ld (iy+BM_MAX_FILES_TO_ENUM+1),b
0069+  5763 FD 72 56        ld (iy+BM_WHERE_CALLED_FROM),d
0070+  5766             
0071+  5766 CD 09 60        call BM_SCREEN_BAK
0072+  5769 3E 28           ld a,40
0073+  576B 32 AE F3        ld (LINL40),a
0074+  576E CD 6C 00        call INITXT
0075+  5771 CD CC 00        call ERAFNK
0076+  5774             
0077+  5774 CD 97 57        call DO_BOOT_MENU_MAIN
0078+  5777             
0079+  5777 F5              push af
0080+  5778 CD 1C 60        call BM_SCREEN_REST
0081+  577B CD 56 01        call KILBUF
0082+  577E             
0083+  577E FD 7E 56        ld a,(iy+BM_WHERE_CALLED_FROM)
0084+  5781 B7              or a
0085+  5782 28 07           jr z,_BM_NO_REMOUNT
0086+  5784 F1              pop af
0087+  5785 F5              push af
0088+  5786 FE 01           cp 1
0089+  5788 CC 57 6A        call z,DSK_REMOUNT
0090+  578B             _BM_NO_REMOUNT:
0091+  578B F1              pop af
0092+  578C             
0093+  578C FD 21 97 00     ld iy,BM_VARS_LEN
0094+  5790 FD 39           add iy,sp
0095+  5792 FD F9           ld sp,iy
0096+  5794 FD E1           pop iy
0097+  5796             
0098+  5796 C9              ret
0099+  5797             
0100+  5797             DO_BOOT_MENU_MAIN:
0101+  5797 AF              xor a
0102+  5798 FD 77 0A        ld (iy+BM_CURSOR_DELAY),a
0103+  579B FD 77 0B        ld (iy+BM_NO_STOR_DEV),a
0104+  579E             
0105+  579E                 ; Init screen mode, draw fixed elements
0106+  579E             
0107+  579E CD C3 00        call CLS
0108+  57A1             
0109+  57A1 26 01           ld h,1
0110+  57A3 2E 02           ld l,2
0111+  57A5 CD C6 00        call POSIT
0112+  57A8 CD EF 5D        call BM_DRAW_LINE
0113+  57AB 26 01           ld h,1
0114+  57AD 2E 17           ld l,23
0115+  57AF CD C6 00        call POSIT
0116+  57B2 CD EF 5D        call BM_DRAW_LINE
0117+  57B5             
0118+  57B5                 ; Try opening the initial directory
0119+  57B5             
0120+  57B5 CD 74 60        call BM_OPEN_INITIAL_DIR
0121+  57B8 B7              or a
0122+  57B9 3E 04           ld a,4
0123+  57BB C0              ret nz
0124+  57BC             
0125+  57BC CD 87 5E        call BM_PRINT_CUR_DIR
0126+  57BF CD 91 5C        call BM_ENUM_FILES
0127+  57C2             
0128+  57C2                 ; At this point, files are displayed on screen.
0129+  57C2             
0130+  57C2                 //jp BM_DO_BS
0131+  57C2             
0132+  57C2             
0133+  57C2             ; -----------------------------------------------------------------------------
0134+  57C2             ; Main key scanning loop
0135+  57C2             ; -----------------------------------------------------------------------------
0136+  57C2             
0137+  57C2             
0138+  57C2             ;--- This entry point redraws the screen
0139+  57C2             
0140+  57C2             BM_ENTER_MAIN_LOOP:
0141+  57C2 CD 84 5D        call BM_CLEAR_INFO_AREA
0142+  57C5 CD B7 5D        call BM_PRINT_MAIN_STATUS
0143+  57C8             
0144+  57C8 CD E7 5C        call BM_PRINT_FILENAMES_PAGE
0145+  57CB CD 82 5F        call BM_UPDATE_CUR_PAGE_PNT
0146+  57CE CD 9A 5F        call BM_UPDATE_CUR_FILE_PNT
0147+  57D1 CD F9 5D        call BM_POSIT_CUR_FILE
0148+  57D4 FD 6E 02        ld l,(iy+BM_NUM_FILES)
0149+  57D7 FD 66 03        ld h,(iy+BM_NUM_FILES+1)
0150+  57DA 7C              ld a,h
0151+  57DB B5              or l
0152+  57DC C4 2A 5E        call nz,BM_PRINT_CURRENT_FILE_AS_SELECTED
0153+  57DF             
0154+  57DF             ;--- This is the actual start of the loop
0155+  57DF             
0156+  57DF             _BM_MAIN_LOOP:
0157+  57DF 76              halt
0158+  57E0 CD B7 00        call BREAKX
0159+  57E3 3E 01           ld a,1
0160+  57E5 D8              ret c
0161+  57E6             
0162+  57E6 11 07 04        ld de,0407h ;ESC pressed?
0163+  57E9 CD E3 5E        call BM_KEY_CHECK
0164+  57EC CA 6B 58        jp z,BM_DO_ESC
0165+  57EF             
0166+  57EF CD 04 5F        call BM_F5_IS_PRESSED
0167+  57F2 CA 23 58        jp z,BM_START_OVER
0168+  57F5             
0169+  57F5 FD 7E 0B        ld a,(iy+BM_NO_STOR_DEV)
0170+  57F8 3C              inc a
0171+  57F9 28 E4           jr z,_BM_MAIN_LOOP
0172+  57FB             
0173+  57FB CD 0A 5F        call BM_ENTER_IS_PRESSED
0174+  57FE CA 85 58        jp z,BM_DO_ENTER
0175+  5801             
0176+  5801 CD 1B 5F        call BM_BS_IS_PRESSED
0177+  5804 CA A7 59        jp z,BM_DO_BS
0178+  5807             
0179+  5807 CD F8 5E        call BM_F1_IS_PRESSED
0180+  580A CA 13 5A        jp z,BM_DO_HELP
0181+  580D             
0182+  580D CD FE 5E        call BM_F2_IS_PRESSED
0183+  5810 CA 4E 5A        jp z,BM_DO_CONFIG
0184+  5813             
0185+  5813 CD 2C 5F        call BM_CURSOR_IS_PRESSED
0186+  5816 B7              or a
0187+  5817 28 C6           jr z,_BM_MAIN_LOOP
0188+  5819 CB 7F           bit 7,a
0189+  581B CA A4 5B        jp z,BM_UPDATE_CUR_FILE
0190+  581E E6 7F           and 7Fh
0191+  5820 C3 26 5C        jp BM_UPDATE_PAGE
0192+  5823             
0193+  5823             ;--- Start over after F5 is pressed
0194+  5823             
0195+  5823             BM_START_OVER:
0196+  5823 CD 84 5D        call BM_CLEAR_INFO_AREA
0197+  5826 AF              xor a
0198+  5827 FD 77 0D        ld (iy+BM_CUR_DIR),a
0199+  582A CD 52 60        call BM_ADJUST_DIR_VARS
0200+  582D CD 87 5E        call BM_PRINT_CUR_DIR
0201+  5830 21 01 61        ld hl,BM_RESETTING_DEVICE_S
0202+  5833 CD A1 5D        call BM_PRINT_STATUS
0203+  5836             
0204+  5836 21 00 00        ld hl,0
0205+  5839 CD 9C 41        call HWF_MOUNT_DISK
0206+  583C 30 22           jr nc,_BM_START_OVER_OK
0207+  583E             
0208+  583E AF              xor a
0209+  583F FD 77 02        ld (iy+BM_NUM_FILES),a
0210+  5842 FD 77 03        ld (iy+BM_NUM_FILES+1),a
0211+  5845 CD F8 4F        call WK_SET_STORAGE_DEV_FLAGS
0212+  5848 3C              inc a
0213+  5849 FD 77 01        ld (iy+BM_CUR_PAGE),a
0214+  584C FD 77 00        ld (iy+BM_NUM_PAGES),a
0215+  584F 3E FF           ld a,0FFh
0216+  5851 FD 77 0B        ld (iy+BM_NO_STOR_DEV),a
0217+  5854 21 15 61        ld hl,BM_NO_DEV_OR_NO_STOR_S
0218+  5857 CD A1 5D        call BM_PRINT_STATUS
0219+  585A CD 9F 00        call CHGET
0220+  585D C3 DF 57        jp _BM_MAIN_LOOP
0221+  5860             
0222+  5860             _BM_START_OVER_OK:
0223+  5860 CD B0 6D        call DSK_INIT_WK_FOR_STORAGE_DEV
0224+  5863 3E 01           ld a,1
0225+  5865 CD 3C 6C        call DSK_DO_BOOT_PROC
0226+  5868 C3 97 57        jp DO_BOOT_MENU_MAIN
0227+  586B             
0228+  586B             
0229+  586B             ; -----------------------------------------------------------------------------
0230+  586B             ; Key press handlers
0231+  586B             ;
0232+  586B             ; These are JP-ed in, so they must finish by JP-ing to
0233+  586B             ; either BM_ENTER_MAIN_LOOP or _BM_MAIN_LOOP.
0234+  586B             ; -----------------------------------------------------------------------------
0235+  586B             
0236+  586B             
0237+  586B             ;--- ESC key press handler
0238+  586B             
0239+  586B             BM_DO_ESC:
0240+  586B 11 06 01        ld de,0106h ;SHIFT is pressed?
0241+  586E CD EE 5E        call BM_KEY_CHECK_CORE
0242+  5871 3E 01           ld a,1
0243+  5873 C0              ret nz
0244+  5874             
0245+  5874 21 D3 61        ld hl,BM_CHANGING_EXITING_S
0246+  5877 CD A1 5D        call BM_PRINT_STATUS
0247+  587A CD 48 60        call BM_GET_CUR_DIR_ADD
0248+  587D 3E 01           ld a,1
0249+  587F CD 89 68        call DSK_CHANGE_DIR_U
0250+  5882 3E 05           ld a,5
0251+  5884 C9              ret
0252+  5885             
0253+  5885             
0254+  5885             ;--- ENTER key press handler
0255+  5885             
0256+  5885             BM_DO_ENTER:
0257+  5885 11 06 02        ld de,0206h ;CTRL is pressed?
0258+  5888 CD EE 5E        call BM_KEY_CHECK_CORE
0259+  588B FD 77 54        ld (iy+BM_TEMP),a
0260+  588E             
0261+  588E FD 6E 06        ld l,(iy+BM_CUR_FILE_PNT)
0262+  5891 FD 66 07        ld h,(iy+BM_CUR_FILE_PNT+1)
0263+  5894             
0264+  5894 E5              push hl
0265+  5895 CD 3E 60        call BM_GET_BUF_ADD
0266+  5898 EB              ex de,hl
0267+  5899 E1              pop hl
0268+  589A E5              push hl
0269+  589B CD 3D 5D        call BM_GENERATE_FILENAME
0270+  589E DD E1           pop ix
0271+  58A0 DD CB 0A 7E     bit 7,(ix+10)
0272+  58A4 C2 14 59        jp nz,BM_DO_ENTER_DIR
0273+  58A7             
0274+  58A7                 ;* It's a file
0275+  58A7             
0276+  58A7             BM_DO_ENTER_FILE:
0277+  58A7 21 AC 61        ld hl,BM_MOUNTING_BOOTING_S
0278+  58AA             BM_DO_ENTER_FILE_2:
0279+  58AA CD A1 5D        call BM_PRINT_STATUS
0280+  58AD CD 84 5D        call BM_CLEAR_INFO_AREA
0281+  58B0             
0282+  58B0 CD 48 60        call BM_GET_CUR_DIR_ADD
0283+  58B3 CD 2E 68        call DSK_WRITE_CURDIR_FILE
0284+  58B6 B7              or a
0285+  58B7 21 5C 61        ld hl,BM_ERROR_OPENING_FILE_S
0286+  58BA 20 0A           jr nz,_BM_DO_ENTER_OPEN_ERR
0287+  58BC                 
0288+  58BC CD 3E 60        call BM_GET_BUF_ADD
0289+  58BF AF              xor a
0290+  58C0 CD 4A 69        call DSK_MOUNT
0291+  58C3 B7              or a
0292+  58C4 28 26           jr z,_BM_DO_ENTER_FILE_SUCCESS   ;Exit boot menu
0293+  58C6             
0294+  58C6             _BM_DO_ENTER_OPEN_ERR:
0295+  58C6 FE 02           cp 2
0296+  58C8 21 3A 61        ld hl,BM_FILE_NOT_FOUND_S
0297+  58CB 28 03           jr z,_BM_DO_ENTER_PRINT_ERR
0298+  58CD 21 5C 61        ld hl,BM_ERROR_OPENING_FILE_S   ;Other error or it's a dir
0299+  58D0             _BM_DO_ENTER_PRINT_ERR:
0300+  58D0 CD 98 59        call BM_PRINT_STATUS_WAIT_KEY
0301+  58D3             
0302+  58D3             _BM_DO_ENTER_WAIT_RELEASE:  ;In case the "any key" pressed is enter
0303+  58D3 CD 0A 5F        call BM_ENTER_IS_PRESSED
0304+  58D6 28 FB           jr z,_BM_DO_ENTER_WAIT_RELEASE
0305+  58D8             
0306+  58D8 21 EB 60        ld hl,BM_SCANNING_DIR_S
0307+  58DB CD A1 5D        call BM_PRINT_STATUS
0308+  58DE CD 48 60        call BM_GET_CUR_DIR_ADD
0309+  58E1 3E 01           ld a,1
0310+  58E3 CD 89 68        call DSK_CHANGE_DIR_U
0311+  58E6 CD 91 5C        call BM_ENUM_FILES
0312+  58E9 C3 C2 57        jp BM_ENTER_MAIN_LOOP ; _BM_MAIN_LOOP
0313+  58EC             
0314+  58EC             _BM_DO_ENTER_FILE_SUCCESS:
0315+  58EC CD 56 01        call KILBUF
0316+  58EF             
0317+  58EF FD 7E 54        ld a,(iy+BM_TEMP)   ;Was CTRL pressed?
0318+  58F2 B7              or a
0319+  58F3 3E 00           ld a,0
0320+  58F5 C0              ret nz  ;Exit menu
0321+  58F6             
0322+  58F6 21 67 62        ld hl,BM_RESETTING_S
0323+  58F9 CD A1 5D        call BM_PRINT_STATUS
0324+  58FC             
0325+  58FC CD 1A 6D        call DSK_CREATE_TMP_BOOT_FILE
0326+  58FF B7              or a
0327+  5900 FD 2A C0 FC     ld iy,(EXPTBL-1)
0328+  5904 DD 21 00 00     ld ix,0
0329+  5908 CA 1C 00        jp z,CALSLT
0330+  590B             
0331+  590B 21 3F 62        ld hl,BM_ERR_CREATING_TEMP_FILE_S
0332+  590E CD 98 59        call BM_PRINT_STATUS_WAIT_KEY
0333+  5911 C3 C2 57        jp BM_ENTER_MAIN_LOOP
0334+  5914             
0335+  5914                 ;* It's a directory
0336+  5914             
0337+  5914             BM_DO_ENTER_DIR:
0338+  5914 CD 3E 60        call BM_GET_BUF_ADD
0339+  5917 0E 2F           ld c,"/"
0340+  5919 CD 00 60        call BM_STRLEN_C
0341+  591C 36 00           ld (hl),0
0342+  591E 04              inc b   ;Count also the additional "/"
0343+  591F FD 7E 4E        ld a,(iy+BM_CUR_DIR_LENGTH)
0344+  5922 80              add b
0345+  5923 FE 41           cp BM_MAX_DIR_NAME_LENGTH+1
0346+  5925 D2 DF 57        jp nc,_BM_MAIN_LOOP     ;Max dir length surpassed: can't change dir
0347+  5928             
0348+  5928 CD 3E 60        call BM_GET_BUF_ADD
0349+  592B CD CA 41        call HWF_OPEN_FILE_DIR
0350+  592E C2 C6 58        jp nz,_BM_DO_ENTER_OPEN_ERR
0351+  5931 D2 C6 58        jp nc,_BM_DO_ENTER_OPEN_ERR
0352+  5934             
0353+  5934 FD 7E 0C        ld a,(iy+BM_CUR_DIR_LEVEL)
0354+  5937 3C              inc a
0355+  5938 FD 77 0C        ld (iy+BM_CUR_DIR_LEVEL),a
0356+  593B             
0357+  593B FD 7E 4E        ld a,(iy+BM_CUR_DIR_LENGTH)
0358+  593E 5F              ld e,a
0359+  593F 16 00           ld d,0
0360+  5941 CD 48 60        call BM_GET_CUR_DIR_ADD
0361+  5944 19              add hl,de
0362+  5945             
0363+  5945 FD 7E 0C        ld a,(iy+BM_CUR_DIR_LEVEL)
0364+  5948 FE 01           cp 1
0365+  594A 28 03           jr z,_BM_DO_ENTER_DIR_WAS_ROOT
0366+  594C 36 2F           ld (hl),"/"
0367+  594E 23              inc hl
0368+  594F             _BM_DO_ENTER_DIR_WAS_ROOT:
0369+  594F             
0370+  594F EB              ex de,hl
0371+  5950 CD 3E 60        call BM_GET_BUF_ADD
0372+  5953             _BM_COPY_DIR_NAME_LOOP:
0373+  5953 7E              ld a,(hl)
0374+  5954 12              ld (de),a
0375+  5955 23              inc hl
0376+  5956 13              inc de
0377+  5957 B7              or a
0378+  5958 20 F9           jr nz,_BM_COPY_DIR_NAME_LOOP
0379+  595A             
0380+  595A CD 48 60        call BM_GET_CUR_DIR_ADD
0381+  595D CD FE 5F        call BM_STRLEN
0382+  5960 78              ld a,b
0383+  5961 FD 77 4E        ld (iy+BM_CUR_DIR_LENGTH),a
0384+  5964             
0385+  5964 CD 87 5E        call BM_PRINT_CUR_DIR
0386+  5967             
0387+  5967 11 06 01        ld de,0106h ;SHIFT is pressed?
0388+  596A CD EE 5E        call BM_KEY_CHECK_CORE
0389+  596D 28 0E           jr z,_BM_DO_MOUNT_DEFAULT
0390+  596F 11 06 02        ld de,0206h ;CTRL is pressed?
0391+  5972 CD EE 5E        call BM_KEY_CHECK_CORE
0392+  5975 28 06           jr z,_BM_DO_MOUNT_DEFAULT
0393+  5977             
0394+  5977             _BM_DO_ENTER_DIR_END:
0395+  5977 CD 91 5C        call BM_ENUM_FILES
0396+  597A C3 C2 57        jp BM_ENTER_MAIN_LOOP
0397+  597D             
0398+  597D                 ;* It's a directory and SHIFT was pressed
0399+  597D             
0400+  597D             _BM_DO_MOUNT_DEFAULT:
0401+  597D CD 3E 60        call BM_GET_BUF_ADD
0402+  5980 E5              push hl
0403+  5981 CD DD 6A        call DSK_GET_DEFAULT
0404+  5984 E1              pop hl
0405+  5985             
0406+  5985 B7              or a
0407+  5986 21 F7 61        ld hl,BM_MOUNTING_DEF_S
0408+  5989 CA AA 58        jp z,BM_DO_ENTER_FILE_2
0409+  598C FE 02           cp 2
0410+  598E 28 E7           jr z,_BM_DO_ENTER_DIR_END
0411+  5990             
0412+  5990 21 18 62        ld hl,BM_ERR_RETRIEVING_DEFAULT_S
0413+  5993 CD 98 59        call BM_PRINT_STATUS_WAIT_KEY
0414+  5996 18 DF           jr _BM_DO_ENTER_DIR_END
0415+  5998             
0416+  5998             
0417+  5998             ;--- Print the string HL in the status area and wait for a key press
0418+  5998             
0419+  5998             BM_PRINT_STATUS_WAIT_KEY:
0420+  5998 CD A1 5D        call BM_PRINT_STATUS
0421+  599B CD 56 01        call KILBUF
0422+  599E CD 9F 00        call CHGET
0423+  59A1 F5              push af
0424+  59A2 CD 56 01        call KILBUF
0425+  59A5 F1              pop af
0426+  59A6 C9              ret
0427+  59A7             
0428+  59A7             
0429+  59A7             ;--- BS key press handler, go to parent directory
0430+  59A7             ;
0431+  59A7             ;    The CH376 doesn't support opening ".." so we'll have to
0432+  59A7             ;    cd to root and then to each dir on the current path
0433+  59A7             ;    stopping right before the last one :facepalm:
0434+  59A7             
0435+  59A7             BM_DO_BS:
0436+  59A7 FD 7E 0C        ld a,(iy+BM_CUR_DIR_LEVEL)
0437+  59AA B7              or a
0438+  59AB CA DF 57        jp z,_BM_MAIN_LOOP  ;We are in the root dir already
0439+  59AE             
0440+  59AE CD 84 5D        call BM_CLEAR_INFO_AREA
0441+  59B1 21 BD 61        ld hl,BM_ENTERING_DIR_S
0442+  59B4 CD A1 5D        call BM_PRINT_STATUS
0443+  59B7             
0444+  59B7 CD 48 60        call BM_GET_CUR_DIR_ADD
0445+  59BA E5              push hl
0446+  59BB FD 7E 0C        ld a,(iy+BM_CUR_DIR_LEVEL)
0447+  59BE 3D              dec a
0448+  59BF 28 0C           jr z,_BM_DO_BS_FOUND_SLASH  ;We are in level 1: just zero the current dir
0449+  59C1 FD 4E 4E        ld c,(iy+BM_CUR_DIR_LENGTH)
0450+  59C4 06 00           ld b,0
0451+  59C6 09              add hl,bc
0452+  59C7             _BM_DO_BS_FIND_SLASH_LOOP:
0453+  59C7 2B              dec hl
0454+  59C8 7E              ld a,(hl)
0455+  59C9 FE 2F           cp "/"
0456+  59CB 20 FA           jr nz,_BM_DO_BS_FIND_SLASH_LOOP
0457+  59CD             
0458+  59CD             _BM_DO_BS_FOUND_SLASH:
0459+  59CD 36 00           ld (hl),0
0460+  59CF E1              pop hl
0461+  59D0 3E 01           ld a,1
0462+  59D2 CD 6C 68        call DSK_CHANGE_DIR
0463+  59D5 B7              or a
0464+  59D6 28 21           jr z,_BM_DO_BS_END
0465+  59D8             
0466+  59D8             _BM_DO_BS_OPEN_ERROR:
0467+  59D8 AF              xor a
0468+  59D9 FD 77 0D        ld (iy+BM_CUR_DIR),a
0469+  59DC CD 87 5E        call BM_PRINT_CUR_DIR
0470+  59DF 21 5C 61        ld hl,BM_ERROR_OPENING_FILE_S
0471+  59E2 CD 98 59        call BM_PRINT_STATUS_WAIT_KEY
0472+  59E5 AF              xor a
0473+  59E6 FD 77 02        ld (iy+BM_NUM_FILES),a
0474+  59E9 FD 77 03        ld (iy+BM_NUM_FILES+1),a
0475+  59EC 3C              inc a
0476+  59ED FD 77 00        ld (iy+BM_NUM_PAGES),a
0477+  59F0 FD 77 01        ld (iy+BM_CUR_PAGE),a
0478+  59F3 FD 77 4E        ld (iy+BM_CUR_DIR_LENGTH),a
0479+  59F6 C3 C2 57        jp BM_ENTER_MAIN_LOOP
0480+  59F9             
0481+  59F9             _BM_DO_BS_END:
0482+  59F9 FD 7E 0C        ld a,(iy+BM_CUR_DIR_LEVEL)
0483+  59FC 3D              dec a
0484+  59FD FD 77 0C        ld (iy+BM_CUR_DIR_LEVEL),a
0485+  5A00             _BM_DO_BS_END_2:
0486+  5A00 CD 48 60        call BM_GET_CUR_DIR_ADD
0487+  5A03 CD FE 5F        call BM_STRLEN
0488+  5A06 78              ld a,b
0489+  5A07 FD 77 4E        ld (iy+BM_CUR_DIR_LENGTH),a
0490+  5A0A CD 87 5E        call BM_PRINT_CUR_DIR
0491+  5A0D CD 91 5C        call BM_ENUM_FILES
0492+  5A10 C3 C2 57        jp BM_ENTER_MAIN_LOOP
0493+  5A13             
0494+  5A13             
0495+  5A13             ;--- Help loop, entered when F1 is pressed
0496+  5A13             
0497+  5A13             BM_DO_HELP:
0498+  5A13 CD 84 5D        call BM_CLEAR_INFO_AREA
0499+  5A16             
0500+  5A16 26 01           ld h,1
0501+  5A18 2E 04           ld l,4
0502+  5A1A CD C6 00        call POSIT
0503+  5A1D 21 85 62        ld hl,BM_HELP_1
0504+  5A20 CD B5 45        call PRINT
0505+  5A23             
0506+  5A23 21 A2 60        ld hl,BM_F1_NEXT
0507+  5A26 CD A1 5D        call BM_PRINT_STATUS
0508+  5A29             
0509+  5A29             _BM_HELP_LOOP1:
0510+  5A29 76              halt
0511+  5A2A CD F8 5E        call BM_F1_IS_PRESSED
0512+  5A2D 20 FA           jr nz,_BM_HELP_LOOP1
0513+  5A2F             
0514+  5A2F CD 84 5D        call BM_CLEAR_INFO_AREA
0515+  5A32             
0516+  5A32 26 01           ld h,1
0517+  5A34 2E 04           ld l,4
0518+  5A36 CD C6 00        call POSIT
0519+  5A39 21 E8 63        ld hl,BM_HELP_2
0520+  5A3C CD B5 45        call PRINT
0521+  5A3F             
0522+  5A3F 21 AC 60        ld hl,BM_F1_END
0523+  5A42 CD A1 5D        call BM_PRINT_STATUS
0524+  5A45             
0525+  5A45             _BM_HELP_LOOP2:
0526+  5A45 76              halt
0527+  5A46 CD F8 5E        call BM_F1_IS_PRESSED
0528+  5A49 20 FA           jr nz,_BM_HELP_LOOP2
0529+  5A4B             
0530+  5A4B C3 C2 57        jp BM_ENTER_MAIN_LOOP
0531+  5A4E             
0532+  5A4E             
0533+  5A4E             ;--- Config loop, entered when F2 is pressed
0534+  5A4E             
0535+  5A4E             BM_DO_CONFIG:
0536+  5A4E CD 84 5D        call BM_CLEAR_INFO_AREA
0537+  5A51 21 72 67        ld hl,BM_ZERO_S
0538+  5A54 CD A1 5D        call BM_PRINT_STATUS
0539+  5A57             
0540+  5A57 26 01           ld h,1
0541+  5A59 2E 04           ld l,4
0542+  5A5B CD C6 00        call POSIT
0543+  5A5E             
0544+  5A5E                 ;* Print the current boot directory
0545+  5A5E             
0546+  5A5E 21 B1 65        ld hl,BM_CONFIG_BOOTDIR_S
0547+  5A61 CD B5 45        call PRINT
0548+  5A64             
0549+  5A64 CD 3E 60        call BM_GET_BUF_ADD
0550+  5A67 E5              push hl
0551+  5A68 CD A3 6B        call DSK_GET_BOOTDIR
0552+  5A6B E1              pop hl
0553+  5A6C B7              or a
0554+  5A6D 28 0A           jr z,BM_DO_CONFIG_2
0555+  5A6F FE 01           cp 1
0556+  5A71 21 61 67        ld hl,BM_ERROR_S
0557+  5A74 28 03           jr z,BM_DO_CONFIG_2
0558+  5A76 21 9B 67        ld hl,DSK_MAIN_DIR_S
0559+  5A79             BM_DO_CONFIG_2:
0560+  5A79 CD B5 45        call PRINT
0561+  5A7C CD 96 5B        call BM_PRINT_CRLF
0562+  5A7F             
0563+  5A7F                 ;* Print the name of the default file in current dir
0564+  5A7F             
0565+  5A7F 21 BD 65        ld hl,BM_CONFIG_DEFFILE_S
0566+  5A82 CD B5 45        call PRINT
0567+  5A85             
0568+  5A85 CD 9C 5B        call BM_RESTORE_CURDIR
0569+  5A88             
0570+  5A88 CD 3E 60        call BM_GET_BUF_ADD
0571+  5A8B E5              push hl
0572+  5A8C CD 5F 68        call DSK_READ_DEFFILE_FILE
0573+  5A8F E1              pop hl
0574+  5A90 B7              or a
0575+  5A91 28 0A           jr z,BM_DO_CONFIG_3
0576+  5A93 FE 01           cp 1
0577+  5A95 21 61 67        ld hl,BM_ERROR_S
0578+  5A98 28 03           jr z,BM_DO_CONFIG_3
0579+  5A9A 21 69 67        ld hl,BM_UNSET_S
0580+  5A9D             BM_DO_CONFIG_3:
0581+  5A9D F5              push af
0582+  5A9E CD B5 45        call PRINT
0583+  5AA1 CD 96 5B        call BM_PRINT_CRLF
0584+  5AA4             
0585+  5AA4                 ;* Print the current boot mode
0586+  5AA4             
0587+  5AA4 21 D8 65        ld hl,BM_CONFIG_BOOTMODE_S
0588+  5AA7 CD B5 45        call PRINT
0589+  5AAA CD F6 6B        call DSK_GET_BOOTMODE
0590+  5AAD C6 30           add "0"
0591+  5AAF CD A2 00        call CHPUT
0592+  5AB2             
0593+  5AB2 CD 9C 5B        call BM_RESTORE_CURDIR
0594+  5AB5             
0595+  5AB5                 ;* Print the boot mode change options
0596+  5AB5             
0597+  5AB5 21 E4 65        ld hl,BM_CONFIG_TEXT_S
0598+  5AB8 CD B5 45        call PRINT
0599+  5ABB             
0600+  5ABB                 ;* Print "set (currently pointed file) as default" if it's indeed a file
0601+  5ABB             
0602+  5ABB                 ;BM_TEMP usage:
0603+  5ABB                 ;bit 0 set if there's a pointed file that can be set as default
0604+  5ABB                 ;bit 1 set if there's a default file that can be unset
0605+  5ABB FD 36 54 00     ld (iy+BM_TEMP),0
0606+  5ABF             
0607+  5ABF FD 6E 02        ld l,(iy+BM_NUM_FILES)
0608+  5AC2 FD 66 03        ld h,(iy+BM_NUM_FILES+1)
0609+  5AC5 7C              ld a,h
0610+  5AC6 B5              or l
0611+  5AC7 28 29           jr z,BM_DO_CONFIG_4
0612+  5AC9             
0613+  5AC9 FD 6E 06        ld l,(iy+BM_CUR_FILE_PNT)
0614+  5ACC FD 66 07        ld h,(iy+BM_CUR_FILE_PNT+1)
0615+  5ACF E5              push hl
0616+  5AD0 DD E1           pop ix
0617+  5AD2 DD 7E 0A        ld a,(ix+10)
0618+  5AD5 E6 80           and 80h     ;Is it a directory?
0619+  5AD7 20 19           jr nz,BM_DO_CONFIG_4
0620+  5AD9             
0621+  5AD9 FD CB 54 C6     set 0,(iy+BM_TEMP)
0622+  5ADD 21 93 66        ld hl,BM_CONFIG_SET_DEF_S
0623+  5AE0 CD B5 45        call PRINT
0624+  5AE3 FD 6E 06        ld l,(iy+BM_CUR_FILE_PNT)
0625+  5AE6 FD 66 07        ld h,(iy+BM_CUR_FILE_PNT+1)
0626+  5AE9 CD 49 5D        call BM_PRINT_FILENAME
0627+  5AEC             
0628+  5AEC 21 9B 66        ld hl,BM_CONFIG_TEXT_2_S
0629+  5AEF CD B5 45        call PRINT
0630+  5AF2             
0631+  5AF2                 ;* Print "unset default file" if one is set
0632+  5AF2             
0633+  5AF2             BM_DO_CONFIG_4:
0634+  5AF2 F1              pop af
0635+  5AF3 B7              or a
0636+  5AF4 20 25           jr nz,BM_DO_CONFIG_ASK
0637+  5AF6 FD CB 54 CE     set 1,(iy+BM_TEMP)
0638+  5AFA 21 C0 66        ld hl,BM_CONFIG_UNSET_DEF_S
0639+  5AFD CD B5 45        call PRINT
0640+  5B00             
0641+  5B00                 ;* Print "Enable/disable CAPS lit on file access"
0642+  5B00             
0643+  5B00 21 BB 66        ld hl,BM_CONFIG_TWOCRLF_S
0644+  5B03 CD B5 45        call PRINT
0645+  5B06 CD 6D 6D        call DSK_TEST_CAPS_LIT
0646+  5B09 B7              or a
0647+  5B0A 21 EF 66        ld hl,BM_CONFIG_ENABLE_8_S
0648+  5B0D 28 03           jr z,BM_DO_CONFIG_5
0649+  5B0F 21 F9 66        ld hl,BM_CONFIG_DISABLE_8_S
0650+  5B12             BM_DO_CONFIG_5:
0651+  5B12 CD B5 45        call PRINT
0652+  5B15 21 04 67        ld hl,BM_CONFIG_CAPS_LIT_S
0653+  5B18 CD B5 45        call PRINT
0654+  5B1B             
0655+  5B1B                 ;* All info printed, ask user what to do and do it
0656+  5B1B             
0657+  5B1B             BM_DO_CONFIG_ASK:
0658+  5B1B 21 1D 67        ld hl,BM_CONFIG_CHOOSE_S
0659+  5B1E CD 98 59        call BM_PRINT_STATUS_WAIT_KEY
0660+  5B21             
0661+  5B21 D6 30           sub "0"
0662+  5B23 B7              or a
0663+  5B24 28 14           jr z,BM_DO_CONFIG_RETURN
0664+  5B26             
0665+  5B26 FE 05           cp 5
0666+  5B28 38 16           jr c,BM_DO_CONFIG_BOOTMODE
0667+  5B2A             
0668+  5B2A                 ;cp 5
0669+  5B2A 28 1B           jr z,BM_DO_SET_BOOTDIR
0670+  5B2C             
0671+  5B2C FE 06           cp 6
0672+  5B2E 28 1F           jr z,BM_DO_SET_DEFFILE
0673+  5B30             
0674+  5B30 FE 07           cp 7
0675+  5B32 28 35           jr z,BM_DO_UNSET_DEFFILE
0676+  5B34             
0677+  5B34 FE 08           cp 8
0678+  5B36 28 42           jr z,BM_DO_TOGGLE_CAPS_LIT
0679+  5B38             
0680+  5B38 18 E1           jr BM_DO_CONFIG_ASK ;Invalid action selected: ask again
0681+  5B3A             
0682+  5B3A             BM_DO_CONFIG_RETURN:
0683+  5B3A CD 9C 5B        call BM_RESTORE_CURDIR
0684+  5B3D C3 C2 57        jp BM_ENTER_MAIN_LOOP
0685+  5B40             
0686+  5B40             BM_DO_CONFIG_BOOTMODE:
0687+  5B40 C6 30           add "0"
0688+  5B42 CD 44 68        call DSK_WRITE_BOOTMODE_FILE
0689+  5B45 18 42           jr BM_DO_CONFIG_AFTER_CHANGE
0690+  5B47             
0691+  5B47             BM_DO_SET_BOOTDIR:
0692+  5B47 CD 48 60        call BM_GET_CUR_DIR_ADD
0693+  5B4A CD 39 68        call DSK_WRITE_BOOTDIR_FILE
0694+  5B4D 18 3A           jr BM_DO_CONFIG_AFTER_CHANGE
0695+  5B4F             
0696+  5B4F             BM_DO_SET_DEFFILE:
0697+  5B4F FD CB 54 46     bit 0,(iy+BM_TEMP)
0698+  5B53 28 C6           jr z,BM_DO_CONFIG_ASK
0699+  5B55             
0700+  5B55 CD 3E 60        call BM_GET_BUF_ADD
0701+  5B58 E5              push hl
0702+  5B59 EB              ex de,hl
0703+  5B5A FD 6E 06        ld l,(iy+BM_CUR_FILE_PNT)
0704+  5B5D FD 66 07        ld h,(iy+BM_CUR_FILE_PNT+1)
0705+  5B60 CD 3D 5D        call BM_GENERATE_FILENAME
0706+  5B63 E1              pop hl
0707+  5B64 CD 54 68        call DSK_WRITE_DEFFILE_FILE
0708+  5B67 18 20           jr BM_DO_CONFIG_AFTER_CHANGE
0709+  5B69             
0710+  5B69             BM_DO_UNSET_DEFFILE:
0711+  5B69 FD CB 54 4E     bit 1,(iy+BM_TEMP)
0712+  5B6D 28 AC           jr z,BM_DO_CONFIG_ASK
0713+  5B6F             
0714+  5B6F CD 9C 5B        call BM_RESTORE_CURDIR
0715+  5B72 21 72 67        ld hl,BM_ZERO_S
0716+  5B75 CD 54 68        call DSK_WRITE_DEFFILE_FILE
0717+  5B78 18 0F           jr BM_DO_CONFIG_AFTER_CHANGE
0718+  5B7A             
0719+  5B7A             BM_DO_TOGGLE_CAPS_LIT:
0720+  5B7A CD 6D 6D        call DSK_TEST_CAPS_LIT
0721+  5B7D EE 01           xor 1
0722+  5B7F CD 5A 6D        call DSK_SET_OR_UNSET_CAPS_LIT
0723+  5B82 B7              or a
0724+  5B83 20 04           jr nz,BM_DO_CONFIG_AFTER_CHANGE
0725+  5B85 CD 95 6D        call DSK_UPDATE_CAPS_LIT_WK
0726+  5B88 AF              xor a
0727+  5B89                 ;jr BM_DO_CONFIG_AFTER_CHANGE
0728+  5B89             
0729+  5B89                 ;* After doing an action, show error if needed, then start over
0730+  5B89             
0731+  5B89             BM_DO_CONFIG_AFTER_CHANGE:
0732+  5B89 B7              or a
0733+  5B8A CA 4E 5A        jp z,BM_DO_CONFIG
0734+  5B8D 21 3E 67        ld hl,BM_CONFIG_ERROR_APPLYING_S
0735+  5B90 CD 98 59        call BM_PRINT_STATUS_WAIT_KEY
0736+  5B93 C3 4E 5A        jp BM_DO_CONFIG
0737+  5B96             
0738+  5B96             
0739+  5B96             ;--- Just that... print a CRLF sequence
0740+  5B96             
0741+  5B96             BM_PRINT_CRLF:
0742+  5B96 21 DA 46        ld hl,CRLF_S
0743+  5B99 C3 B5 45        jp PRINT
0744+  5B9C             
0745+  5B9C             
0746+  5B9C             ;--- Set again the directory in CURDIR
0747+  5B9C             
0748+  5B9C             BM_RESTORE_CURDIR:
0749+  5B9C CD 48 60        call BM_GET_CUR_DIR_ADD
0750+  5B9F 3E 01           ld a,1
0751+  5BA1 C3 6C 68        jp DSK_CHANGE_DIR 
0752+  5BA4             
0753+  5BA4             
0754+  5BA4             ;--- Update currently pointed file on cursor press
0755+  5BA4             ;    Input: A = pressed cursor key
0756+  5BA4             
0757+  5BA4             BM_UPDATE_CUR_FILE:
0758+  5BA4 F5              push af
0759+  5BA5 CD F9 5D        call BM_POSIT_CUR_FILE
0760+  5BA8 CD 14 5E        call BM_PRINT_CURRENT_FILE
0761+  5BAB F1              pop af
0762+  5BAC                 
0763+  5BAC 3D              dec a
0764+  5BAD 28 1D           jr z,_BM_FILE_UP
0765+  5BAF 3D              dec a
0766+  5BB0 28 0F           jr z,_BM_FILE_RIGHT
0767+  5BB2 3D              dec a
0768+  5BB3 28 23           jr z,_BM_FILE_DOWN
0769+  5BB5             
0770+  5BB5             _BM_FILE_LEFT:
0771+  5BB5 FD 7E 09        ld a,(iy+BM_CUR_COL)
0772+  5BB8 3D              dec a
0773+  5BB9 FE FF           cp 0FFh
0774+  5BBB 20 26           jr nz,_BM_UPDATE_CUR_COL_GO
0775+  5BBD 3E 02           ld a,2
0776+  5BBF 18 22           jr _BM_UPDATE_CUR_COL_GO
0777+  5BC1             
0778+  5BC1             _BM_FILE_RIGHT:
0779+  5BC1 FD 7E 09        ld a,(iy+BM_CUR_COL)
0780+  5BC4 3C              inc a
0781+  5BC5 FE 03           cp 3
0782+  5BC7 38 1A           jr c,_BM_UPDATE_CUR_COL_GO
0783+  5BC9 AF              xor a
0784+  5BCA 18 17           jr _BM_UPDATE_CUR_COL_GO
0785+  5BCC             
0786+  5BCC             _BM_FILE_UP:
0787+  5BCC FD 7E 08        ld a,(iy+BM_CUR_ROW)
0788+  5BCF 3D              dec a
0789+  5BD0 FE FF           cp 0FFh
0790+  5BD2 20 21           jr nz,_BM_UPDATE_CUR_ROW_GO
0791+  5BD4 3E 13           ld a,19
0792+  5BD6 18 1D           jr _BM_UPDATE_CUR_ROW_GO
0793+  5BD8             
0794+  5BD8             _BM_FILE_DOWN:
0795+  5BD8 FD 7E 08        ld a,(iy+BM_CUR_ROW)
0796+  5BDB 3C              inc a
0797+  5BDC FE 14           cp 20
0798+  5BDE 38 15           jr c,_BM_UPDATE_CUR_ROW_GO
0799+  5BE0 AF              xor a
0800+  5BE1 18 12           jr _BM_UPDATE_CUR_ROW_GO
0801+  5BE3             
0802+  5BE3             _BM_UPDATE_CUR_COL_GO:
0803+  5BE3 FD 77 09        ld (iy+BM_CUR_COL),a
0804+  5BE6 FD E5           push iy
0805+  5BE8 E1              pop hl
0806+  5BE9 01 09 00        ld bc,BM_CUR_COL
0807+  5BEC 09              add hl,bc
0808+  5BED FD 75 54        ld (iy+BM_TEMP),l
0809+  5BF0 FD 74 55        ld (iy+BM_TEMP+1),h
0810+  5BF3 18 10           jr _BM_UPDATE_CUR_ROWCOL_GO
0811+  5BF5             
0812+  5BF5             _BM_UPDATE_CUR_ROW_GO:
0813+  5BF5 FD 77 08        ld (iy+BM_CUR_ROW),a
0814+  5BF8 FD E5           push iy
0815+  5BFA E1              pop hl
0816+  5BFB 01 08 00        ld bc,BM_CUR_ROW
0817+  5BFE 09              add hl,bc
0818+  5BFF FD 75 54        ld (iy+BM_TEMP),l
0819+  5C02 FD 74 55        ld (iy+BM_TEMP+1),h
0820+  5C05             
0821+  5C05             _BM_UPDATE_CUR_ROWCOL_GO:
0822+  5C05 CD 9A 5F        call BM_UPDATE_CUR_FILE_PNT
0823+  5C08 FD 6E 06        ld l,(iy+BM_CUR_FILE_PNT)
0824+  5C0B FD 66 07        ld h,(iy+BM_CUR_FILE_PNT+1)
0825+  5C0E 7E              ld a,(hl)
0826+  5C0F B7              or a
0827+  5C10 20 0B           jr nz,_BM_UPDATE_CUR_ROWCOL_GO_2
0828+  5C12                 ;We ended up pointing past the end of the list,
0829+  5C12                 ;so reset column/row to 0
0830+  5C12 FD 6E 54        ld l,(iy+BM_TEMP)
0831+  5C15 FD 66 55        ld h,(iy+BM_TEMP+1)
0832+  5C18 36 00           ld (hl),0
0833+  5C1A CD 9A 5F        call BM_UPDATE_CUR_FILE_PNT
0834+  5C1D             
0835+  5C1D             _BM_UPDATE_CUR_ROWCOL_GO_2:
0836+  5C1D CD F9 5D        call BM_POSIT_CUR_FILE
0837+  5C20 CD 2A 5E        call BM_PRINT_CURRENT_FILE_AS_SELECTED
0838+  5C23 C3 DF 57        jp _BM_MAIN_LOOP
0839+  5C26             
0840+  5C26             
0841+  5C26             ;--- Update current page on cursor+SHIFT press
0842+  5C26             ;    Input: A = pressed cursor key
0843+  5C26             
0844+  5C26             BM_UPDATE_PAGE:
0845+  5C26 3D              dec a
0846+  5C27 28 1E           jr z,_BM_NEXT_10_PAGES
0847+  5C29 3D              dec a
0848+  5C2A 28 09           jr z,_BM_NEXT_PAGE
0849+  5C2C 3D              dec a
0850+  5C2D 28 41           jr z,_BM_PREV_10_PAGES
0851+  5C2F 3D              dec a
0852+  5C30 28 2F           jr z,_BM_PREV_PAGE
0853+  5C32 C3 DF 57        jp _BM_MAIN_LOOP
0854+  5C35             
0855+  5C35             _BM_NEXT_PAGE:
0856+  5C35 FD 7E 00        ld a,(iy+BM_NUM_PAGES)
0857+  5C38 47              ld b,a
0858+  5C39 FD 7E 01        ld a,(iy+BM_CUR_PAGE)
0859+  5C3C B8              cp b
0860+  5C3D CA DF 57        jp z,_BM_MAIN_LOOP
0861+  5C40             
0862+  5C40 3C              inc a
0863+  5C41 FD 77 01        ld (iy+BM_CUR_PAGE),a
0864+  5C44 C3 87 5C        jp _BM_UPDATE_PAGE_END
0865+  5C47             
0866+  5C47             _BM_NEXT_10_PAGES:
0867+  5C47 FD 7E 00        ld a,(iy+BM_NUM_PAGES)
0868+  5C4A 47              ld b,a
0869+  5C4B FD 7E 01        ld a,(iy+BM_CUR_PAGE)
0870+  5C4E B8              cp b
0871+  5C4F D2 DF 57        jp nc,_BM_MAIN_LOOP
0872+  5C52 04              inc b
0873+  5C53 C6 0A           add 10
0874+  5C55 B8              cp b
0875+  5C56 38 03           jr c,_BM_NEXT_10_PAGES_GO
0876+  5C58 FD 7E 00        ld a,(iy+BM_NUM_PAGES)
0877+  5C5B             
0878+  5C5B             _BM_NEXT_10_PAGES_GO:
0879+  5C5B FD 77 01        ld (iy+BM_CUR_PAGE),a
0880+  5C5E C3 87 5C        jp _BM_UPDATE_PAGE_END
0881+  5C61             
0882+  5C61             _BM_PREV_PAGE:
0883+  5C61 FD 7E 01        ld a,(iy+BM_CUR_PAGE)
0884+  5C64 FE 01           cp 1
0885+  5C66 CA DF 57        jp z,_BM_MAIN_LOOP
0886+  5C69             
0887+  5C69 3D              dec a
0888+  5C6A FD 77 01        ld (iy+BM_CUR_PAGE),a
0889+  5C6D C3 87 5C        jp _BM_UPDATE_PAGE_END
0890+  5C70             
0891+  5C70             _BM_PREV_10_PAGES:
0892+  5C70 FD 7E 01        ld a,(iy+BM_CUR_PAGE)
0893+  5C73 FE 01           cp 1
0894+  5C75 CA DF 57        jp z,_BM_MAIN_LOOP
0895+  5C78 D6 0A           sub 10
0896+  5C7A 28 03           jr z,_BM_PREV_10_PAGES_1
0897+  5C7C F2 81 5C        jp p,_BM_PREV_10_PAGES_GO
0898+  5C7F             _BM_PREV_10_PAGES_1:    
0899+  5C7F 3E 01           ld a,1
0900+  5C81             
0901+  5C81             _BM_PREV_10_PAGES_GO:
0902+  5C81 FD 77 01        ld (iy+BM_CUR_PAGE),a
0903+  5C84 C3 87 5C        jp _BM_UPDATE_PAGE_END
0904+  5C87             
0905+  5C87             _BM_UPDATE_PAGE_END:
0906+  5C87 AF              xor a
0907+  5C88 FD 77 08        ld (iy+BM_CUR_ROW),a
0908+  5C8B FD 77 09        ld (iy+BM_CUR_COL),a
0909+  5C8E C3 C2 57        jp BM_ENTER_MAIN_LOOP
0910+  5C91             
0911+  5C91             
0912+  5C91                 ;--- Enumerate files and initialize paging
0913+  5C91             
0914+  5C91             BM_ENUM_FILES:
0915+  5C91 3E 01           ld a,1
0916+  5C93 FD 77 01        ld (iy+BM_CUR_PAGE),a
0917+  5C96             
0918+  5C96 CD 84 5D        call BM_CLEAR_INFO_AREA
0919+  5C99 21 EB 60        ld hl,BM_SCANNING_DIR_S
0920+  5C9C CD A1 5D        call BM_PRINT_STATUS
0921+  5C9F             
0922+  5C9F 2A C6 F6        ld hl,(STREND)
0923+  5CA2 FD 4E 4F        ld c,(iy+BM_MAX_FILES_TO_ENUM)
0924+  5CA5 FD 46 50        ld b,(iy+BM_MAX_FILES_TO_ENUM+1)
0925+  5CA8 CD 40 42        call HWF_ENUM_FILES
0926+  5CAB FD 71 02        ld (iy+BM_NUM_FILES),c
0927+  5CAE FD 70 03        ld (iy+BM_NUM_FILES+1),b
0928+  5CB1 C5              push bc
0929+  5CB2             
0930+  5CB2 E5              push hl ;Fill one extra page of 0s.
0931+  5CB3 D1              pop de  ;This will be used to detect non-existing
0932+  5CB4 13              inc de  ;file positions in the last page.
0933+  5CB5 36 00           ld (hl),0
0934+  5CB7 01 88 02        ld bc,59*11-1
0935+  5CBA ED B0           ldir
0936+  5CBC             
0937+  5CBC E1              pop hl
0938+  5CBD 06 00           ld b,0
0939+  5CBF             _BM_CALC_NUM_PAGES:
0940+  5CBF 7C              ld a,h
0941+  5CC0 B7              or a
0942+  5CC1 20 0B           jr nz,_BM_CALC_NUM_PAGES_ADD
0943+  5CC3 7D              ld a,l
0944+  5CC4 B7              or a
0945+  5CC5 28 10           jr z,_BM_CALC_NUM_PAGES_END
0946+  5CC7 FE 3C           cp 60
0947+  5CC9 30 03           jr nc,_BM_CALC_NUM_PAGES_ADD
0948+  5CCB             
0949+  5CCB 04              inc b
0950+  5CCC 18 09           jr _BM_CALC_NUM_PAGES_END
0951+  5CCE             
0952+  5CCE             _BM_CALC_NUM_PAGES_ADD:
0953+  5CCE 04              inc b
0954+  5CCF 11 3C 00        ld de,60
0955+  5CD2 B7              or a
0956+  5CD3 ED 52           sbc hl,de
0957+  5CD5 18 E8           jr _BM_CALC_NUM_PAGES
0958+  5CD7             
0959+  5CD7             _BM_CALC_NUM_PAGES_END:
0960+  5CD7 78              ld a,b
0961+  5CD8 B7              or a
0962+  5CD9 20 01           jr nz,_BM_CALC_NUM_PAGES_END_2
0963+  5CDB 3C              inc a
0964+  5CDC             _BM_CALC_NUM_PAGES_END_2:
0965+  5CDC FD 77 00        ld (iy+BM_NUM_PAGES),a
0966+  5CDF             
0967+  5CDF AF              xor a
0968+  5CE0 FD 77 08        ld (iy+BM_CUR_ROW),a
0969+  5CE3 FD 77 09        ld (iy+BM_CUR_COL),a
0970+  5CE6 C9              ret
0971+  5CE7             
0972+  5CE7             
0973+  5CE7             ; -----------------------------------------------------------------------------
0974+  5CE7             ; Screen printing routines
0975+  5CE7             ; -----------------------------------------------------------------------------
0976+  5CE7             
0977+  5CE7             
0978+  5CE7             ;--- Print the filenames for the current page
0979+  5CE7             
0980+  5CE7             BM_PRINT_FILENAMES_PAGE:
0981+  5CE7 FD 6E 02        ld l,(iy+BM_NUM_FILES)
0982+  5CEA FD 66 03        ld h,(iy+BM_NUM_FILES+1)
0983+  5CED 7C              ld a,h
0984+  5CEE B5              or l
0985+  5CEF C2 FF 5C        jp nz,_BM_PRINT_FILENAMES_PAGE_GO
0986+  5CF2             
0987+  5CF2 26 03           ld h,3
0988+  5CF4 2E 0C           ld l,12
0989+  5CF6 CD C6 00        call POSIT
0990+  5CF9 21 C6 60        ld hl,BM_NO_FILES_S
0991+  5CFC C3 B5 45        jp PRINT
0992+  5CFF             
0993+  5CFF             _BM_PRINT_FILENAMES_PAGE_GO:
0994+  5CFF FD 7E 01        ld a,(iy+BM_CUR_PAGE)
0995+  5D02 47              ld b,a
0996+  5D03 2A C6 F6        ld hl,(STREND)
0997+  5D06 11 94 02        ld de,11*60
0998+  5D09 B7              or a
0999+  5D0A ED 52           sbc hl,de
1000+  5D0C             _BM_PRINT_FILENAMES_CALC:
1001+  5D0C 19              add hl,de
1002+  5D0D 10 FD           djnz _BM_PRINT_FILENAMES_CALC
1003+  5D0F             
1004+  5D0F CD 84 5D        call BM_CLEAR_INFO_AREA
1005+  5D12             
1006+  5D12 06 02           ld b,2  ;X coordinate
1007+  5D14             _BM_PRINT_FILENAMES_COLUMN:
1008+  5D14 0E 03           ld c,3  ;Y coordinate
1009+  5D16             
1010+  5D16 E5              push hl
1011+  5D17 60              ld h,b
1012+  5D18 69              ld l,c
1013+  5D19 CD C6 00        call POSIT
1014+  5D1C E1              pop hl
1015+  5D1D             
1016+  5D1D             _BM_PRINT_FILENAMES_COLUMN_LOOP:
1017+  5D1D 7E              ld a,(hl)
1018+  5D1E B7              or a
1019+  5D1F C8              ret z   ;End of the files list reached
1020+  5D20             
1021+  5D20 C5              push bc
1022+  5D21 CD 49 5D        call BM_PRINT_FILENAME
1023+  5D24 C1              pop bc
1024+  5D25 0C              inc c
1025+  5D26 79              ld a,c
1026+  5D27 FE 17           cp 23
1027+  5D29 30 09           jr nc,_BM_PRINT_FILENAMES_COLUMN_END
1028+  5D2B             
1029+  5D2B E5              push hl
1030+  5D2C 60              ld h,b
1031+  5D2D 69              ld l,c
1032+  5D2E CD C6 00        call POSIT
1033+  5D31 E1              pop hl
1034+  5D32             
1035+  5D32 18 E9           jr _BM_PRINT_FILENAMES_COLUMN_LOOP
1036+  5D34             
1037+  5D34             _BM_PRINT_FILENAMES_COLUMN_END:
1038+  5D34 78              ld a,b
1039+  5D35 C6 0D           add 13
1040+  5D37 47              ld b,a
1041+  5D38 FE 25           cp 37
1042+  5D3A 38 D8           jr c,_BM_PRINT_FILENAMES_COLUMN
1043+  5D3C             
1044+  5D3C C9              ret
1045+  5D3D             
1046+  5D3D             
1047+  5D3D             ;--- Generate a formatted file name from one in dir entry format
1048+  5D3D             ;    Input:  HL = Pointer to filename in directory entry format
1049+  5D3D             ;                 (11 chars, name and extension padded with spaces)
1050+  5D3D             ;            DE = Destination buffer for the formatted file name
1051+  5D3D             ;    Output: HL = Points past the filename
1052+  5D3D             ;            DE = Points to the termination 0
1053+  5D3D             ;            C  = Length of the formatted file name
1054+  5D3D             
1055+  5D3D             BM_GENERATE_FILENAME:
1056+  5D3D DD 21 80 5D     ld ix,_BM_DO_LD_DE
1057+  5D41 0E 00           ld c,0
1058+  5D43 CD 4D 5D        call _BM_PRINTPUT_FILENAME
1059+  5D46 AF              xor a
1060+  5D47 12              ld (de),a
1061+  5D48 C9              ret
1062+  5D49             
1063+  5D49             
1064+  5D49             ;--- Print a formatted file name in the current position
1065+  5D49             ;    Input:  HL = Pointer to filename in directory entry format
1066+  5D49             ;                 (11 chars, name and extension padded with spaces)
1067+  5D49             ;    Output: HL = Points past the filename
1068+  5D49             ;            C  = Length of the printed file name
1069+  5D49             
1070+  5D49             BM_PRINT_FILENAME:
1071+  5D49 DD 21 7C 5D     ld ix,_BM_DO_CHPUT
1072+  5D4D             
1073+  5D4D             
1074+  5D4D             _BM_PRINTPUT_FILENAME:
1075+  5D4D 06 08           ld b,8
1076+  5D4F 0E 00           ld c,0
1077+  5D51             _BM_PRINT_FILENAME_MAIN:
1078+  5D51 7E              ld a,(hl)
1079+  5D52 23              inc hl
1080+  5D53 FE 20           cp ' '
1081+  5D55 C4 D0 7F        call nz,CALL_IX
1082+  5D58 10 F7           djnz _BM_PRINT_FILENAME_MAIN
1083+  5D5A             
1084+  5D5A 7E              ld a,(hl)
1085+  5D5B FE 20           cp ' '
1086+  5D5D 06 03           ld b,3
1087+  5D5F 28 05           jr z,_BM_PRINT_FILENAME_EXT
1088+  5D61 3E 2E           ld a,'.'
1089+  5D63 CD D0 7F        call CALL_IX
1090+  5D66             _BM_PRINT_FILENAME_EXT:
1091+  5D66 7E              ld a,(hl)
1092+  5D67 23              inc hl
1093+  5D68 E6 7F           and 7Fh
1094+  5D6A FE 20           cp ' '
1095+  5D6C C4 D0 7F        call nz,CALL_IX
1096+  5D6F 10 F5           djnz _BM_PRINT_FILENAME_EXT
1097+  5D71             
1098+  5D71 2B              dec hl
1099+  5D72 7E              ld a,(hl)
1100+  5D73 23              inc hl
1101+  5D74 E6 80           and 80h
1102+  5D76 C8              ret z
1103+  5D77 3E 2F           ld a,'/'
1104+  5D79 C3 D0 7F        jp CALL_IX
1105+  5D7C             
1106+  5D7C             _BM_DO_CHPUT:
1107+  5D7C 0C              inc c
1108+  5D7D C3 A2 00        jp CHPUT
1109+  5D80             
1110+  5D80             _BM_DO_LD_DE:
1111+  5D80 12              ld (de),a
1112+  5D81 13              inc de
1113+  5D82 0C              inc c
1114+  5D83 C9              ret
1115+  5D84             
1116+  5D84             
1117+  5D84             ;--- Clear the central information area
1118+  5D84             
1119+  5D84             BM_CLEAR_INFO_AREA:
1120+  5D84 E5              push hl
1121+  5D85 26 01           ld h,1
1122+  5D87 2E 03           ld l,3
1123+  5D89 CD C6 00        call POSIT
1124+  5D8C E1              pop hl
1125+  5D8D 06 14           ld b,20
1126+  5D8F             _BM_CLEAR_INFO_AREA_LOOP:
1127+  5D8F 3E 1B           ld a,27
1128+  5D91 CD A2 00        call CHPUT
1129+  5D94 3E 4B           ld a,'K'
1130+  5D96 CD A2 00        call CHPUT  ;Delete to end of line
1131+  5D99 3E 0A           ld a,10
1132+  5D9B CD A2 00        call CHPUT
1133+  5D9E 10 EF           djnz _BM_CLEAR_INFO_AREA_LOOP
1134+  5DA0 C9              ret
1135+  5DA1             
1136+  5DA1             
1137+  5DA1             ;--- Print something in the lower status line
1138+  5DA1             ;    Input: HL = Pointer to string to print
1139+  5DA1             
1140+  5DA1             BM_PRINT_STATUS:
1141+  5DA1 E5              push hl
1142+  5DA2 26 02           ld h,2
1143+  5DA4 2E 18           ld l,24
1144+  5DA6 CD C6 00        call POSIT
1145+  5DA9 3E 1B           ld a,27
1146+  5DAB CD A2 00        call CHPUT
1147+  5DAE 3E 4B           ld a,'K'
1148+  5DB0 CD A2 00        call CHPUT  ;Delete to end of line
1149+  5DB3 E1              pop hl
1150+  5DB4 C3 B5 45        jp PRINT
1151+  5DB7             
1152+  5DB7             
1153+  5DB7             ;--- Print the main lower status line
1154+  5DB7             ;    ("F1=HELP" and current page number)
1155+  5DB7             
1156+  5DB7             BM_PRINT_MAIN_STATUS:
1157+  5DB7 21 8B 60        ld hl,BM_F1_HELP
1158+  5DBA CD A1 5D        call BM_PRINT_STATUS
1159+  5DBD             
1160+  5DBD             BM_PRINT_PAGE_NUM:
1161+  5DBD 26 1C           ld h,28
1162+  5DBF 2E 18           ld l,24
1163+  5DC1 CD C6 00        call POSIT
1164+  5DC4 21 B5 60        ld hl,BM_PAGE_S
1165+  5DC7 CD B5 45        call PRINT
1166+  5DCA             
1167+  5DCA FD 7E 01        ld a,(iy+BM_CUR_PAGE)
1168+  5DCD CD DC 5D        call BM_PRINT_BYTE
1169+  5DD0 21 BB 60        ld hl,BM_SPACE_AND_BAR
1170+  5DD3 CD B5 45        call PRINT
1171+  5DD6 FD 7E 00        ld a,(iy+BM_NUM_PAGES)
1172+  5DD9 C3 DC 5D        jp BM_PRINT_BYTE
1173+  5DDC             
1174+  5DDC             BM_PRINT_BYTE:
1175+  5DDC CD 3E 60        call BM_GET_BUF_ADD
1176+  5DDF E5              push hl
1177+  5DE0 DD E1           pop ix
1178+  5DE2 CD 45 55        call BYTE2ASC
1179+  5DE5 DD 36 00 00     ld (ix),0
1180+  5DE9 CD 3E 60        call BM_GET_BUF_ADD
1181+  5DEC C3 B5 45        jp PRINT
1182+  5DEF             
1183+  5DEF             
1184+  5DEF             ;--- Draw a horizontal line of 40 hyphens in the current cursor location
1185+  5DEF             
1186+  5DEF             BM_DRAW_LINE:
1187+  5DEF 06 28           ld b,40
1188+  5DF1             _BM_DRAW_LINE_LOOP:
1189+  5DF1 3E 2D           ld a,"-"
1190+  5DF3 CD A2 00        call CHPUT
1191+  5DF6 10 F9           djnz _BM_DRAW_LINE_LOOP
1192+  5DF8 C9              ret
1193+  5DF9             
1194+  5DF9             
1195+  5DF9             ;--- Position the cursor for the current file:
1196+  5DF9             ;    col = (BM_CUR_COL*13)+2
1197+  5DF9             ;    row = BM_CUR_ROW+3
1198+  5DF9             
1199+  5DF9             BM_POSIT_CUR_FILE:
1200+  5DF9 FD 7E 09        ld a,(iy+BM_CUR_COL)
1201+  5DFC 47              ld b,a
1202+  5DFD CB 27           sla a
1203+  5DFF CB 27           sla a
1204+  5E01 CB 27           sla a   ;*8
1205+  5E03 80              add b
1206+  5E04 80              add b
1207+  5E05 80              add b
1208+  5E06 80              add b
1209+  5E07 80              add b   ;*13
1210+  5E08 3C              inc a
1211+  5E09 3C              inc a
1212+  5E0A 67              ld h,a
1213+  5E0B FD 7E 08        ld a,(iy+BM_CUR_ROW)
1214+  5E0E C6 03           add 3
1215+  5E10 6F              ld l,a
1216+  5E11 C3 C6 00        jp POSIT
1217+  5E14             
1218+  5E14             
1219+  5E14             ;--- Print the current filename at the current position
1220+  5E14             
1221+  5E14             BM_PRINT_CURRENT_FILE:
1222+  5E14 FD 6E 06        ld l,(iy+BM_CUR_FILE_PNT)
1223+  5E17 FD 66 07        ld h,(iy+BM_CUR_FILE_PNT+1)
1224+  5E1A CD 49 5D        call BM_PRINT_FILENAME
1225+  5E1D 06 20           ld b,' '
1226+  5E1F             _BM_PRINT_CURRENT_FILE_PAD:
1227+  5E1F 79              ld a,c
1228+  5E20 FE 0C           cp 12
1229+  5E22 D0              ret nc
1230+  5E23 78              ld a,b
1231+  5E24 CD A2 00        call CHPUT
1232+  5E27 0C              inc c
1233+  5E28 18 F5           jr _BM_PRINT_CURRENT_FILE_PAD
1234+  5E2A             
1235+  5E2A             
1236+  5E2A             ;--- Print the current filename at the current position, as selected
1237+  5E2A             
1238+  5E2A                 ;Generate the formatted file name in BM_BUF, padded with spaces
1239+  5E2A             
1240+  5E2A             BM_PRINT_CURRENT_FILE_AS_SELECTED:
1241+  5E2A CD 3E 60        call BM_GET_BUF_ADD
1242+  5E2D EB              ex de,hl
1243+  5E2E FD 6E 06        ld l,(iy+BM_CUR_FILE_PNT)
1244+  5E31 FD 66 07        ld h,(iy+BM_CUR_FILE_PNT+1)
1245+  5E34 CD 3D 5D        call BM_GENERATE_FILENAME
1246+  5E37             
1247+  5E37             _BM_GEN_CURRENT_FILE_PAD:
1248+  5E37 79              ld a,c
1249+  5E38 FE 0C           cp 12
1250+  5E3A 30 07           jr nc,_BM_GEN_CURRENT_FILE_OK
1251+  5E3C 3E 20           ld a,' '
1252+  5E3E 12              ld (de),a
1253+  5E3F 13              inc de
1254+  5E40 0C              inc c
1255+  5E41 18 F4           jr _BM_GEN_CURRENT_FILE_PAD
1256+  5E43             _BM_GEN_CURRENT_FILE_OK:
1257+  5E43             
1258+  5E43                 ;Redefine chars 128-139 as the inverted chars of the filename
1259+  5E43             
1260+  5E43 2A B7 F3        ld hl,(TXTCGP)
1261+  5E46 11 00 04        ld de,128*8
1262+  5E49 19              add hl,de
1263+  5E4A CD 53 00        call SETWRT
1264+  5E4D             
1265+  5E4D 3A 07 00        ld a,(VDP_DW)
1266+  5E50 4F              ld c,a      ;VDP write port
1267+  5E51             
1268+  5E51 CD 3E 60        call BM_GET_BUF_ADD  ;Pointer to current char
1269+  5E54 06 0C           ld b,12     ;How many chars left to invert
1270+  5E56             _BM_INVERT_CHARS_LOOP:
1271+  5E56 E5              push hl
1272+  5E57 C5              push bc
1273+  5E58 5E              ld e,(hl)
1274+  5E59 16 00           ld d,0
1275+  5E5B CB 23           sla e
1276+  5E5D CB 12           rl d
1277+  5E5F CB 23           sla e
1278+  5E61 CB 12           rl d
1279+  5E63 CB 23           sla e
1280+  5E65 CB 12           rl d    ;DE = Current char *8
1281+  5E67 2A 04 00        ld hl,(CGTABL)
1282+  5E6A 19              add hl,de   ;HL = Pointer to start of char definition
1283+  5E6B             
1284+  5E6B 06 08           ld b,8
1285+  5E6D             _BM_INVERT_ONE_CHAR_LOOP
1286+  5E6D 7E              ld a,(hl)
1287+  5E6E 2F              cpl
1288+  5E6F ED 79           out (c),a
1289+  5E71 23              inc hl
1290+  5E72 10 F9           djnz _BM_INVERT_ONE_CHAR_LOOP
1291+  5E74             
1292+  5E74 C1              pop bc
1293+  5E75 E1              pop hl
1294+  5E76 23              inc hl
1295+  5E77 10 DD           djnz _BM_INVERT_CHARS_LOOP
1296+  5E79             
1297+  5E79                 ;Print the inverted filename
1298+  5E79             
1299+  5E79 CD F9 5D        call BM_POSIT_CUR_FILE
1300+  5E7C 3E 80           ld a,128
1301+  5E7E             _BM_PRINT_INVERTED_LOOP:
1302+  5E7E CD A2 00        call CHPUT
1303+  5E81 3C              inc a
1304+  5E82 FE 8C           cp 128+12
1305+  5E84 38 F8           jr c,_BM_PRINT_INVERTED_LOOP
1306+  5E86             
1307+  5E86 C9              ret
1308+  5E87             
1309+  5E87             
1310+  5E87             ;--- Print the current directory in the top row
1311+  5E87             
1312+  5E87             BM_PRINT_CUR_DIR:
1313+  5E87 26 01           ld h,1
1314+  5E89 2E 01           ld l,1
1315+  5E8B CD C6 00        call POSIT
1316+  5E8E 3E 2F           ld a,"/"
1317+  5E90 CD A2 00        call CHPUT
1318+  5E93             
1319+  5E93 FD 7E 4E        ld a,(iy+BM_CUR_DIR_LENGTH)
1320+  5E96 FE 28           cp 40
1321+  5E98 38 0B           jr c,_BM_PRINT_CUR_DIR_DIRECT
1322+  5E9A             
1323+  5E9A 21 7D 62        ld hl,BM_DOTS_BAR_S
1324+  5E9D CD B5 45        call PRINT
1325+  5EA0             
1326+  5EA0                 ; Skip leading slash in the last directory part, then print it
1327+  5EA0 CD D2 5E        call BM_GET_LAST_DIR_PNT
1328+  5EA3 18 14           jr _BM_PRINT_CUR_DIR_TRUNC
1329+  5EA5             
1330+  5EA5             _BM_PRINT_CUR_DIR_DIRECT:
1331+  5EA5 CD 48 60        call BM_GET_CUR_DIR_ADD
1332+  5EA8                ; call PRINT
1333+  5EA8             
1334+  5EA8                ; Skip any leading '/'
1335+  5EA8             _BM_SKIP_LEADING_SLASH:
1336+  5EA8 7E              ld a,(hl)
1337+  5EA9 FE 2F           cp "/"
1338+  5EAB 20 03           jr nz,_BM_PRINT_CUR_DIR_PRINT
1339+  5EAD 23              inc hl
1340+  5EAE 18 F8           jr _BM_SKIP_LEADING_SLASH
1341+  5EB0             
1342+  5EB0             _BM_PRINT_CUR_DIR_PRINT:
1343+  5EB0 7E              ld a,(hl)
1344+  5EB1 B7              or a
1345+  5EB2 28 14           jr z,_BM_PRINT_CUR_DIR_END  ; If empty, done (just "/")
1346+  5EB4             
1347+  5EB4                 ; Print whatever is left
1348+  5EB4 CD B5 45        call PRINT
1349+  5EB7 18 0F           jr _BM_PRINT_CUR_DIR_END
1350+  5EB9             
1351+  5EB9             _BM_PRINT_CUR_DIR_TRUNC:
1352+  5EB9                 ; By default, BM_GET_LAST_DIR_PNT leaves HL pointing 
1353+  5EB9                 ; at the final name in the path, but let's skip slashes just in case
1354+  5EB9             
1355+  5EB9             _BM_SKIP_LEADING_SLASH_2:
1356+  5EB9 7E              ld a,(hl)
1357+  5EBA FE 2F           cp "/"
1358+  5EBC 20 03           jr nz,_BM_PRINT_CUR_DIR_TRUNC_PRINT
1359+  5EBE 23              inc hl
1360+  5EBF 18 F8           jr _BM_SKIP_LEADING_SLASH_2
1361+  5EC1             
1362+  5EC1             _BM_PRINT_CUR_DIR_TRUNC_PRINT:
1363+  5EC1 7E              ld a,(hl)
1364+  5EC2 B7              or a
1365+  5EC3 28 03           jr z,_BM_PRINT_CUR_DIR_END  ; If empty, done (just "/.../")
1366+  5EC5             
1367+  5EC5 CD B5 45        call PRINT
1368+  5EC8             
1369+  5EC8             _BM_PRINT_CUR_DIR_END:
1370+  5EC8 3E 1B           ld a,27
1371+  5ECA CD A2 00        call CHPUT
1372+  5ECD 3E 4B           ld a,'K'
1373+  5ECF C3 A2 00        jp CHPUT  ;Delete to end of line
1374+  5ED2             
1375+  5ED2             
1376+  5ED2             ;--- Get pointer to the last part of the current directory name
1377+  5ED2             ;    (assuming current dir is not root)
1378+  5ED2             
1379+  5ED2             BM_GET_LAST_DIR_PNT:
1380+  5ED2 CD 48 60        call BM_GET_CUR_DIR_ADD
1381+  5ED5 FD 5E 4E        ld e,(iy+BM_CUR_DIR_LENGTH)
1382+  5ED8 16 00           ld d,0
1383+  5EDA 19              add hl,de
1384+  5EDB             _BM_GET_LAST_DIR_PNT_LOOP:
1385+  5EDB 2B              dec hl
1386+  5EDC 7E              ld a,(hl)
1387+  5EDD FE 2F           cp "/"
1388+  5EDF 20 FA           jr nz,_BM_GET_LAST_DIR_PNT_LOOP
1389+  5EE1             
1390+  5EE1 23              inc hl
1391+  5EE2 C9              ret
1392+  5EE3             
1393+  5EE3             
1394+  5EE3             ; -----------------------------------------------------------------------------
1395+  5EE3             ; Keyboard scanning routines
1396+  5EE3             ; -----------------------------------------------------------------------------
1397+  5EE3             
1398+  5EE3             ;--- Check if a key is pressed
1399+  5EE3             ;    Input:  D = Keyboard matrix column mask, desired key set to 1
1400+  5EE3             ;            E = Keyboard matrix row number
1401+  5EE3             ;    Output: Z if key is pressed, NZ if not
1402+  5EE3             
1403+  5EE3             BM_KEY_CHECK:
1404+  5EE3 CD EE 5E        call BM_KEY_CHECK_CORE
1405+  5EE6 C0              ret nz
1406+  5EE7             
1407+  5EE7             _BM_KEY_CHECK_WAIT_RELEASE:
1408+  5EE7 76              halt
1409+  5EE8 7E              ld a,(hl)
1410+  5EE9 A0              and b
1411+  5EEA 28 FB           jr z,_BM_KEY_CHECK_WAIT_RELEASE
1412+  5EEC AF              xor a
1413+  5EED C9              ret
1414+  5EEE             
1415+  5EEE                 ;This version doesn't wait for key release
1416+  5EEE             
1417+  5EEE             BM_KEY_CHECK_CORE:
1418+  5EEE 42              ld b,d
1419+  5EEF 16 00           ld d,0
1420+  5EF1 21 E5 FB        ld hl,NEWKEY
1421+  5EF4 19              add hl,de
1422+  5EF5 7E              ld a,(hl)
1423+  5EF6 A0              and b
1424+  5EF7 C9              ret
1425+  5EF8             
1426+  5EF8             
1427+  5EF8             ;--- Check if F1 is pressed
1428+  5EF8             ;    Output: Z if pressed, NZ if not
1429+  5EF8             
1430+  5EF8             BM_F1_IS_PRESSED:
1431+  5EF8 11 06 20        ld de,2006h
1432+  5EFB C3 E3 5E        jp BM_KEY_CHECK
1433+  5EFE             
1434+  5EFE             
1435+  5EFE             ;--- Check if F2 is pressed
1436+  5EFE             ;    Output: Z if pressed, NZ if not
1437+  5EFE             
1438+  5EFE             BM_F2_IS_PRESSED:
1439+  5EFE 11 06 40        ld de,4006h
1440+  5F01 C3 E3 5E        jp BM_KEY_CHECK
1441+  5F04             
1442+  5F04             
1443+  5F04             ;--- Check if F5 is pressed
1444+  5F04             ;    Output: Z if pressed, NZ if not
1445+  5F04             
1446+  5F04             BM_F5_IS_PRESSED:
1447+  5F04 11 07 02        ld de,0207h
1448+  5F07 C3 E3 5E        jp BM_KEY_CHECK
1449+  5F0A             
1450+  5F0A             
1451+  5F0A             ;--- Check if ENTER is pressed
1452+  5F0A             ;    Output: Z if pressed, NZ if not
1453+  5F0A             
1454+  5F0A             BM_ENTER_IS_PRESSED:
1455+  5F0A 11 07 80        ld de,8007h
1456+  5F0D C3 E3 5E        jp BM_KEY_CHECK
1457+  5F10 C0              ret nz
1458+  5F11             
1459+  5F11             _BM_ENTER_IS_PRESSED_WAIT_RELEASE:
1460+  5F11 11 07 80        ld de,8007h
1461+  5F14 CD E3 5E        call BM_KEY_CHECK
1462+  5F17 28 F8           jr z,_BM_ENTER_IS_PRESSED_WAIT_RELEASE
1463+  5F19 AF              xor a
1464+  5F1A C9              ret
1465+  5F1B             
1466+  5F1B             
1467+  5F1B             ;--- Check if BS is pressed
1468+  5F1B             ;    Output: Z if pressed, NZ if not
1469+  5F1B             
1470+  5F1B             BM_BS_IS_PRESSED:
1471+  5F1B 11 07 20        ld de,2007h
1472+  5F1E C3 E3 5E        jp BM_KEY_CHECK
1473+  5F21 C0              ret nz
1474+  5F22             
1475+  5F22             _BM_BS_IS_PRESSED_WAIT_RELEASE:
1476+  5F22 11 07 20        ld de,2007h
1477+  5F25 CD E3 5E        call BM_KEY_CHECK
1478+  5F28 28 F8           jr z,_BM_BS_IS_PRESSED_WAIT_RELEASE
1479+  5F2A AF              xor a
1480+  5F2B C9              ret
1481+  5F2C             
1482+  5F2C             
1483+  5F2C             ;--- Check if a cursor key is pressed
1484+  5F2C             ;    Output: A=0: no cursor key is pressed
1485+  5F2C             ;              1,2,3,4: up,right,down,left
1486+  5F2C             ;            Bit 7 set if SHIFT is pressed too
1487+  5F2C             
1488+  5F2C             BM_CURSOR_IS_PRESSED:
1489+  5F2C 21 E5 FB        ld hl,NEWKEY
1490+  5F2F 11 08 00        ld de,8
1491+  5F32 19              add hl,de
1492+  5F33 7E              ld a,(hl)
1493+  5F34             
1494+  5F34 07              rlca
1495+  5F35 06 02           ld b,2
1496+  5F37 30 14           jr nc,_BM_CURSOR_IS_PRESSED_GO
1497+  5F39 07              rlca
1498+  5F3A 06 03           ld b,3
1499+  5F3C 30 0F           jr nc,_BM_CURSOR_IS_PRESSED_GO
1500+  5F3E 07              rlca
1501+  5F3F 06 01           ld b,1
1502+  5F41 30 0A           jr nc,_BM_CURSOR_IS_PRESSED_GO
1503+  5F43 07              rlca
1504+  5F44 06 04           ld b,4
1505+  5F46 30 05           jr nc,_BM_CURSOR_IS_PRESSED_GO
1506+  5F48             
1507+  5F48 AF              xor a
1508+  5F49 FD 77 0A        ld (iy+BM_CURSOR_DELAY),a
1509+  5F4C C9              ret
1510+  5F4D             
1511+  5F4D             _BM_CURSOR_IS_PRESSED_GO:
1512+  5F4D                 ;* Not previously pressed: return key, init delay counter
1513+  5F4D             
1514+  5F4D FD 7E 0A        ld a,(iy+BM_CURSOR_DELAY)
1515+  5F50 B7              or a
1516+  5F51 20 06           jr nz,_BM_CURSOR_IS_PRESSED_GO_2
1517+  5F53             
1518+  5F53 3C              inc a
1519+  5F54 FD 77 0A        ld (iy+BM_CURSOR_DELAY),a
1520+  5F57 18 20           jr _BM_CURSOR_IS_PRESSED_END
1521+  5F59             _BM_CURSOR_IS_PRESSED_GO_2:
1522+  5F59             
1523+  5F59                 ;* Bit 7 is set: we are already repeating
1524+  5F59             
1525+  5F59 CB 7F           bit 7,a
1526+  5F5B 28 0B           jr z,_BM_CURSOR_IS_PRESSED_GO_3
1527+  5F5D             
1528+  5F5D FE 83           cp 3+128    ;3 cycles passed since last repeat?
1529+  5F5F 38 12           jr c,_BM_CURSOR_IS_PRESSED_INC_DELAY
1530+  5F61             
1531+  5F61 3E 80           ld a,128
1532+  5F63 FD 77 0A        ld (iy+BM_CURSOR_DELAY),a
1533+  5F66 18 11           jr _BM_CURSOR_IS_PRESSED_END
1534+  5F68             _BM_CURSOR_IS_PRESSED_GO_3:
1535+  5F68             
1536+  5F68                 ;* Bit 7 is reset: we are waiting for the first repetition
1537+  5F68             
1538+  5F68 FE 28           cp 40   ;40 cycles passed since pressing?
1539+  5F6A 38 07           jr c,_BM_CURSOR_IS_PRESSED_INC_DELAY
1540+  5F6C             
1541+  5F6C CB FF           set 7,a
1542+  5F6E FD 77 0A        ld (iy+BM_CURSOR_DELAY),a
1543+  5F71 AF              xor a
1544+  5F72 C9              ret
1545+  5F73             
1546+  5F73             _BM_CURSOR_IS_PRESSED_INC_DELAY:
1547+  5F73 3C              inc a
1548+  5F74 FD 77 0A        ld (iy+BM_CURSOR_DELAY),a
1549+  5F77 AF              xor a
1550+  5F78 C9              ret
1551+  5F79             
1552+  5F79                 ;* Check for SHIFT and return, input: B = Pressed key
1553+  5F79             
1554+  5F79             _BM_CURSOR_IS_PRESSED_END:
1555+  5F79 2B              dec hl
1556+  5F7A 2B              dec hl  ;Row 6 (for SHIFT)
1557+  5F7B 7E              ld a,(hl)
1558+  5F7C 2F              cpl
1559+  5F7D 0F              rrca
1560+  5F7E E6 80           and 80h
1561+  5F80 B0              or b
1562+  5F81 C9              ret
1563+  5F82             
1564+  5F82             
1565+  5F82             ; -----------------------------------------------------------------------------
1566+  5F82             ; Utility routines
1567+  5F82             ; -----------------------------------------------------------------------------
1568+  5F82             
1569+  5F82             
1570+  5F82             ;--- Update BM_CUR_PAGE_PNT as:
1571+  5F82             ;    Base for filenames (STREND) + ((BM_CUR_PAGE-1)*60)*11
1572+  5F82             
1573+  5F82             BM_UPDATE_CUR_PAGE_PNT:
1574+  5F82 FD 6E 01        ld l,(iy+BM_CUR_PAGE)
1575+  5F85 26 00           ld h,0
1576+  5F87 2D              dec l
1577+  5F88 CD E2 5F        call BM_MULT_60
1578+  5F8B CD B9 5F        call BM_MULT_11
1579+  5F8E ED 5B C6 F6     ld de,(STREND)
1580+  5F92 19              add hl,de
1581+  5F93 FD 75 04        ld (iy+BM_CUR_PAGE_PNT),l
1582+  5F96 FD 74 05        ld (iy+BM_CUR_PAGE_PNT+1),h
1583+  5F99 C9              ret
1584+  5F9A             
1585+  5F9A             
1586+  5F9A             ;--- Update BM_CUR_FILE_PNT as:
1587+  5F9A             ;    BM_CUR_PAGE_PNT + ((BM_CUR_COL*20) + BM_CUR_ROW)*11
1588+  5F9A             
1589+  5F9A             BM_UPDATE_CUR_FILE_PNT:
1590+  5F9A FD 6E 09        ld l,(iy+BM_CUR_COL)
1591+  5F9D 26 00           ld h,0
1592+  5F9F CD CB 5F        call BM_MULT_20
1593+  5FA2 FD 5E 08        ld e,(iy+BM_CUR_ROW)
1594+  5FA5 16 00           ld d,0
1595+  5FA7 19              add hl,de
1596+  5FA8 CD B9 5F        call BM_MULT_11
1597+  5FAB FD 5E 04        ld e,(iy+BM_CUR_PAGE_PNT)
1598+  5FAE FD 56 05        ld d,(iy+BM_CUR_PAGE_PNT+1)
1599+  5FB1 19              add hl,de
1600+  5FB2 FD 75 06        ld (iy+BM_CUR_FILE_PNT),l
1601+  5FB5 FD 74 07        ld (iy+BM_CUR_FILE_PNT+1),h
1602+  5FB8 C9              ret
1603+  5FB9             
1604+  5FB9             
1605+  5FB9             ;--- Multiply HL by 11
1606+  5FB9             
1607+  5FB9             BM_MULT_11:
1608+  5FB9 E5              push hl
1609+  5FBA D1              pop de
1610+  5FBB CB 25           sla l
1611+  5FBD CB 14           rl h    ;*2
1612+  5FBF CB 25           sla l
1613+  5FC1 CB 14           rl h    ;*4
1614+  5FC3 CB 25           sla l
1615+  5FC5 CB 14           rl h    ;*8
1616+  5FC7 19              add hl,de   ;*9
1617+  5FC8 19              add hl,de   ;*10
1618+  5FC9 19              add hl,de   ;*11
1619+  5FCA C9              ret
1620+  5FCB             
1621+  5FCB             
1622+  5FCB             ;--- Multiply HL by 20
1623+  5FCB             
1624+  5FCB             BM_MULT_20:
1625+  5FCB E5              push hl
1626+  5FCC D1              pop de
1627+  5FCD CB 25           sla l
1628+  5FCF CB 14           rl h    ;*2
1629+  5FD1 CB 25           sla l
1630+  5FD3 CB 14           rl h    ;*4
1631+  5FD5 CB 25           sla l
1632+  5FD7 CB 14           rl h    ;*8
1633+  5FD9 CB 25           sla l
1634+  5FDB CB 14           rl h    ;*16
1635+  5FDD 19              add hl,de   ;*17
1636+  5FDE 19              add hl,de   ;*18
1637+  5FDF 19              add hl,de   ;*19
1638+  5FE0 19              add hl,de   ;*20
1639+  5FE1 C9              ret
1640+  5FE2             
1641+  5FE2             
1642+  5FE2             ;--- Multiply HL by 60
1643+  5FE2             
1644+  5FE2             BM_MULT_60:
1645+  5FE2 E5              push hl
1646+  5FE3 D1              pop de
1647+  5FE4 CB 25           sla l
1648+  5FE6 CB 14           rl h    ;*2
1649+  5FE8 CB 25           sla l
1650+  5FEA CB 14           rl h    ;*4
1651+  5FEC CB 25           sla l
1652+  5FEE CB 14           rl h    ;*8
1653+  5FF0 CB 25           sla l
1654+  5FF2 CB 14           rl h    ;*16
1655+  5FF4 CB 25           sla l
1656+  5FF6 CB 14           rl h    ;*32
1657+  5FF8 06 1C           ld b,60-32
1658+  5FFA             _BM_MULT_60_LOOP:
1659+  5FFA 19              add hl,de
1660+  5FFB 10 FD           djnz _BM_MULT_60_LOOP
1661+  5FFD C9              ret
1662+  5FFE             
1663+  5FFE             
1664+  5FFE             ;--- Calculate length of zero-terminated string
1665+  5FFE             ;    Input:  HL = String
1666+  5FFE             ;    Output: B  = Length
1667+  5FFE             ;            HL points to the zero
1668+  5FFE             
1669+  5FFE             BM_STRLEN:
1670+  5FFE 0E 00           ld c,0
1671+  6000             BM_STRLEN_C:
1672+  6000 06 00           ld b,0
1673+  6002             _BM_STRLEN_LOOP:
1674+  6002 7E              ld a,(hl)
1675+  6003 B9              cp c
1676+  6004 C8              ret z
1677+  6005 23              inc hl
1678+  6006 04              inc b
1679+  6007 18 F9           jr _BM_STRLEN_LOOP
1680+  6009             
1681+  6009             
1682+  6009             ;--- Backup current screen mode
1683+  6009             
1684+  6009             BM_SCREEN_BAK:
1685+  6009 3A AF FC        ld a,(SCRMOD)
1686+  600C FD 77 51        ld (iy+BM_SCRMOD_BAK),a
1687+  600F 3A B0 F3        ld a,(LINLEN)
1688+  6012 FD 77 52        ld (iy+BM_LINLEN_BAK),a
1689+  6015 3A DE F3        ld a,(CNSDFG)
1690+  6018 FD 77 53        ld (iy+BM_FNK_BAK),a
1691+  601B C9              ret
1692+  601C             
1693+  601C             
1694+  601C             ;--- Restore previous screen mode
1695+  601C             
1696+  601C             BM_SCREEN_REST:
1697+  601C FD 7E 51        ld a,(iy+BM_SCRMOD_BAK)
1698+  601F 3D              dec a
1699+  6020 28 0B           jr z,_BM_SCREEN_REST_W32
1700+  6022             
1701+  6022                 ; Restore SCREEN 0
1702+  6022             
1703+  6022             _BM_SCREEN_REST_W40:
1704+  6022 FD 7E 52        ld a,(iy+BM_LINLEN_BAK)
1705+  6025 32 AE F3        ld (LINL40),a
1706+  6028 CD 6C 00        call INITXT
1707+  602B 18 09           jr _BM_SCREEN_REST_OK
1708+  602D             
1709+  602D                 ; Restore SCREEN 1
1710+  602D             
1711+  602D             _BM_SCREEN_REST_W32:
1712+  602D FD 7E 52        ld a,(iy+BM_LINLEN_BAK)
1713+  6030 32 AF F3        ld (LINL32),a
1714+  6033 CD 6F 00        call INIT32
1715+  6036             
1716+  6036                 ; Restore function keys
1717+  6036             
1718+  6036             _BM_SCREEN_REST_OK:
1719+  6036 FD 7E 53        ld a,(iy+BM_FNK_BAK)
1720+  6039 B7              or a
1721+  603A C4 CF 00        call nz,DSPFNK
1722+  603D             
1723+  603D C9              ret
1724+  603E             
1725+  603E             
1726+  603E             ;--- Get the address of BM_BUF in HL
1727+  603E             
1728+  603E             BM_GET_BUF_ADD:
1729+  603E C5              push bc
1730+  603F FD E5           push iy
1731+  6041 E1              pop hl
1732+  6042 01 57 00        ld bc,BM_BUF
1733+  6045 09              add hl,bc
1734+  6046 C1              pop bc
1735+  6047 C9              ret
1736+  6048             
1737+  6048             
1738+  6048             ;--- Get the address of BM_CUR_DIR in HL
1739+  6048             
1740+  6048             BM_GET_CUR_DIR_ADD:
1741+  6048 C5              push bc
1742+  6049 FD E5           push iy
1743+  604B E1              pop hl
1744+  604C 01 0D 00        ld bc,BM_CUR_DIR
1745+  604F 09              add hl,bc
1746+  6050 C1              pop bc
1747+  6051 C9              ret
1748+  6052             
1749+  6052             
1750+  6052             ;--- Adjust variables after BM_CUR_DIR has changed
1751+  6052             
1752+  6052             BM_ADJUST_DIR_VARS:
1753+  6052 CD 48 60        call BM_GET_CUR_DIR_ADD
1754+  6055 E5              push hl
1755+  6056 CD FE 5F        call BM_STRLEN
1756+  6059 E1              pop hl
1757+  605A FD 70 4E        ld (iy+BM_CUR_DIR_LENGTH),b
1758+  605D             
1759+  605D 06 00           ld b,0
1760+  605F 7E              ld a,(hl)
1761+  6060 B7              or a
1762+  6061 28 0D           jr z,_BM_CALC_DIR_LEVEL_END
1763+  6063 04              inc b   ;Non-empty dir: start at level 1, each "/" increases level
1764+  6064             _BM_CALC_DIR_LEVEL:
1765+  6064 7E              ld a,(hl)
1766+  6065 23              inc hl
1767+  6066 B7              or a
1768+  6067 28 07           jr z,_BM_CALC_DIR_LEVEL_END
1769+  6069 FE 2F           cp "/"
1770+  606B 20 F7           jr nz,_BM_CALC_DIR_LEVEL
1771+  606D 04              inc b
1772+  606E 18 F4           jr _BM_CALC_DIR_LEVEL
1773+  6070             _BM_CALC_DIR_LEVEL_END:
1774+  6070 FD 70 0C        ld (iy+BM_CUR_DIR_LEVEL),b
1775+  6073             
1776+  6073 C9              ret
1777+  6074             
1778+  6074             
1779+  6074             ;--- Try opening the initial directory
1780+  6074             ;    Output: A = 0 if ok, 1 if error
1781+  6074             
1782+  6074             BM_OPEN_INITIAL_DIR:
1783+  6074                 if USE_FAKE_STORAGE_DEVICE = 0
1784+  6074             
1785+  6074 CD 48 60        call BM_GET_CUR_DIR_ADD
1786+  6077 CD 1A 6A        call DSK_GET_CURDIR
1787+  607A B7              or a
1788+  607B 20 05           jr nz,_BM_MAIN_GETDIR_ERR
1789+  607D CD 52 60        call BM_ADJUST_DIR_VARS
1790+  6080 AF              xor a
1791+  6081 C9              ret
1792+  6082             
1793+  6082             _BM_MAIN_GETDIR_ERR
1794+  6082 21 82 61        ld hl,BM_ERROR_INITIAL_S
1795+  6085 CD 98 59        call BM_PRINT_STATUS_WAIT_KEY
1796+  6088 3E 01           ld a,1
1797+  608A C9              ret
1798+  608B             
1799+  608B                 else
1800+  608B~            
1801+  608B~                xor a
1802+  608B~                ret
1803+  608B~            
1804+  608B                 endif
1805+  608B             
1806+  608B             ; -----------------------------------------------------------------------------
1807+  608B             ; Text strings
1808+  608B             ; -----------------------------------------------------------------------------
1809+  608B             
1810+  608B             ;--- Strings
1811+  608B             
1812+  608B             BM_F1_HELP:
1813+  608B                 db "F1 = Help  F2 = Config",0
1813+  608B 4631203D2048656C7020204632203D20436F6E66696700
1814+  60A2             
1815+  60A2             BM_F1_NEXT:
1816+  60A2                 db "F1 = Next",0
1816+  60A2 4631203D204E65787400
1817+  60AC             
1818+  60AC             BM_F1_END:
1819+  60AC                 db "F1 = End",0
1819+  60AC 4631203D20456E6400
1820+  60B5             
1821+  60B5             BM_PAGE_S:
1822+  60B5                 db "Page ",0
1822+  60B5 506167652000
1823+  60BB             
1824+  60BB             BM_SPACE_AND_BAR:
1825+  60BB 20 2F 20 00     db " / ",0
1826+  60BF             
1827+  60BF             BM_ROOT_DIR_S:
1828+  60BF 2F 00           db "/",0
1829+  60C1             
1830+  60C1             BM_DSK_S:
1831+  60C1 2F44534B00      db "/DSK",0
1832+  60C6             
1833+  60C6             BM_NO_FILES_S:
1834+  60C6                 db "No files found in current directory!",0
1834+  60C6 4E6F2066696C657320666F756E6420696E2063757272656E7420646972656374
1834+  60E6 6F72792100
1835+  60EB             
1836+  60EB             BM_SCANNING_DIR_S:
1837+  60EB                 db "Scanning directory...",0
1837+  60EB 5363616E6E696E67206469726563746F72792E2E2E00
1838+  6101             
1839+  6101             BM_RESETTING_DEVICE_S:
1840+  6101                 db "Resetting device...",0
1840+  6101 526573657474696E67206465766963652E2E2E00
1841+  6115             
1842+  6115             BM_NO_DEV_OR_NO_STOR_S:
1843+  6115                 db "No storage device found! F5 to retry",0
1843+  6115 4E6F2073746F726167652064657669636520666F756E642120463520746F2072
1843+  6135 6574727900
1844+  613A             
1845+  613A             BM_FILE_NOT_FOUND_S:
1846+  613A                 db "File/dir not found! Press any key",0
1846+  613A 46696C652F646972206E6F7420666F756E642120507265737320616E79206B65
1846+  615A 7900
1847+  615C             
1848+  615C             BM_ERROR_OPENING_FILE_S:
1849+  615C                 db "Error opening file/dir! Press any key",0
1849+  615C 4572726F72206F70656E696E672066696C652F6469722120507265737320616E
1849+  617C 79206B657900
1850+  6182             
1851+  6182             BM_ERROR_INITIAL_S:
1852+  6182                 db "Error entering initial dir! Press any key",0
1852+  6182 4572726F7220656E746572696E6720696E697469616C20646972212050726573
1852+  61A2 7320616E79206B657900
1853+  61AC             
1854+  61AC             BM_MOUNTING_BOOTING_S:
1855+  61AC                 db "Mounting file...",0
1855+  61AC 4D6F756E74696E672066696C652E2E2E00
1856+  61BD             
1857+  61BD             BM_ENTERING_DIR_S:
1858+  61BD                 db "Entering directory...",0
1858+  61BD 456E746572696E67206469726563746F72792E2E2E00
1859+  61D3             
1860+  61D3             BM_CHANGING_EXITING_S:
1861+  61D3                 db "Changing current dir and exiting...",0
1861+  61D3 4368616E67696E672063757272656E742064697220616E642065786974696E67
1861+  61F3 2E2E2E00
1862+  61F7             
1863+  61F7             BM_MOUNTING_DEF_S:
1864+  61F7                 db "Mounting default file for dir...",0
1864+  61F7 4D6F756E74696E672064656661756C742066696C6520666F72206469722E2E2E
1864+  6217 00
1865+  6218             
1866+  6218             BM_ERR_RETRIEVING_DEFAULT_S:
1867+  6218                 db "Error retrieving default file for dir!",0
1867+  6218 4572726F722072657472696576696E672064656661756C742066696C6520666F
1867+  6238 72206469722100
1868+  623F             
1869+  623F             BM_ERR_CREATING_TEMP_FILE_S:
1870+  623F                 db "Error creating temp file! Press any key",0
1870+  623F 4572726F72206372656174696E672074656D702066696C652120507265737320
1870+  625F 616E79206B657900
1871+  6267             
1872+  6267             BM_RESETTING_S:
1873+  6267                 db "Resetting computer...",0
1873+  6267 526573657474696E6720636F6D70757465722E2E2E00
1874+  627D             
1875+  627D             BM_DOTS_BAR_S:
1876+  627D 2E2E2E2F00      db ".../",0
1877+  6282             
1878+  6282             BM_DOTDOT_S:
1879+  6282 2E 2E 00        db "..",0
1880+  6285             
1881+  6285             BM_HELP_1:
1882+  6285                 db " Cursors: select file or directory",13,10
1882+  6285 20437572736F72733A2073656C6563742066696C65206F72206469726563746F
1882+  62A5 72790D0A
1883+  62A9 0D 0A           db 13,10
1884+  62AB                 db " SHIFT+Right/Left: Next/prev page",13,10
1884+  62AB 2053484946542B52696768742F4C6566743A204E6578742F7072657620706167
1884+  62CB 650D0A
1885+  62CE 0D 0A           db 13,10
1886+  62D0                 db " SHIFT+Up/Down: Up/down 10 pages",13,10
1886+  62D0 2053484946542B55702F446F776E3A2055702F646F776E203130207061676573
1886+  62F0 0D0A
1887+  62F2 0D 0A           db 13,10
1888+  62F4                 db " Enter (on file): Mount file and exit",13,10
1888+  62F4 20456E74657220286F6E2066696C65293A204D6F756E742066696C6520616E64
1888+  6314 20657869740D0A
1889+  631B 0D 0A           db 13,10
1890+  631D                 db " Enter (on dir): Enter directory",13,10
1890+  631D 20456E74657220286F6E20646972293A20456E746572206469726563746F7279
1890+  633D 0D0A
1891+  633F 0D 0A           db 13,10
1892+  6341                 db " SHIFT+Enter (on dir):",13,10
1892+  6341 2053484946542B456E74657220286F6E20646972293A0D0A
1893+  6359                 db "   Mount default file on dir and exit",13,10
1893+  6359 2020204D6F756E742064656661756C742066696C65206F6E2064697220616E64
1893+  6379 20657869740D0A
1894+  6380 0D 0A           db 13,10
1895+  6382                 db " CTRL+Enter: Mount and reset",13,10
1895+  6382 204354524C2B456E7465723A204D6F756E7420616E642072657365740D0A
1896+  63A0 0D 0A           db 13,10
1897+  63A2                 db " BS: Back to parent directory",13,10
1897+  63A2 2042533A204261636B20746F20706172656E74206469726563746F72790D0A
1898+  63C1 0D 0A           db 13,10
1899+  63C3                 db " F5: Reset device and start over",13,10
1899+  63C3 2046353A2052657365742064657669636520616E64207374617274206F766572
1899+  63E3 0D0A
1900+  63E5 0D 0A           db 13,10
1901+  63E7             
1902+  63E7 00              db 0
1903+  63E8             
1904+  63E8             BM_HELP_2:
1905+  63E8                 db " ESC: Exit without mounting",13,10
1905+  63E8 204553433A204578697420776974686F7574206D6F756E74696E670D0A
1906+  6405 0D 0A           db 13,10
1907+  6407                 db " SHIFT+ESC: Set current dir and",13,10
1907+  6407 2053484946542B4553433A205365742063757272656E742064697220616E640D
1907+  6427 0A
1908+  6428                 db "   exit without mounting",13,10
1908+  6428 2020206578697420776974686F7574206D6F756E74696E670D0A
1909+  6442 0D 0A           db 13,10
1910+  6444                 db " TAB (while booting):",13,10
1910+  6444 2054414220287768696C6520626F6F74696E67293A0D0A
1911+  645B                 db "   temporarily force boot mode 1",13,10
1911+  645B 20202074656D706F726172696C7920666F72636520626F6F74206D6F64652031
1911+  647B 0D0A
1912+  647D 0D 0A           db 13,10
1913+  647F                 db " CALL USBHELP / _USBHELP (in BASIC):",13,10
1913+  647F 2043414C4C2055534248454C50202F205F55534248454C502028696E20424153
1913+  649F 4943293A0D0A
1914+  64A5                 db "   show list of available CALL commands",13,10
1914+  64A5 20202073686F77206C697374206F6620617661696C61626C652043414C4C2063
1914+  64C5 6F6D6D616E64730D0A
1915+  64CE 0D 0A           db 13,10
1916+  64D0                 db " After boot it is possible to switch",13,10
1916+  64D0 20416674657220626F6F7420697420697320706F737369626C6520746F207377
1916+  64F0 697463680D0A
1917+  64F6                 db " to another disk image file from the",13,10
1917+  64F6 20746F20616E6F74686572206469736B20696D6167652066696C652066726F6D
1917+  6516 207468650D0A
1918+  651C                 db " same directory (up to 35 files).",13,10
1918+  651C 2073616D65206469726563746F72792028757020746F2033352066696C657329
1918+  653C 2E0D0A
1919+  653F 0D 0A           db 13,10
1920+  6541                 db " On disk access press the key for the",13,10
1920+  6541 204F6E206469736B2061636365737320707265737320746865206B657920666F
1920+  6561 72207468650D0A
1921+  6568                 db " file (1-9, A-Z), or press CODE/KANA",13,10
1921+  6568 2066696C652028312D392C20412D5A292C206F7220707265737320434F44452F
1921+  6588 4B414E410D0A
1922+  658E                 db " and when CAPS lits press the key."
1922+  658E 20616E64207768656E2043415053206C69747320707265737320746865206B65
1922+  65AE 792E
1923+  65B0 00              db 0
1924+  65B1             
1925+  65B1             BM_CONFIG_BOOTDIR_S:
1926+  65B1                 db "Boot dir: /",0
1926+  65B1 426F6F74206469723A202F00
1927+  65BD             BM_CONFIG_DEFFILE_S:
1928+  65BD                 db "Default file in this dir: ",0
1928+  65BD 44656661756C742066696C6520696E2074686973206469723A2000
1929+  65D8             BM_CONFIG_BOOTMODE_S:
1930+  65D8                 db "Boot mode: ",0
1930+  65D8 426F6F74206D6F64653A2000
1931+  65E4             BM_CONFIG_TEXT_S:
1932+  65E4                 db ", to change press:",13,10
1932+  65E4 2C20746F206368616E67652070726573733A0D0A
1933+  65F8                 db "  1: Show menu",13,10
1933+  65F8 2020313A2053686F77206D656E750D0A
1934+  6608                 db "  2: Don't show menu, don't mount",13,10
1934+  6608 2020323A20446F6E27742073686F77206D656E752C20646F6E2774206D6F756E
1934+  6628 740D0A
1935+  662B                 db "  3: Mount default file in boot dir",13,10
1935+  662B 2020333A204D6F756E742064656661756C742066696C6520696E20626F6F7420
1935+  664B 6469720D0A
1936+  6650                 db "  4: Mount last mounted file",13,10
1936+  6650 2020343A204D6F756E74206C617374206D6F756E7465642066696C650D0A
1937+  666E 0D 0A           db 13,10
1938+  6670                 db "5: Set current dir as boot dir",13,10
1938+  6670 353A205365742063757272656E742064697220617320626F6F74206469720D0A
1939+  6690 0D 0A           db 13,10
1940+  6692 00              db 0
1941+  6693             BM_CONFIG_SET_DEF_S:
1942+  6693                 db "6: Set ",0
1942+  6693 363A205365742000
1943+  669B             BM_CONFIG_TEXT_2_S:
1944+  669B                 db " as default file",13,10
1944+  669B 2061732064656661756C742066696C650D0A
1945+  66AD                 db "   in this dir"
1945+  66AD 202020696E207468697320646972
1946+  66BB             BM_CONFIG_TWOCRLF_S:
1947+  66BB 0D 0A           db 13,10
1948+  66BD 0D 0A           db 13,10
1949+  66BF 00              db 0
1950+  66C0             BM_CONFIG_UNSET_DEF_S:
1951+  66C0                 db "7: Unset explicit default file",13,10
1951+  66C0 373A20556E736574206578706C696369742064656661756C742066696C650D0A
1952+  66E0                 db "   in this dir",0
1952+  66E0 202020696E20746869732064697200
1953+  66EF             BM_CONFIG_ENABLE_8_S:
1954+  66EF                 db "8: Enable",0
1954+  66EF 383A20456E61626C6500
1955+  66F9             BM_CONFIG_DISABLE_8_S:    
1956+  66F9                 db "8: Disable",0
1956+  66F9 383A2044697361626C6500
1957+  6704             BM_CONFIG_CAPS_LIT_S:
1958+  6704                 db " CAPS lit on file access",0
1958+  6704 2043415053206C6974206F6E2066696C652061636365737300
1959+  671D             BM_CONFIG_CHOOSE_S:
1960+  671D                 db "Choose an option, or 0 to exit: ",0
1960+  671D 43686F6F736520616E206F7074696F6E2C206F72203020746F20657869743A20
1960+  673D 00
1961+  673E             
1962+  673E             BM_CONFIG_ERROR_APPLYING_S:
1963+  673E                 db "Error applying change - Press key ",0
1963+  673E 4572726F72206170706C79696E67206368616E6765202D205072657373206B65
1963+  675E 792000
1964+  6761             
1965+  6761             BM_ERROR_S: db "(error)",0
1965+  6761 286572726F722900
1966+  6769             
1967+  6769             BM_UNSET_S: db "(not set)"
1967+  6769 286E6F742073657429
1968+  6772             
1969+  6772 00          BM_ZERO_S: db 0
1970+  6773             
1971+  6773             
1972+  6773             ; -----------------------------------------------------------------------------
1973+  6773             ; Variables
1974+  6773             ; -----------------------------------------------------------------------------
1975+  6773             
1976+  6773             BM_VARS_START: equ 0
1977+  6773             
1978+  6773             BM_NUM_PAGES: equ BM_VARS_START
1979+  6773             BM_CUR_PAGE:  equ BM_NUM_PAGES+1
1980+  6773             BM_NUM_FILES: equ BM_CUR_PAGE+1
1981+  6773             BM_CUR_PAGE_PNT: equ BM_NUM_FILES+2   ;Pointer to 1st filename in current page
1982+  6773             BM_CUR_FILE_PNT: equ BM_CUR_PAGE_PNT+2   ;Pointer to current filename
1983+  6773             BM_CUR_ROW: equ BM_CUR_FILE_PNT+2   ;Current logical row, 0-19
1984+  6773             BM_CUR_COL: equ BM_CUR_ROW+1   ;Current logical column, 0-2
1985+  6773             BM_CURSOR_DELAY: equ BM_CUR_COL+1    ;Counter to control control key repetition delays
1986+  6773             BM_NO_STOR_DEV: equ BM_CURSOR_DELAY+1 ;FFh if F5 was pressed and no storage device was found
1987+  6773             BM_CUR_DIR_LEVEL: equ BM_NO_STOR_DEV+1  ;Current direcrory level, 0 is root
1988+  6773             BM_CUR_DIR: equ BM_CUR_DIR_LEVEL+1  ;Current directory, up to BM_MAX_DIR_NAME_LENGTH chars + 0
1989+  6773             BM_CUR_DIR_LENGTH: equ BM_CUR_DIR+BM_MAX_DIR_NAME_LENGTH+1
1990+  6773             BM_MAX_FILES_TO_ENUM: equ BM_CUR_DIR_LENGTH+1
1991+  6773             BM_SCRMOD_BAK: equ BM_MAX_FILES_TO_ENUM+2
1992+  6773             BM_LINLEN_BAK: equ BM_SCRMOD_BAK+1
1993+  6773             BM_FNK_BAK: equ BM_LINLEN_BAK+1
1994+  6773             BM_TEMP: equ BM_FNK_BAK+1
1995+  6773             BM_WHERE_CALLED_FROM: equ BM_TEMP+2
1996+  6773             BM_BUF: equ BM_WHERE_CALLED_FROM+1
1997+  6773             
1998+  6773             BM_VARS_END: equ BM_BUF+64
1999+  6773             BM_VARS_LEN: equ BM_VARS_END-BM_VARS_START
0062   6773                 include "bank1/dsk.asm"
0001+  6773             ; MSXUSB USB FDD BIOS
0002+  6773             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003+  6773             ; This version is adapted to work with the latest version of the MSXUSB project
0004+  6773             ;
0005+  6773             ; This file contains the code for high-level management
0006+  6773             ; of disk image files, including creating and accessing
0007+  6773             ; configuration files when needed.
0008+  6773             
0009+  6773             
0010+  6773             ; -----------------------------------------------------------------------------
0011+  6773             ; DSK_OPEN_MAIN_DIR: Open the main directory
0012+  6773             ; -----------------------------------------------------------------------------
0013+  6773             ; Output: A = 0: Ok
0014+  6773             ;             1: Error
0015+  6773             ;         Z if ok, NZ if error
0016+  6773             ;         Cy = 0 if root directory was open, 1 if DSK_MAIN_DIR_S was open
0017+  6773             
0018+  6773             DSK_OPEN_MAIN_DIR:
0019+  6773 E5              push hl
0020+  6774 D5              push de
0021+  6775 C5              push bc
0022+  6776 CD 7D 67        call _DSK_OPEN_MAIN_DIR
0023+  6779 C1              pop bc
0024+  677A D1              pop de
0025+  677B E1              pop hl
0026+  677C C9              ret
0027+  677D             _DSK_OPEN_MAIN_DIR:
0028+  677D 21 99 67        ld hl,DSK_ROOT_DIR_S
0029+  6780 CD CA 41        call HWF_OPEN_FILE_DIR
0030+  6783 C0              ret nz
0031+  6784             
0032+  6784 21 9B 67        ld hl,DSK_MAIN_DIR_S
0033+  6787 CD CA 41        call HWF_OPEN_FILE_DIR
0034+  678A 20 02           jr nz,_DSK_OPEN_MAIN_REOPEN_ROOT
0035+  678C 38 08           jr c,_DSK_OPEN_MAIN_WAS_MSX
0036+  678E             
0037+  678E             _DSK_OPEN_MAIN_REOPEN_ROOT:
0038+  678E 21 99 67        ld hl,DSK_ROOT_DIR_S
0039+  6791 CD CA 41        call HWF_OPEN_FILE_DIR
0040+  6794             _DSK_OPEN_MAIN_END:
0041+  6794 B7              or a    ;If error, set NZ; if ok, set Z and NC
0042+  6795 C9              ret
0043+  6796             
0044+  6796             _DSK_OPEN_MAIN_WAS_MSX:
0045+  6796 AF              xor a
0046+  6797 37              scf
0047+  6798 C9              ret
0048+  6799             
0049+  6799             DSK_ROOT_DIR_S:
0050+  6799 2F 00           db "/",0
0051+  679B             
0052+  679B             DSK_MAIN_DIR_S:
0053+  679B 4D 53 58        db "MSX"
0054+  679E             DSK_ZERO_S:
0055+  679E 00              db 0
0056+  679F             
0057+  679F             
0058+  679F             ; -----------------------------------------------------------------------------
0059+  679F             ; DSK_READ_CONFIG_FILE: Read config file in current directory
0060+  679F             ;
0061+  679F             ; The file is read until B bytes have been read, the end of the file
0062+  679F             ; is reached, or a CR or LF character is found, whatever happens firts
0063+  679F             ; -----------------------------------------------------------------------------
0064+  679F             ; Input:  HL = File name
0065+  679F             ;         DE = Destination address
0066+  679F             ;         B  = Max amount of bytes to read
0067+  679F             ; Output: A  = 0: Ok
0068+  679F             ;              1: Other error
0069+  679F             ;              2: File not found
0070+  679F             ;         B  = Amount of bytes read if no error
0071+  679F             ;         DE = Pointer after last byte read
0072+  679F             
0073+  679F             DSK_READ_CONFIG_FILE:
0074+  679F E5              push hl
0075+  67A0 D5              push de
0076+  67A1 C5              push bc
0077+  67A2 21 E0 67        ld hl,DSK_CONFIG_DIR_S
0078+  67A5 CD CA 41        call HWF_OPEN_FILE_DIR
0079+  67A8 C1              pop bc
0080+  67A9 D1              pop de
0081+  67AA E1              pop hl
0082+  67AB C0              ret nz
0083+  67AC 3E 01           ld a,1
0084+  67AE D0              ret nc
0085+  67AF             
0086+  67AF D5              push de
0087+  67B0 C5              push bc
0088+  67B1 CD CA 41        call HWF_OPEN_FILE_DIR
0089+  67B4 C1              pop bc
0090+  67B5 D1              pop de
0091+  67B6 C0              ret nz
0092+  67B7 3E 01           ld a,1
0093+  67B9 D8              ret c
0094+  67BA             
0095+  67BA EB              ex de,hl
0096+  67BB 48              ld c,b
0097+  67BC 06 00           ld b,0
0098+  67BE E5              push hl
0099+  67BF CD 0A 43        call HWF_READ_FILE
0100+  67C2 EB              ex de,hl
0101+  67C3 E1              pop hl
0102+  67C4 06 00           ld b,0
0103+  67C6 B7              or a
0104+  67C7 C0              ret nz
0105+  67C8             
0106+  67C8                 ;Search for CR or LF
0107+  67C8             
0108+  67C8 79              ld a,c
0109+  67C9 B7              or a
0110+  67CA 28 10           jr z,_DSK_READ_CONFIG_FILE_END
0111+  67CC             
0112+  67CC 41              ld b,c
0113+  67CD 0E 00           ld c,0
0114+  67CF             _DSK_READ_CONFIG_FILE_LOOP:
0115+  67CF 7E              ld a,(hl)
0116+  67D0 FE 0D           cp 13
0117+  67D2 28 08           jr z,_DSK_READ_CONFIG_FILE_END
0118+  67D4 FE 0A           cp 10
0119+  67D6 28 04           jr z,_DSK_READ_CONFIG_FILE_END
0120+  67D8 23              inc hl
0121+  67D9 0C              inc c
0122+  67DA 10 F3           djnz _DSK_READ_CONFIG_FILE_LOOP
0123+  67DC             
0124+  67DC             _DSK_READ_CONFIG_FILE_END:
0125+  67DC EB              ex de,hl
0126+  67DD AF              xor a
0127+  67DE 41              ld b,c
0128+  67DF C9              ret
0129+  67E0             
0130+  67E0             DSK_CONFIG_DIR_S:
0131+  67E0 5F55534200      db "_USB",0
0132+  67E5             
0133+  67E5             
0134+  67E5             ; -----------------------------------------------------------------------------
0135+  67E5             ; DSK_READ_MAIN_CONFIG_FILE: Read config file in main directory
0136+  67E5             ; -----------------------------------------------------------------------------
0137+  67E5             ; Input:  HL = File name
0138+  67E5             ;         DE = Destination address
0139+  67E5             ;         B  = Max amount of bytes to read
0140+  67E5             ; Output: A  = 0: Ok
0141+  67E5             ;              1: Other error
0142+  67E5             ;              2: File not found
0143+  67E5             ;         B  = Amount of bytes read if no error, 0 on error
0144+  67E5             ;         DE = Pointer after last byte read
0145+  67E5             
0146+  67E5             DSK_READ_MAIN_CONFIG_FILE:
0147+  67E5 CD 73 67        call DSK_OPEN_MAIN_DIR
0148+  67E8 B7              or a
0149+  67E9 3E 01           ld a,1
0150+  67EB 48              ld c,b
0151+  67EC 06 00           ld b,0
0152+  67EE C0              ret nz
0153+  67EF 41              ld b,c
0154+  67F0             
0155+  67F0 CD 9F 67        call DSK_READ_CONFIG_FILE
0156+  67F3 B7              or a
0157+  67F4 C8              ret z
0158+  67F5 06 00           ld b,0
0159+  67F7 C9              ret
0160+  67F8             
0161+  67F8             
0162+  67F8             ; -----------------------------------------------------------------------------
0163+  67F8             ; DSK_WRITE_CONFIG_FILE: Write config file in current directory
0164+  67F8             ; -----------------------------------------------------------------------------
0165+  67F8             ; Input:  HL = File name
0166+  67F8             ;         DE = Source address
0167+  67F8             ;         B  = Amount of bytes to write, if 0 delete the file
0168+  67F8             ; Output: A  = 0: Ok
0169+  67F8             ;              1: Error
0170+  67F8             
0171+  67F8             DSK_WRITE_CONFIG_FILE:
0172+  67F8 E5              push hl
0173+  67F9 D5              push de
0174+  67FA C5              push bc
0175+  67FB 21 E0 67        ld hl,DSK_CONFIG_DIR_S
0176+  67FE CD 08 42        call HWF_CREATE_DIR
0177+  6801 C1              pop bc
0178+  6802 D1              pop de
0179+  6803 E1              pop hl
0180+  6804 B7              or a
0181+  6805 C0              ret nz
0182+  6806             
0183+  6806 78              ld a,b
0184+  6807 B7              or a
0185+  6808 20 05           jr nz,_DSK_WRITE_CONFIG_FILE_GO
0186+  680A             
0187+  680A CD 28 42        call HWF_DELETE_FILE
0188+  680D AF              xor a
0189+  680E C9              ret
0190+  680F             
0191+  680F             _DSK_WRITE_CONFIG_FILE_GO:
0192+  680F D5              push de
0193+  6810 C5              push bc
0194+  6811 CD F3 41        call HWF_CREATE_FILE
0195+  6814 C1              pop bc
0196+  6815 E1              pop hl
0197+  6816 B7              or a
0198+  6817 C0              ret nz
0199+  6818             
0200+  6818 48              ld c,b
0201+  6819 06 00           ld b,0
0202+  681B CD 37 43        call HWF_WRITE_FILE
0203+  681E             
0204+  681E F5              push af
0205+  681F CD 1D 42        call HWF_CLOSE_FILE
0206+  6822 F1              pop af
0207+  6823 C9              ret
0208+  6824             
0209+  6824             
0210+  6824             ; -----------------------------------------------------------------------------
0211+  6824             ; DSK_WRITE_MAIN_CONFIG_FILE: Write config file in main directory
0212+  6824             ; -----------------------------------------------------------------------------
0213+  6824             ; Input:  HL = File name
0214+  6824             ;         DE = Source address
0215+  6824             ;         B  = Amount of bytes to write
0216+  6824             ; Output: A  = 0: Ok
0217+  6824             ;              1: Error
0218+  6824             
0219+  6824             DSK_WRITE_MAIN_CONFIG_FILE:
0220+  6824 CD 73 67        call DSK_OPEN_MAIN_DIR
0221+  6827 B7              or a
0222+  6828 3E 01           ld a,1
0223+  682A C0              ret nz
0224+  682B             
0225+  682B C3 F8 67        jp DSK_WRITE_CONFIG_FILE
0226+  682E             
0227+  682E             
0228+  682E             ; -----------------------------------------------------------------------------
0229+  682E             ; DSK_WRITE_CURDIR_FILE: Write CURDIR config file in main directory
0230+  682E             ; -----------------------------------------------------------------------------
0231+  682E             ; Input:  HL = Address of content to write, zero-terminated
0232+  682E             ; Output: A  = 0: Ok
0233+  682E             ;              1: Error
0234+  682E             
0235+  682E             DSK_WRITE_CURDIR_FILE:
0236+  682E E5              push hl
0237+  682F CD FE 5F        call BM_STRLEN
0238+  6832 D1              pop de
0239+  6833 21 27 69        ld hl,DSK_CURDIR_S
0240+  6836 C3 24 68        jp DSK_WRITE_MAIN_CONFIG_FILE
0241+  6839             
0242+  6839             
0243+  6839             ; -----------------------------------------------------------------------------
0244+  6839             ; DSK_WRITE_BOOTDIR_FILE: Write BOOTDIR config file in main directory
0245+  6839             ; -----------------------------------------------------------------------------
0246+  6839             ; Input:  HL = Address of content to write, zero-terminated
0247+  6839             ; Output: A  = 0: Ok
0248+  6839             ;              1: Error
0249+  6839             
0250+  6839             DSK_WRITE_BOOTDIR_FILE:
0251+  6839 E5              push hl
0252+  683A CD FE 5F        call BM_STRLEN
0253+  683D D1              pop de
0254+  683E 21 B2 6B        ld hl,DSK_BOOTDIR_S
0255+  6841 C3 24 68        jp DSK_WRITE_MAIN_CONFIG_FILE
0256+  6844             
0257+  6844             
0258+  6844             ; -----------------------------------------------------------------------------
0259+  6844             ; DSK_WRITE_BOOTMODE_FILE: Write BOOTMODE config file in main directory
0260+  6844             ; -----------------------------------------------------------------------------
0261+  6844             ; Input:  A  = Value to write
0262+  6844             ; Output: A  = 0: Ok
0263+  6844             ;              1: Error
0264+  6844             
0265+  6844             DSK_WRITE_BOOTMODE_FILE:
0266+  6844 F5              push af
0267+  6845 21 01 00        ld hl,1
0268+  6848 39              add hl,sp
0269+  6849 EB              ex de,hl
0270+  684A 06 01           ld b,1
0271+  684C 21 33 6C        ld hl,DSK_BOOTMODE_S
0272+  684F CD 24 68        call DSK_WRITE_MAIN_CONFIG_FILE
0273+  6852 E1              pop hl
0274+  6853 C9              ret
0275+  6854             
0276+  6854             
0277+  6854             ; -----------------------------------------------------------------------------
0278+  6854             ; DSK_WRITE_DEFFILE_FILE: Write DEFFILE config file in current directory
0279+  6854             ; -----------------------------------------------------------------------------
0280+  6854             ; Input:  HL = Address of content to write, zero-terminated
0281+  6854             ; Output: A  = 0: Ok
0282+  6854             ;              1: Error
0283+  6854             
0284+  6854             DSK_WRITE_DEFFILE_FILE:
0285+  6854 E5              push hl
0286+  6855 CD FE 5F        call BM_STRLEN
0287+  6858 D1              pop de
0288+  6859 21 43 6B        ld hl,DSK_DEFFILE_S
0289+  685C C3 F8 67        jp DSK_WRITE_CONFIG_FILE
0290+  685F             
0291+  685F             
0292+  685F             ; -----------------------------------------------------------------------------
0293+  685F             ; DSK_READ_DEFFILE_FILE: Read DEFFILE config file from current directory
0294+  685F             ; -----------------------------------------------------------------------------
0295+  685F             ; Input:  HL = Address where to read the file
0296+  685F             ; Output: A  = 0: Ok
0297+  685F             ;              1: Other error
0298+  685F             ;              2: File not found
0299+  685F             
0300+  685F             DSK_READ_DEFFILE_FILE:
0301+  685F EB              ex de,hl
0302+  6860 21 43 6B        ld hl,DSK_DEFFILE_S
0303+  6863 06 0C           ld b,12
0304+  6865 CD 9F 67        call DSK_READ_CONFIG_FILE
0305+  6868 B7              or a
0306+  6869 C0              ret nz
0307+  686A 12              ld (de),a
0308+  686B C9              ret
0309+  686C                 
0310+  686C             
0311+  686C             ; -----------------------------------------------------------------------------
0312+  686C             ; DSK_CHANGE_DIR: Change the current directory
0313+  686C             ;                 (doesn't update config files or work area)
0314+  686C             ; -----------------------------------------------------------------------------
0315+  686C             ; Input:  HL = Directory path, "dir/dir2/dir3", no starting or ending "/"
0316+  686C             ;              (the root dir is represented as an empty string)
0317+  686C             ;         A  = 0 for relative to current, 1 for absolute
0318+  686C             ; Output: A  = 0: Ok
0319+  686C             ;              1: Other error
0320+  686C             ;              2: Directory not found
0321+  686C             ;              3: It's a file, not a directory
0322+  686C             
0323+  686C             DSK_CHANGE_DIR:
0324+  686C B7              or a
0325+  686D 28 0C           jr z,_DSK_CHANGE_DIR_REL
0326+  686F             
0327+  686F E5              push hl
0328+  6870 21 99 67        ld hl,DSK_ROOT_DIR_S
0329+  6873 CD CA 41        call HWF_OPEN_FILE_DIR
0330+  6876 E1              pop hl
0331+  6877 C0              ret nz
0332+  6878             
0333+  6878 7E              ld a,(hl)
0334+  6879 B7              or a
0335+  687A C8              ret z   ;Empty string = root dir, so we're done
0336+  687B             _DSK_CHANGE_DIR_REL:
0337+  687B             
0338+  687B             _DSK_CHANGE_LOOP:
0339+  687B CD CA 41        call HWF_OPEN_FILE_DIR
0340+  687E C0              ret nz
0341+  687F 3E 03           ld a,3
0342+  6881 D0              ret nc
0343+  6882             
0344+  6882 7E              ld a,(hl)
0345+  6883 23              inc hl
0346+  6884 B7              or a
0347+  6885 20 F4           jr nz,_DSK_CHANGE_LOOP
0348+  6887             
0349+  6887 AF              xor a
0350+  6888 C9              ret
0351+  6889             
0352+  6889             
0353+  6889             ; -----------------------------------------------------------------------------
0354+  6889             ; DSK_CHANGE_DIR_U: Change the current directory
0355+  6889             ;                   and update config files and work area
0356+  6889             ;
0357+  6889             ; This one is tricky. We can't update CURDIR until after we are sure that
0358+  6889             ; the directory change has been sucessful, but if we update a config file
0359+  6889             ; after setting our directory then it won't be set anymore! Also if we fail
0360+  6889             ; we should restore the previous directory.
0361+  6889             ;
0362+  6889             ; Thus we do it like this:
0363+  6889             ;
0364+  6889             ; 1. Read current content of CURDIR, save in memory
0365+  6889             ; 2. Set CURDIR contents to the directory we want to change to
0366+  6889             ; 3. Try to change to the directory, if successful, we're all set
0367+  6889             ; 4. On error changing the directory, set CURDIR to its previous contents
0368+  6889             ;    and change to it again
0369+  6889             ; -----------------------------------------------------------------------------
0370+  6889             ; Input:  HL = Directory path, "dir/dir2/dir3", no starting or ending "/"
0371+  6889             ;         A  = 0 for relative to current, 1 for absolute
0372+  6889             ; Output: A  = 0: Ok
0373+  6889             ;              1: Other error
0374+  6889             ;              2: Directory not found
0375+  6889             ;              3: It's a file, not a directory
0376+  6889             ;              4: Path is too long
0377+  6889             
0378+  6889             DSK_CHANGE_DIR_U:
0379+  6889 FD E5           push iy
0380+  688B FD 21 BF FF     ld iy,-65
0381+  688F FD 39           add iy,sp
0382+  6891 FD F9           ld sp,iy
0383+  6893 CD A1 68        call _DSK_CHANGE_DIR_U
0384+  6896 FD 21 41 00     ld iy,65
0385+  689A FD 39           add iy,sp
0386+  689C FD F9           ld sp,iy
0387+  689E FD E1           pop iy
0388+  68A0 C9              ret
0389+  68A1             
0390+  68A1             _DSK_CHANGE_DIR_U:
0391+  68A1 F5              push af
0392+  68A2 E5              push hl
0393+  68A3             
0394+  68A3                 ;If setting absolute dir we can check its length now
0395+  68A3             
0396+  68A3 B7              or a
0397+  68A4 28 0F           jr z,_DSK_CHANGE_DIR_U_LENGTH_OK
0398+  68A6 E5              push hl
0399+  68A7 CD FE 5F        call BM_STRLEN
0400+  68AA E1              pop hl
0401+  68AB 78              ld a,b
0402+  68AC FE 41           cp BM_MAX_DIR_NAME_LENGTH+1
0403+  68AE 38 05           jr c,_DSK_CHANGE_DIR_U_LENGTH_OK
0404+  68B0 E1              pop hl
0405+  68B1 F1              pop af
0406+  68B2 3E 04           ld a,4
0407+  68B4 C9              ret
0408+  68B5             _DSK_CHANGE_DIR_U_LENGTH_OK:
0409+  68B5             
0410+  68B5                 ;Set work area as "no file mounted"
0411+  68B5             
0412+  68B5 CD E5 4F        call WK_GET_STORAGE_DEV_FLAGS
0413+  68B8 E6 FE           and 0FEh
0414+  68BA CD F8 4F        call WK_SET_STORAGE_DEV_FLAGS
0415+  68BD             
0416+  68BD                 ;Get current dir from CURDIR, save in memory
0417+  68BD             
0418+  68BD FD E5           push iy
0419+  68BF D1              pop de
0420+  68C0 13              inc de
0421+  68C1 21 27 69        ld hl,DSK_CURDIR_S
0422+  68C4 06 40           ld b,64
0423+  68C6 CD E5 67        call DSK_READ_MAIN_CONFIG_FILE
0424+  68C9 FD 70 00        ld (iy),b
0425+  68CC             
0426+  68CC                 ;If setting relative dir check length now
0427+  68CC             
0428+  68CC E1              pop hl
0429+  68CD F1              pop af
0430+  68CE B7              or a
0431+  68CF 20 33           jr nz,_DSK_CHANGE_DIR_U_UPD_CURDIR
0432+  68D1 E5              push hl
0433+  68D2 CD FE 5F        call BM_STRLEN
0434+  68D5 78              ld a,b
0435+  68D6 FD 86 00        add (iy)
0436+  68D9 3C              inc a   ;Account for the extra "/" to add
0437+  68DA FE 41           cp BM_MAX_DIR_NAME_LENGTH+1
0438+  68DC 38 04           jr c,_DSK_CHANGE_DIR_U_LENGTH_OK_2
0439+  68DE E1              pop hl
0440+  68DF 3E 04           ld a,4
0441+  68E1 C9              ret
0442+  68E2             _DSK_CHANGE_DIR_U_LENGTH_OK_2:
0443+  68E2             
0444+  68E2                 ;Also if setting relative dir:
0445+  68E2                 ;append dir to the one we have in memory
0446+  68E2             
0447+  68E2 FD E5           push iy
0448+  68E4 E1              pop hl
0449+  68E5 23              inc hl  ;Skip length
0450+  68E6 FD 7E 00        ld a,(iy)
0451+  68E9 5F              ld e,a
0452+  68EA 16 00           ld d,0
0453+  68EC B7              or a
0454+  68ED 28 04           jr z,_DSK_CHANGE_DIR_U_APPEND_OK ;It's root dir
0455+  68EF 19              add hl,de
0456+  68F0 36 2F           ld (hl),'/'
0457+  68F2 23              inc hl
0458+  68F3             _DSK_CHANGE_DIR_U_APPEND_OK: 
0459+  68F3 EB              ex de,hl
0460+  68F4             
0461+  68F4 E1              pop hl
0462+  68F5 E5              push hl
0463+  68F6 CD FE 5F        call BM_STRLEN
0464+  68F9 E1              pop hl
0465+  68FA 48              ld c,b
0466+  68FB 06 00           ld b,0
0467+  68FD 03              inc bc  ;Count the terminator too
0468+  68FE ED B0           ldir
0469+  6900             
0470+  6900 FD E5           push iy
0471+  6902 E1              pop hl
0472+  6903 23              inc hl
0473+  6904             
0474+  6904                 ;Save new dir into CURDIR,
0475+  6904                 ;input: HL = new absolute dir
0476+  6904             
0477+  6904             _DSK_CHANGE_DIR_U_UPD_CURDIR:
0478+  6904 CD 2E 69        call _DSK_SET_CURDIR
0479+  6907             
0480+  6907                 ;Try the actual dir change, return if ok
0481+  6907             
0482+  6907 3E 01           ld a,1
0483+  6909 E5              push hl
0484+  690A CD 6C 68        call DSK_CHANGE_DIR
0485+  690D E1              pop hl
0486+  690E 28 2C           jr z,_DSK_SET_CURDIR_OK
0487+  6910             
0488+  6910                 ;Rewrite CURDIR with its old value,
0489+  6910                 ;and change to the old directory again
0490+  6910             
0491+  6910 FD E5           push iy
0492+  6912 D1              pop de
0493+  6913 13              inc de
0494+  6914 FD 46 00        ld b,(iy)
0495+  6917 21 27 69        ld hl,DSK_CURDIR_S
0496+  691A F5              push af
0497+  691B D5              push de
0498+  691C CD 24 68        call DSK_WRITE_MAIN_CONFIG_FILE
0499+  691F E1              pop hl
0500+  6920 3E 01           ld a,1
0501+  6922 CD 6C 68        call DSK_CHANGE_DIR
0502+  6925 F1              pop af
0503+  6926             
0504+  6926 C9              ret
0505+  6927             
0506+  6927             DSK_CURDIR_S:
0507+  6927                 db "CURDIR",0
0507+  6927 43555244495200
0508+  692E             
0509+  692E                 ;--- Set the value of CURDIR from HL, preserves HL
0510+  692E             
0511+  692E             _DSK_SET_CURDIR:
0512+  692E E5              push hl
0513+  692F CD FE 5F        call BM_STRLEN
0514+  6932 D1              pop de
0515+  6933 D5              push de
0516+  6934 21 27 69        ld hl,DSK_CURDIR_S
0517+  6937 CD 24 68        call DSK_WRITE_MAIN_CONFIG_FILE
0518+  693A E1              pop hl
0519+  693B C9              ret
0520+  693C             
0521+  693C                 ;--- Dir change ok: delete CURFILE since nothing is mounted now,
0522+  693C                 ;    and set dir again.
0523+  693C             
0524+  693C             _DSK_SET_CURDIR_OK:
0525+  693C E5              push hl
0526+  693D 21 27 69        ld hl,DSK_CURDIR_S
0527+  6940 11 9E 67        ld de,DSK_ZERO_S
0528+  6943 CD 24 68        call DSK_WRITE_MAIN_CONFIG_FILE
0529+  6946 E1              pop hl
0530+  6947 C3 2E 69        jp _DSK_SET_CURDIR
0531+  694A             
0532+  694A             
0533+  694A             ; -----------------------------------------------------------------------------
0534+  694A             ; DSK_MOUNT: Mount a file in the current directory
0535+  694A             ;            and update config file and work area;
0536+  694A             ;            in case of failure it restores the previously mounted file.
0537+  694A             ;
0538+  694A             ; This one is tricky as DSK_CHANGE_DIR_U, but even more because every time we
0539+  694A             ; want to mount a file (the requested one or the previous one) we need to ensure
0540+  694A             ; that the value of CURDIR is set as the current directory.
0541+  694A             ; -----------------------------------------------------------------------------
0542+  694A             ; Input:  HL = File path
0543+  694A             ;         A  = 0: Mount as read-only if read-only flag is set
0544+  694A             ;              1: Force mount as read and write
0545+  694A             ;              2: Force mount as read-only
0546+  694A             ; Output: A  = 0: Ok
0547+  694A             ;              1: Other error
0548+  694A             ;              2: File not found
0549+  694A             ;              3: It's a directory, not a file
0550+  694A             
0551+  694A             DSK_MOUNT:
0552+  694A FD E5           push iy
0553+  694C FD 21 AF FF     ld iy,-65-15-1    ;65 for dir name+0, 15 for file length+name+0, 1 extra for read-only mode
0554+  6950 FD 39           add iy,sp
0555+  6952 FD F9           ld sp,iy
0556+  6954 CD 62 69        call _DSK_MOUNT
0557+  6957 FD 21 51 00     ld iy,65+15+1
0558+  695B FD 39           add iy,sp
0559+  695D FD F9           ld sp,iy
0560+  695F FD E1           pop iy
0561+  6961 C9              ret
0562+  6962             
0563+  6962             _DSK_MOUNT:
0564+  6962 FD 77 50        ld (iy+65+15),a
0565+  6965 E5              push hl
0566+  6966             
0567+  6966                 ;Set work area as "no file mounted" for now
0568+  6966             
0569+  6966 CD E5 4F        call WK_GET_STORAGE_DEV_FLAGS
0570+  6969 E6 FE           and 0FEh
0571+  696B CD F8 4F        call WK_SET_STORAGE_DEV_FLAGS
0572+  696E             
0573+  696E                 ;Get current dir from CURDIR, save in memory
0574+  696E             
0575+  696E FD E5           push iy
0576+  6970 D1              pop de
0577+  6971 21 27 69        ld hl,DSK_CURDIR_S
0578+  6974 06 40           ld b,64
0579+  6976 CD E5 67        call DSK_READ_MAIN_CONFIG_FILE
0580+  6979 AF              xor a
0581+  697A 12              ld (de),a
0582+  697B             
0583+  697B                 ;Get current file from CURFILE, save in memory
0584+  697B             
0585+  697B FD E5           push iy
0586+  697D E1              pop hl
0587+  697E 11 42 00        ld de,65+1
0588+  6981 19              add hl,de   ;HL = Buffer for file name from CURFILE
0589+  6982 E5              push hl
0590+  6983 EB              ex de,hl
0591+  6984 21 12 6A        ld hl,DSK_CURFILE_S
0592+  6987 06 0D           ld b,13
0593+  6989 CD E5 67        call DSK_READ_MAIN_CONFIG_FILE
0594+  698C E1              pop hl
0595+  698D 2B              dec hl      ;HL = Buffer for length of file name
0596+  698E 70              ld (hl),b
0597+  698F AF              xor a
0598+  6990 12              ld (de),a
0599+  6991             
0600+  6991                 ;Set CURFILE with the new file to be mounted
0601+  6991             
0602+  6991 E1              pop hl
0603+  6992 E5              push hl
0604+  6993 D1              pop de
0605+  6994 D5              push de
0606+  6995 CD FE 5F        call BM_STRLEN
0607+  6998 21 12 6A        ld hl,DSK_CURFILE_S
0608+  699B CD 24 68        call DSK_WRITE_MAIN_CONFIG_FILE
0609+  699E             
0610+  699E                 ;Set current directory from CURDIR again
0611+  699E             
0612+  699E FD E5           push iy
0613+  69A0 E1              pop hl
0614+  69A1 3E 01           ld a,1
0615+  69A3 CD 6C 68        call DSK_CHANGE_DIR
0616+  69A6 B7              or a
0617+  69A7 E1              pop hl  ;Name of file to mount
0618+  69A8 C0              ret nz  ;Should never occur but just in case
0619+  69A9             
0620+  69A9                 ;Try to actually mount the file, return if ok
0621+  69A9             
0622+  69A9 E5              push hl
0623+  69AA CD CA 41        call HWF_OPEN_FILE_DIR
0624+  69AD E1              pop hl
0625+  69AE 20 05           jr nz,_DSK_MOUNT_ERR
0626+  69B0 D2 EE 69        jp nc,_DSK_MOUNT_SET_WORK
0627+  69B3 3E 03           ld a,3
0628+  69B5             _DSK_MOUNT_ERR:
0629+  69B5 FD 36 50 00     ld (iy+65+15),0 ;Remount old file in auto-readonly mode
0630+  69B9 F5              push af ;Save the error we'll return at the end
0631+  69BA             
0632+  69BA                 ;Restore old contents of CURFILE
0633+  69BA             
0634+  69BA FD E5           push iy
0635+  69BC E1              pop hl
0636+  69BD 11 41 00        ld de,65
0637+  69C0 19              add hl,de
0638+  69C1 46              ld b,(hl)
0639+  69C2 23              inc hl
0640+  69C3 EB              ex de,hl
0641+  69C4 21 12 6A        ld hl,DSK_CURFILE_S
0642+  69C7 CD 24 68        call DSK_WRITE_MAIN_CONFIG_FILE
0643+  69CA E1              pop hl  ;Error from mounting the requested file
0644+  69CB B7              or a
0645+  69CC 7C              ld a,h
0646+  69CD C0              ret nz
0647+  69CE E5              push hl
0648+  69CF             
0649+  69CF                 ;Set current directory from CURDIR again
0650+  69CF             
0651+  69CF FD E5           push iy
0652+  69D1 E1              pop hl
0653+  69D2 3E 01           ld a,1
0654+  69D4 CD 6C 68        call DSK_CHANGE_DIR
0655+  69D7 20 13           jr nz,_DSK_MOUNT_ERR_END  ;Should never occur but just in case
0656+  69D9             
0657+  69D9                 ;Mount file from CURFILE again if there was any
0658+  69D9             
0659+  69D9 FD E5           push iy
0660+  69DB E1              pop hl
0661+  69DC 11 42 00        ld de,65+1
0662+  69DF 19              add hl,de
0663+  69E0 7E              ld a,(hl)
0664+  69E1 B7              or a
0665+  69E2 28 08           jr z,_DSK_MOUNT_ERR_END
0666+  69E4 E5              push hl
0667+  69E5 CD CA 41        call HWF_OPEN_FILE_DIR
0668+  69E8 E1              pop hl
0669+  69E9 CC EE 69        call z,_DSK_MOUNT_SET_WORK  ;Assume it was a file, not a dir
0670+  69EC                 
0671+  69EC                 ;Jump here on error from HWF_OPEN_FILE_DIR
0672+  69EC             
0673+  69EC             _DSK_MOUNT_ERR_END:
0674+  69EC F1              pop af
0675+  69ED C9              ret
0676+  69EE             
0677+  69EE                 ;Set disk mounted flag in work area
0678+  69EE                 ;HL = File name
0679+  69EE             
0680+  69EE             _DSK_MOUNT_SET_WORK:
0681+  69EE F5              push af
0682+  69EF FD 7E 50        ld a,(iy+65+15)
0683+  69F2 FE 02           cp 2
0684+  69F4 28 10           jr z,_DSK_MOUNT_SET_WORK_DO
0685+  69F6 FE 01           cp 1
0686+  69F8 3E 00           ld a,0
0687+  69FA 28 0A           jr z,_DSK_MOUNT_SET_WORK_DO
0688+  69FC CD 77 43        call HWF_GET_FILE_ATTR
0689+  69FF 3D              dec a
0690+  6A00 28 04           jr z,_DSK_MOUNT_SET_WORK_DO ;Error, assume not read-only
0691+  6A02 78              ld a,b    ;Attributes byte, read-only in bit 0
0692+  6A03 17              rla ;Now read-only in bit 1
0693+  6A04 E6 02           and 2
0694+  6A06             
0695+  6A06             _DSK_MOUNT_SET_WORK_DO:
0696+  6A06 47              ld b,a
0697+  6A07 CD E5 4F        call WK_GET_STORAGE_DEV_FLAGS
0698+  6A0A F6 05           or 1+4  ;Disk present+disk has changed
0699+  6A0C B0              or b  ;Read-only flag (maybe)
0700+  6A0D CD F8 4F        call WK_SET_STORAGE_DEV_FLAGS
0701+  6A10 F1              pop af
0702+  6A11 C9              ret
0703+  6A12             
0704+  6A12             DSK_CURFILE_S:
0705+  6A12                 db "CURFILE",0
0705+  6A12 43555246494C4500
0706+  6A1A             
0707+  6A1A             
0708+  6A1A             ; -----------------------------------------------------------------------------
0709+  6A1A             ; DSK_GET_CURDIR: Get (and enter) the current directory
0710+  6A1A             ;
0711+  6A1A             ; - If config file CURDIR exists and the directory it contains exists: return it
0712+  6A1A             ; - Otherwise, return the main directory
0713+  6A1A             ;
0714+  6A1A             ; Doesn't modify the contents of CURFILE.
0715+  6A1A             ; -----------------------------------------------------------------------------
0716+  6A1A             ; Input:  HL = Address of 65 byte buffer for directory name
0717+  6A1A             ; Output: A  = 0: Ok
0718+  6A1A             ;              1: Error
0719+  6A1A             ;         B  = Length of name (not including terminator), 0 on error
0720+  6A1A             ;         DE = Pointer to terminator
0721+  6A1A             
0722+  6A1A             DSK_GET_CURDIR:
0723+  6A1A EB              ex de,hl
0724+  6A1B 21 27 69        ld hl,DSK_CURDIR_S
0725+  6A1E D5              push de
0726+  6A1F 06 40           ld b,64
0727+  6A21 CD E5 67        call DSK_READ_MAIN_CONFIG_FILE
0728+  6A24 B7              or a
0729+  6A25 20 10           jr nz,_DSK_GET_CURDIR_NO_CONFIG
0730+  6A27 12              ld (de),a
0731+  6A28             
0732+  6A28 E1              pop hl
0733+  6A29 E5              push hl
0734+  6A2A C5              push bc
0735+  6A2B 3E 01           ld a,1
0736+  6A2D CD 6C 68        call DSK_CHANGE_DIR
0737+  6A30 C1              pop bc
0738+  6A31 B7              or a
0739+  6A32 20 03           jr nz,_DSK_GET_CURDIR_NO_CONFIG
0740+  6A34             
0741+  6A34 33              inc sp
0742+  6A35 33              inc sp
0743+  6A36 C9              ret
0744+  6A37             
0745+  6A37             _DSK_GET_CURDIR_NO_CONFIG:
0746+  6A37 CD 73 67        call DSK_OPEN_MAIN_DIR
0747+  6A3A 3E 01           ld a,1
0748+  6A3C 20 15           jr nz,_DSK_OPEN_MAIN_DIR_EMPTY
0749+  6A3E 3E 00           ld a,0
0750+  6A40 30 11           jr nc,_DSK_OPEN_MAIN_DIR_EMPTY
0751+  6A42             
0752+  6A42 D1              pop de
0753+  6A43 D5              push de
0754+  6A44 21 9B 67        ld hl,DSK_MAIN_DIR_S
0755+  6A47 01 0D 00        ld bc,13
0756+  6A4A ED B0           ldir
0757+  6A4C E1              pop hl
0758+  6A4D CD FE 5F        call BM_STRLEN
0759+  6A50 EB              ex de,hl
0760+  6A51 AF              xor a
0761+  6A52 C9              ret
0762+  6A53             
0763+  6A53             _DSK_OPEN_MAIN_DIR_EMPTY:
0764+  6A53 D1              pop de
0765+  6A54 06 00           ld b,0
0766+  6A56 C9              ret
0767+  6A57             
0768+  6A57             
0769+  6A57             ; -----------------------------------------------------------------------------
0770+  6A57             ; DSK_REMOUNT: Mount again the current file (per CURDIR and CURFILE)
0771+  6A57             ; -----------------------------------------------------------------------------
0772+  6A57             ; Input:  HL = Address of 65 byte buffer for directory name
0773+  6A57             ; Output: A  = 0: Ok
0774+  6A57             ;              1: Other error
0775+  6A57             ;              2: No CURDIR file, or directory doesn't exist
0776+  6A57             ;              3: No CURFILE file, or file doesn't exist
0777+  6A57             
0778+  6A57             DSK_REMOUNT:
0779+  6A57 FD E5           push iy
0780+  6A59 FD 21 B2 FF     ld iy,-65-13
0781+  6A5D FD 39           add iy,sp
0782+  6A5F FD F9           ld sp,iy
0783+  6A61 CD 6F 6A        call _DSK_REMOUNT
0784+  6A64 FD 21 4E 00     ld iy,65+13
0785+  6A68 FD 39           add iy,sp
0786+  6A6A FD F9           ld sp,iy
0787+  6A6C FD E1           pop iy
0788+  6A6E C9              ret
0789+  6A6F             
0790+  6A6F             _DSK_REMOUNT:
0791+  6A6F CD E5 4F        call WK_GET_STORAGE_DEV_FLAGS   ;No disk mounted for now
0792+  6A72 E6 FE           and 0FEh
0793+  6A74 CD F8 4F        call WK_SET_STORAGE_DEV_FLAGS
0794+  6A77             
0795+  6A77 FD E5           push iy
0796+  6A79 D1              pop de
0797+  6A7A 21 27 69        ld hl,DSK_CURDIR_S
0798+  6A7D 06 40           ld b,64
0799+  6A7F CD E5 67        call DSK_READ_MAIN_CONFIG_FILE
0800+  6A82 B7              or a
0801+  6A83 C0              ret nz
0802+  6A84 12              ld (de),a
0803+  6A85             
0804+  6A85 FD E5           push iy
0805+  6A87 E1              pop hl
0806+  6A88 01 41 00        ld bc,65
0807+  6A8B 09              add hl,bc
0808+  6A8C EB              ex de,hl
0809+  6A8D 21 12 6A        ld hl,DSK_CURFILE_S
0810+  6A90 06 0C           ld b,12
0811+  6A92 CD E5 67        call DSK_READ_MAIN_CONFIG_FILE
0812+  6A95 B7              or a
0813+  6A96 28 06           jr z,_DSK_REMOUNT_OK
0814+  6A98 FE 01           cp 1
0815+  6A9A C8              ret z
0816+  6A9B 3E 03           ld a,3
0817+  6A9D C9              ret
0818+  6A9E             _DSK_REMOUNT_OK:
0819+  6A9E 12              ld (de),a
0820+  6A9F             
0821+  6A9F FD E5           push iy
0822+  6AA1 E1              pop hl
0823+  6AA2 3E 01           ld a,1
0824+  6AA4 CD 6C 68        call DSK_CHANGE_DIR
0825+  6AA7 FE 01           cp 1
0826+  6AA9 C8              ret z
0827+  6AAA FE 02           cp 2
0828+  6AAC C8              ret z
0829+  6AAD FE 03           cp 3
0830+  6AAF 3E 01           ld a,1
0831+  6AB1 C8              ret z  ;It's a file, not a dir
0832+  6AB2             
0833+  6AB2 FD E5           push iy
0834+  6AB4 E1              pop hl
0835+  6AB5 01 41 00        ld bc,65
0836+  6AB8 09              add hl,bc
0837+  6AB9 CD CA 41        call HWF_OPEN_FILE_DIR
0838+  6ABC 28 06           jr z,_DSK_REMOUNT_OK_2
0839+  6ABE FE 01           cp 1
0840+  6AC0 C8              ret z
0841+  6AC1 3E 03           ld a,3
0842+  6AC3 C9              ret
0843+  6AC4             
0844+  6AC4             _DSK_REMOUNT_OK_2:
0845+  6AC4 3E 01           ld a,1
0846+  6AC6 D8              ret c   ;It's a dir, not a file
0847+  6AC7             
0848+  6AC7 CD 77 43        call HWF_GET_FILE_ATTR
0849+  6ACA 3D              dec a
0850+  6ACB 28 04           jr z,_DSK_REMOUNT_OK_3 ;Error, assume not read-only
0851+  6ACD 78              ld a,b    ;Attributes byte, read-only in bit 0
0852+  6ACE 17              rla ;Now read-only in bit 1
0853+  6ACF E6 02           and 2
0854+  6AD1             
0855+  6AD1             _DSK_REMOUNT_OK_3:
0856+  6AD1 47              ld b,a
0857+  6AD2 CD E5 4F        call WK_GET_STORAGE_DEV_FLAGS
0858+  6AD5 F6 05           or 1+4  ;Disk present+disk has changed
0859+  6AD7 B0              or b  ;Read-only flag (maybe)
0860+  6AD8 CD F8 4F        call WK_SET_STORAGE_DEV_FLAGS
0861+  6ADB             
0862+  6ADB AF              xor a
0863+  6ADC C9              ret
0864+  6ADD             
0865+  6ADD             
0866+  6ADD             ; -----------------------------------------------------------------------------
0867+  6ADD             ; DSK_GET_DEFAULT: Get the name of the default file in current directory
0868+  6ADD             ; -----------------------------------------------------------------------------
0869+  6ADD             ; Input:  HL = Address of 13 byte buffer for file name
0870+  6ADD             ; Output: A  = 0: Ok
0871+  6ADD             ;              1: Other error
0872+  6ADD             ;              2: File not found (directory is empty)
0873+  6ADD             
0874+  6ADD             DSK_GET_DEFAULT:
0875+  6ADD FD E5           push iy
0876+  6ADF FD 21 E0 FF     ld iy,-32
0877+  6AE3 FD 39           add iy,sp
0878+  6AE5 FD F9           ld sp,iy
0879+  6AE7 CD F5 6A        call _DSK_GET_DEFAULT
0880+  6AEA FD 21 20 00     ld iy,32
0881+  6AEE FD 39           add iy,sp
0882+  6AF0 FD F9           ld sp,iy
0883+  6AF2 FD E1           pop iy
0884+  6AF4 C9              ret
0885+  6AF5             
0886+  6AF5             _DSK_GET_DEFAULT:
0887+  6AF5             
0888+  6AF5                 ;* First check if a DEFAULT.DSK file exists
0889+  6AF5             
0890+  6AF5 E5              push hl
0891+  6AF6 CD 4B 6B        call DSK_DEFAULT_EXISTS
0892+  6AF9 E1              pop hl
0893+  6AFA FE 01           cp 1
0894+  6AFC C8              ret z
0895+  6AFD             
0896+  6AFD B7              or a
0897+  6AFE 20 0D           jr nz,_DSK_GET_DEFAULT_NODEF
0898+  6B00             
0899+  6B00                 ; DEFAULT.DSK exists, copy to destination for now
0900+  6B00             
0901+  6B00 E5              push hl
0902+  6B01 EB              ex de,hl
0903+  6B02 21 97 6B        ld hl,DSK_DEFAULT_S
0904+  6B05 01 0C 00        ld bc,12
0905+  6B08 ED B0           ldir
0906+  6B0A E1              pop hl
0907+  6B0B 18 16           jr _DSK_GET_DEFAULT_2
0908+  6B0D             
0909+  6B0D                 ; DEFAULT.DSK doesn't exist, see if any suitable file exists at all
0910+  6B0D             
0911+  6B0D             _DSK_GET_DEFAULT_NODEF:
0912+  6B0D E5              push hl
0913+  6B0E FD E5           push iy
0914+  6B10 E1              pop hl
0915+  6B11 AF              xor a
0916+  6B12 CD 4C 42        call HWF_FIND_NTH_FILE
0917+  6B15 E1              pop hl
0918+  6B16 B7              or a
0919+  6B17 C0              ret nz
0920+  6B18             
0921+  6B18 E5              push hl
0922+  6B19 EB              ex de,hl
0923+  6B1A FD E5           push iy
0924+  6B1C E1              pop hl
0925+  6B1D CD 3D 5D        call BM_GENERATE_FILENAME
0926+  6B20 36 00           ld (hl),0
0927+  6B22 E1              pop hl
0928+  6B23             
0929+  6B23                 ;* Now we have either DEFAULT.DSK or the name of the first existing file
0930+  6B23                 ;  copied to the destination address. See if there's a suitable DEFFILE file
0931+  6B23                 ;  and if so extract and use its contents, if not just return.
0932+  6B23                 ;  No errors will be returned past this point.
0933+  6B23             
0934+  6B23             _DSK_GET_DEFAULT_2:
0935+  6B23 E5              push hl
0936+  6B24 FD E5           push iy
0937+  6B26 D1              pop de
0938+  6B27 21 43 6B        ld hl,DSK_DEFFILE_S
0939+  6B2A 06 0C           ld b,12
0940+  6B2C CD 9F 67        call DSK_READ_CONFIG_FILE
0941+  6B2F E1              pop hl
0942+  6B30 B7              or a
0943+  6B31 3E 00           ld a,0
0944+  6B33 C0              ret nz
0945+  6B34 12              ld (de),a
0946+  6B35 78              ld a,b
0947+  6B36 B7              or a
0948+  6B37 C8              ret z
0949+  6B38             
0950+  6B38                 ; We got a file name from DEFFILE, so copy its contents
0951+  6B38                 ; to the output buffer.
0952+  6B38             
0953+  6B38 EB              ex de,hl
0954+  6B39 FD E5           push iy
0955+  6B3B E1              pop hl
0956+  6B3C 01 0D 00        ld bc,13
0957+  6B3F ED B0           ldir
0958+  6B41             
0959+  6B41 AF              xor a
0960+  6B42 C9              ret
0961+  6B43             
0962+  6B43             DSK_DEFFILE_S:
0963+  6B43                 db "DEFFILE",0
0963+  6B43 44454646494C4500
0964+  6B4B             
0965+  6B4B             
0966+  6B4B             ; -----------------------------------------------------------------------------
0967+  6B4B             ; DSK_DEFAULT_EXISTS: Does the DEFAULT.DSK file exist in current directory?
0968+  6B4B             ;
0969+  6B4B             ; We need to do the search in a weird way because there's no way to initiate
0970+  6B4B             ; a file search without specifying 
0971+  6B4B             ; -----------------------------------------------------------------------------
0972+  6B4B             ; Input:  IY = Address of 32 byte buffer for directory entry
0973+  6B4B             ; Output: A  = 0: Ok
0974+  6B4B             ;              1: Other error
0975+  6B4B             ;              2: File doesn't exist
0976+  6B4B             
0977+  6B4B             DSK_DEFAULT_EXISTS:
0978+  6B4B 3E 2F           ld a,CH_CMD_SET_FILE_NAME
0979+  6B4D D3 21           out (CH_COMMAND_PORT),a
0980+  6B4F 21 8B 6B        ld hl,DSK_DEFAST_S
0981+  6B52 CD D3 44        call CH_WRITE_STRING
0982+  6B55 3E 32           ld a,CH_CMD_FILE_OPEN
0983+  6B57 D3 21           out (CH_COMMAND_PORT),a
0984+  6B59             
0985+  6B59             _DSK_DEFAULT_EXISTS_LOOP:
0986+  6B59 CD 01 44        call CH_WAIT_INT_AND_GET_RESULT
0987+  6B5C 47              ld b,a
0988+  6B5D FE 42           cp USB_ERR_MISS_FILE
0989+  6B5F 3E 02           ld a,2
0990+  6B61 C8              ret z
0991+  6B62 78              ld a,b
0992+  6B63 FE 1D           cp CH_ST_INT_DISK_READ
0993+  6B65 3E 01           ld a,1
0994+  6B67 C0              ret nz
0995+  6B68             
0996+  6B68 FD E5           push iy
0997+  6B6A E1              pop hl
0998+  6B6B CD A9 44        call CH_READ_DATA
0999+  6B6E 78              ld a,b
1000+  6B6F FE 20           cp 32
1001+  6B71 3E 01           ld a,1
1002+  6B73 C0              ret nz
1003+  6B74             
1004+  6B74 FD 7E 0A        ld a,(iy+10)
1005+  6B77 FE 4B           cp "K"
1006+  6B79 20 0A           jr nz,_DSK_DEFAULT_EXISTS_NEXT
1007+  6B7B             
1008+  6B7B FD 7E 0B        ld a,(iy+11)
1009+  6B7E E6 1A           and 11010b  ;Directory, hidden or volume?
1010+  6B80 3E 02           ld a,2
1011+  6B82 C0              ret nz
1012+  6B83             
1013+  6B83 AF              xor a
1014+  6B84 C9              ret
1015+  6B85             
1016+  6B85             _DSK_DEFAULT_EXISTS_NEXT:
1017+  6B85 3E 33           ld a,CH_CMD_FILE_ENUM_GO
1018+  6B87 D3 21           out (CH_COMMAND_PORT),a
1019+  6B89 18 CE           jr _DSK_DEFAULT_EXISTS_LOOP
1020+  6B8B             
1021+  6B8B             DSK_DEFAST_S:
1022+  6B8B                 db "DEFAULT.DS*",0
1022+  6B8B 44454641554C542E44532A00
1023+  6B97             DSK_DEFAULT_S:
1024+  6B97                 db "DEFAULT.DSK",0
1024+  6B97 44454641554C542E44534B00
1025+  6BA3             
1026+  6BA3             
1027+  6BA3             ; -----------------------------------------------------------------------------
1028+  6BA3             ; DSK_GET_BOOTDIR: Get the boot directory
1029+  6BA3             ;
1030+  6BA3             ; Hidden files and files starting with "_" don't count.
1031+  6BA3             ; -----------------------------------------------------------------------------
1032+  6BA3             ; Input:  HL = Address of 64 byte buffer for the directory
1033+  6BA3             ; Output: A  = 0: Ok
1034+  6BA3             ;              1: Other error
1035+  6BA3             ;              2: File doesn't exist
1036+  6BA3             
1037+  6BA3             DSK_GET_BOOTDIR:
1038+  6BA3 36 00           ld (hl),0
1039+  6BA5 EB              ex de,hl
1040+  6BA6 21 B2 6B        ld hl,DSK_BOOTDIR_S
1041+  6BA9 06 40           ld b,64
1042+  6BAB CD E5 67        call DSK_READ_MAIN_CONFIG_FILE
1043+  6BAE B7              or a
1044+  6BAF C0              ret nz
1045+  6BB0 12              ld (de),a
1046+  6BB1 C9              ret
1047+  6BB2             
1048+  6BB2             DSK_BOOTDIR_S:
1049+  6BB2                 db "BOOTDIR",0
1049+  6BB2 424F4F5444495200
1050+  6BBA             
1051+  6BBA             
1052+  6BBA             ; -----------------------------------------------------------------------------
1053+  6BBA             ; DSK_CHANGE_BOOTDIR: Change to the boot directory or the main directory
1054+  6BBA             ; -----------------------------------------------------------------------------
1055+  6BBA             ; Output: A  = 0: Ok
1056+  6BBA             ;              1: Error
1057+  6BBA             
1058+  6BBA             DSK_CHANGE_BOOTDIR:
1059+  6BBA FD E5           push iy
1060+  6BBC FD 21 C0 FF     ld iy,-64
1061+  6BC0 FD 39           add iy,sp
1062+  6BC2 FD F9           ld sp,iy
1063+  6BC4 CD D2 6B        call _DSK_CHANGE_BOOTDIR
1064+  6BC7 FD 21 40 00     ld iy,64
1065+  6BCB FD 39           add iy,sp
1066+  6BCD FD F9           ld sp,iy
1067+  6BCF FD E1           pop iy
1068+  6BD1 C9              ret
1069+  6BD2             
1070+  6BD2             _DSK_CHANGE_BOOTDIR:
1071+  6BD2 FD E5           push iy
1072+  6BD4 E1              pop hl
1073+  6BD5 CD A3 6B        call DSK_GET_BOOTDIR
1074+  6BD8 B7              or a
1075+  6BD9 C2 E6 6B        jp nz,_DSK_CHANGE_BOOTDIR_ERR
1076+  6BDC             
1077+  6BDC FD E5           push iy
1078+  6BDE E1              pop hl
1079+  6BDF 3E 01           ld a,1
1080+  6BE1 CD 89 68        call DSK_CHANGE_DIR_U  
1081+  6BE4 B7              or a
1082+  6BE5 C8              ret z
1083+  6BE6             
1084+  6BE6                 ; BOOTDIR doesn't exist or can't change to the dir it points to,
1085+  6BE6                 ; so fallback to setting the main dir
1086+  6BE6             
1087+  6BE6             _DSK_CHANGE_BOOTDIR_ERR:
1088+  6BE6 21 9B 67        ld hl,DSK_MAIN_DIR_S
1089+  6BE9 3E 01           ld a,1
1090+  6BEB CD 89 68        call DSK_CHANGE_DIR_U
1091+  6BEE B7              or a
1092+  6BEF C8              ret z
1093+  6BF0             
1094+  6BF0 21 99 67        ld hl,DSK_ROOT_DIR_S
1095+  6BF3 C3 89 68        jp DSK_CHANGE_DIR_U
1096+  6BF6             
1097+  6BF6             
1098+  6BF6             ; -----------------------------------------------------------------------------
1099+  6BF6             ; DSK_GET_BOOTMODE: Get current boot mode
1100+  6BF6             ; -----------------------------------------------------------------------------
1101+  6BF6             ; Output: A  = Boot mode (1 to 4)
1102+  6BF6             
1103+  6BF6             DSK_GET_BOOTMODE:
1104+  6BF6 FD E5           push iy
1105+  6BF8 FD 21 FF FF     ld iy,-1
1106+  6BFC FD 39           add iy,sp
1107+  6BFE FD F9           ld sp,iy
1108+  6C00 CD 0E 6C        call _DSK_GET_BOOTMODE
1109+  6C03 FD 21 01 00     ld iy,1
1110+  6C07 FD 39           add iy,sp
1111+  6C09 FD F9           ld sp,iy
1112+  6C0B FD E1           pop iy
1113+  6C0D C9              ret
1114+  6C0E             
1115+  6C0E             _DSK_GET_BOOTMODE:
1116+  6C0E 21 33 6C        ld hl,DSK_BOOTMODE_S
1117+  6C11 FD E5           push iy
1118+  6C13 D1              pop de
1119+  6C14 06 01           ld b,1
1120+  6C16 CD E5 67        call DSK_READ_MAIN_CONFIG_FILE
1121+  6C19 B7              or a
1122+  6C1A 3E 01           ld a,1
1123+  6C1C C0              ret nz
1124+  6C1D                 
1125+  6C1D 78              ld a,b
1126+  6C1E B7              or a
1127+  6C1F 3E 01           ld a,1
1128+  6C21 C8              ret z
1129+  6C22             
1130+  6C22                 ;Return value read minus "0" if it's "1" to "4", return 1 otherwise
1131+  6C22             
1132+  6C22 FD 7E 00        ld a,(iy)
1133+  6C25 D6 30           sub "0"
1134+  6C27 47              ld b,a
1135+  6C28 B7              or a
1136+  6C29 3E 01           ld a,1
1137+  6C2B C8              ret z
1138+  6C2C 78              ld a,b
1139+  6C2D FE 05           cp 5
1140+  6C2F D8              ret c
1141+  6C30 3E 01           ld a,1
1142+  6C32 C9              ret
1143+  6C33             
1144+  6C33             DSK_BOOTMODE_S:
1145+  6C33                 db "BOOTMODE",0
1145+  6C33 424F4F544D4F444500
1146+  6C3C             
1147+  6C3C             
1148+  6C3C             ; -----------------------------------------------------------------------------
1149+  6C3C             ; DSK_DO_BOOT_PROC: Do the boot procedure
1150+  6C3C             ; -----------------------------------------------------------------------------
1151+  6C3C             ; Output: A  = 0: Do the computer boot procedure
1152+  6C3C             ;                 (on boot mode 1 jump to boot menu)
1153+  6C3C             ;              1: Do the device change boot procedure (always return)
1154+  6C3C             
1155+  6C3C             DSK_DO_BOOT_PROC:
1156+  6C3C FD E5           push iy
1157+  6C3E FD 21 F3 FF     ld iy,-13
1158+  6C42 FD 39           add iy,sp
1159+  6C44 FD F9           ld sp,iy
1160+  6C46 CD 54 6C        call _DSK_DO_BOOT_PROC
1161+  6C49 FD 21 0D 00     ld iy,13
1162+  6C4D FD 39           add iy,sp
1163+  6C4F FD F9           ld sp,iy
1164+  6C51 FD E1           pop iy
1165+  6C53 C9              ret
1166+  6C54             
1167+  6C54             _DSK_DO_BOOT_PROC:
1168+  6C54 FD 77 00        ld (iy),a
1169+  6C57             
1170+  6C57 B7              or a
1171+  6C58 20 0C           jr nz,_DSK_DO_BOOT_PROC_2
1172+  6C5A             
1173+  6C5A                 ;When booting computer:
1174+  6C5A                 ;If TAB is pressed, force boot mode 1
1175+  6C5A             
1176+  6C5A 11 07 00        ld de,7
1177+  6C5D 21 E5 FB        ld hl,NEWKEY
1178+  6C60 19              add hl,de
1179+  6C61 7E              ld a,(hl)
1180+  6C62 E6 08           and 8
1181+  6C64 28 23           jr z,_DSK_DO_BOOT_1
1182+  6C66             _DSK_DO_BOOT_PROC_2:
1183+  6C66             
1184+  6C66 CD E5 4F        call WK_GET_STORAGE_DEV_FLAGS   ;No disk mounted for now
1185+  6C69 E6 FE           and 0FEh
1186+  6C6B CD F8 4F        call WK_SET_STORAGE_DEV_FLAGS
1187+  6C6E             
1188+  6C6E FD 7E 00        ld a,(iy)
1189+  6C71 B7              or a
1190+  6C72 20 07           jr nz,_DSK_DO_BOOT_PROC_3
1191+  6C74             
1192+  6C74 CD 2B 6D        call DSK_TEST_DEL_TMP_BOOT_FILE
1193+  6C77 B7              or a
1194+  6C78 CA B6 6C        jp z,_DSK_DO_BOOT_4
1195+  6C7B             
1196+  6C7B             _DSK_DO_BOOT_PROC_3:
1197+  6C7B CD F6 6B        call DSK_GET_BOOTMODE
1198+  6C7E             
1199+  6C7E 3D              dec a
1200+  6C7F 28 08           jr z,_DSK_DO_BOOT_1
1201+  6C81 3D              dec a
1202+  6C82 28 13           jr z,_DSK_DO_BOOT_2
1203+  6C84 3D              dec a
1204+  6C85 28 13           jr z,_DSK_DO_BOOT_3
1205+  6C87 18 2D           jr _DSK_DO_BOOT_4
1206+  6C89             
1207+  6C89             
1208+  6C89                 ;* Boot mode 1: 
1209+  6C89                 ;  - Set boot dir
1210+  6C89                 ;  - If doing computer boot, show boot menu
1211+  6C89             
1212+  6C89             _DSK_DO_BOOT_1:
1213+  6C89 CD BA 6B        call DSK_CHANGE_BOOTDIR
1214+  6C8C B7              or a
1215+  6C8D C0              ret nz
1216+  6C8E             
1217+  6C8E FD 7E 00        ld a,(iy)
1218+  6C91 B7              or a
1219+  6C92 C0              ret nz
1220+  6C93             
1221+  6C93 AF              xor a
1222+  6C94 C3 25 57        jp DO_BOOT_MENU
1223+  6C97             
1224+  6C97             
1225+  6C97                 ;* Boot mode 2: 
1226+  6C97                 ;  - Set boot dir and return
1227+  6C97             
1228+  6C97             _DSK_DO_BOOT_2:
1229+  6C97 C3 BA 6B        jp DSK_CHANGE_BOOTDIR
1230+  6C9A             
1231+  6C9A             
1232+  6C9A                 ;* Boot mode 3:
1233+  6C9A                 ;  - Set boot dir
1234+  6C9A                 ;  - Mount default file
1235+  6C9A             
1236+  6C9A             _DSK_DO_BOOT_3:
1237+  6C9A CD BA 6B        call DSK_CHANGE_BOOTDIR
1238+  6C9D B7              or a
1239+  6C9E C0              ret nz
1240+  6C9F             
1241+  6C9F FD E5           push iy
1242+  6CA1 E1              pop hl
1243+  6CA2 23              inc hl
1244+  6CA3 23              inc hl
1245+  6CA4 E5              push hl
1246+  6CA5 CD DD 6A        call DSK_GET_DEFAULT
1247+  6CA8 E1              pop hl
1248+  6CA9 B7              or a
1249+  6CAA C0              ret nz
1250+  6CAB             
1251+  6CAB                 ;We need to set the dir again after DSK_GET_DEFAULT
1252+  6CAB                 ;since it will have read a config file.
1253+  6CAB E5              push hl
1254+  6CAC CD BA 6B        call DSK_CHANGE_BOOTDIR
1255+  6CAF E1              pop hl
1256+  6CB0 B7              or a
1257+  6CB1 C0              ret nz
1258+  6CB2             
1259+  6CB2 AF              xor a
1260+  6CB3 C3 4A 69        jp DSK_MOUNT
1261+  6CB6             
1262+  6CB6             
1263+  6CB6                 ; * Boot mode 4:
1264+  6CB6                 ; - Remount per CURDIR and CURFILE
1265+  6CB6                 ; - On error, fallback to mode 3
1266+  6CB6             
1267+  6CB6             _DSK_DO_BOOT_4:
1268+  6CB6 CD 57 6A        call DSK_REMOUNT
1269+  6CB9 B7              or a
1270+  6CBA C8              ret z
1271+  6CBB 18 DD           jr _DSK_DO_BOOT_3
1272+  6CBD             
1273+  6CBD             
1274+  6CBD             ; -----------------------------------------------------------------------------
1275+  6CBD             ; DSK_READ_CURDIR_FILE: Read the CURDIR config file in main directory
1276+  6CBD             ; -----------------------------------------------------------------------------
1277+  6CBD             ; Input:  DE = Destination address
1278+  6CBD             ; Output: A  = 0: Ok
1279+  6CBD             ;              1: Other error
1280+  6CBD             ;              2: File not found
1281+  6CBD             ;         B  = Amount of bytes read if no error, 0 on error
1282+  6CBD             ;         DE = Pointer to the zero terminator
1283+  6CBD             
1284+  6CBD             DSK_READ_CURDIR_FILE:
1285+  6CBD 21 27 69        ld hl,DSK_CURDIR_S
1286+  6CC0 06 40           ld b,64
1287+  6CC2 18 05           jr _DSK_READ_FILE
1288+  6CC4             
1289+  6CC4             
1290+  6CC4             ; -----------------------------------------------------------------------------
1291+  6CC4             ; DSK_READ_CURFILE_FILE: Read the CURFILE config file in main directory
1292+  6CC4             ; -----------------------------------------------------------------------------
1293+  6CC4             ; Input:  DE = Destination address
1294+  6CC4             ; Output: A  = 0: Ok
1295+  6CC4             ;              1: Other error
1296+  6CC4             ;              2: File not found
1297+  6CC4             ;         B  = Amount of bytes read if no error, 0 on error
1298+  6CC4             ;         DE = Pointer to the zero terminator
1299+  6CC4             
1300+  6CC4             DSK_READ_CURFILE_FILE:
1301+  6CC4 21 12 6A        ld hl,DSK_CURFILE_S
1302+  6CC7 06 0C           ld b,12
1303+  6CC9             _DSK_READ_FILE:
1304+  6CC9 CD E5 67        call DSK_READ_MAIN_CONFIG_FILE
1305+  6CCC F5              push af
1306+  6CCD AF              xor a
1307+  6CCE 12              ld (de),a
1308+  6CCF F1              pop af
1309+  6CD0 C9              ret
1310+  6CD1             
1311+  6CD1             
1312+  6CD1             ; -----------------------------------------------------------------------------
1313+  6CD1             ; DSK_CLOSE_FILE: Close the current file, delete CURFILE, and update work area
1314+  6CD1             ; -----------------------------------------------------------------------------
1315+  6CD1             
1316+  6CD1             DSK_CLOSE_FILE:
1317+  6CD1 CD 1D 42        call HWF_CLOSE_FILE
1318+  6CD4 21 12 6A        ld hl,DSK_CURFILE_S
1319+  6CD7 06 00           ld b,0
1320+  6CD9 CD 24 68        call DSK_WRITE_MAIN_CONFIG_FILE
1321+  6CDC CD E5 4F        call WK_GET_STORAGE_DEV_FLAGS
1322+  6CDF E6 FE           and 0FEh
1323+  6CE1 CD F8 4F        call WK_SET_STORAGE_DEV_FLAGS
1324+  6CE4 C9              ret
1325+  6CE5             
1326+  6CE5             
1327+  6CE5             DSK_REMOUNT_DIR:
1328+  6CE5 FD E5           push iy
1329+  6CE7 FD 21 BF FF     ld iy,-65
1330+  6CEB FD 39           add iy,sp
1331+  6CED FD F9           ld sp,iy
1332+  6CEF CD FD 6C        call _DSK_REMOUNT_DIR
1333+  6CF2 FD 21 41 00     ld iy,65
1334+  6CF6 FD 39           add iy,sp
1335+  6CF8 FD F9           ld sp,iy
1336+  6CFA FD E1           pop iy
1337+  6CFC C9              ret
1338+  6CFD             
1339+  6CFD             _DSK_REMOUNT_DIR:
1340+  6CFD FD E5           push iy
1341+  6CFF D1              pop de
1342+  6D00 21 27 69        ld hl,DSK_CURDIR_S
1343+  6D03 06 40           ld b,64
1344+  6D05 CD E5 67        call DSK_READ_MAIN_CONFIG_FILE
1345+  6D08 B7              or a
1346+  6D09 C2 73 67        jp nz,DSK_OPEN_MAIN_DIR
1347+  6D0C 12              ld (de),a
1348+  6D0D             
1349+  6D0D FD E5           push iy
1350+  6D0F E1              pop hl
1351+  6D10 3E 01           ld a,1
1352+  6D12 CD 6C 68        call DSK_CHANGE_DIR
1353+  6D15 B7              or a
1354+  6D16 C8              ret z
1355+  6D17 C3 73 67        jp DSK_OPEN_MAIN_DIR
1356+  6D1A             
1357+  6D1A             
1358+  6D1A             ; -----------------------------------------------------------------------------
1359+  6D1A             ; DSK_CREATE_TMP_BOOT_FILE: Create the temporary boot file
1360+  6D1A             ; -----------------------------------------------------------------------------
1361+  6D1A             ; Input:  -
1362+  6D1A             ; Output: A  = 0: Ok
1363+  6D1A             ;              1: Error
1364+  6D1A             
1365+  6D1A             DSK_CREATE_TMP_BOOT_FILE:
1366+  6D1A 21 25 6D        ld hl,DSK_TMP4_S
1367+  6D1D 11 2A 6D        ld de,DSK_1_S
1368+  6D20 06 01           ld b,1
1369+  6D22 C3 24 68        jp DSK_WRITE_MAIN_CONFIG_FILE
1370+  6D25             
1371+  6D25             DSK_TMP4_S:
1372+  6D25 544D503400      db "TMP4",0
1373+  6D2A             DSK_1_S:
1374+  6D2A 31              db "1"
1375+  6D2B             
1376+  6D2B             
1377+  6D2B             ; -----------------------------------------------------------------------------
1378+  6D2B             ; DSK_TEST_DEL_TMP_BOOT_FILE: Checks if the temporary boot file exists,
1379+  6D2B             ;                             and deletes it
1380+  6D2B             ; -----------------------------------------------------------------------------
1381+  6D2B             ; Input:  -
1382+  6D2B             ; Output: A  = 0: Ok, file existed
1383+  6D2B             ;              1: Error
1384+  6D2B             ;              2: Ok, file didn't exist
1385+  6D2B             
1386+  6D2B             DSK_TEST_DEL_TMP_BOOT_FILE:
1387+  6D2B FD E5           push iy
1388+  6D2D FD 21 FF FF     ld iy,-1
1389+  6D31 FD 39           add iy,sp
1390+  6D33 FD F9           ld sp,iy
1391+  6D35 CD 43 6D        call _DSK_TEST_DEL_TMP_BOOT_FILE
1392+  6D38 FD 21 01 00     ld iy,1
1393+  6D3C FD 39           add iy,sp
1394+  6D3E FD F9           ld sp,iy
1395+  6D40 FD E1           pop iy
1396+  6D42 C9              ret
1397+  6D43             
1398+  6D43             _DSK_TEST_DEL_TMP_BOOT_FILE:
1399+  6D43 21 25 6D        ld hl,DSK_TMP4_S
1400+  6D46 FD E5           push iy
1401+  6D48 D1              pop de
1402+  6D49 06 01           ld b,1
1403+  6D4B CD E5 67        call DSK_READ_MAIN_CONFIG_FILE
1404+  6D4E             
1405+  6D4E B7              or a    ;Not found or other error?
1406+  6D4F C0              ret nz
1407+  6D50             
1408+  6D50 21 25 6D        ld hl,DSK_TMP4_S
1409+  6D53 06 00           ld b,0
1410+  6D55 CD 24 68        call DSK_WRITE_MAIN_CONFIG_FILE
1411+  6D58 AF              xor a
1412+  6D59 C9              ret
1413+  6D5A             
1414+  6D5A             
1415+  6D5A             ; -----------------------------------------------------------------------------
1416+  6D5A             ; DSK_SET_OR_UNSET_CAPS_LIT: Set or unset the CAPS lit on file access setting,
1417+  6D5A             ;                            creating or deleting the NOCAPS config file
1418+  6D5A             ; -----------------------------------------------------------------------------
1419+  6D5A             ; Input: A = 0 to unset, A = 1 to set
1420+  6D5A             ; Output: 0 = Ok, 1 = Error
1421+  6D5A             
1422+  6D5A             DSK_SET_OR_UNSET_CAPS_LIT:
1423+  6D5A EE 01           xor 1
1424+  6D5C 47              ld b,a
1425+  6D5D 21 66 6D        ld hl,DSK_NOCAPS_S
1426+  6D60 11 2A 6D        ld de,DSK_1_S
1427+  6D63 C3 24 68        jp DSK_WRITE_MAIN_CONFIG_FILE
1428+  6D66             
1429+  6D66             DSK_NOCAPS_S:
1430+  6D66                 db "NOCAPS",0
1430+  6D66 4E4F4341505300
1431+  6D6D             
1432+  6D6D             
1433+  6D6D             ; -----------------------------------------------------------------------------
1434+  6D6D             ; DSK_TEST_CAPS_LIT: Check the CAPS lit on file access setting
1435+  6D6D             ;                    by tryig to read the NOCAPS config file
1436+  6D6D             ; -----------------------------------------------------------------------------
1437+  6D6D             ; Input: -
1438+  6D6D             ; Output: A = 0 if unset, 1 if set or error
1439+  6D6D             
1440+  6D6D             DSK_TEST_CAPS_LIT:
1441+  6D6D FD E5           push iy
1442+  6D6F FD 21 FF FF     ld iy,-1
1443+  6D73 FD 39           add iy,sp
1444+  6D75 FD F9           ld sp,iy
1445+  6D77 CD 85 6D        call _DSK_TEST_CAPS_LIT
1446+  6D7A FD 21 01 00     ld iy,1
1447+  6D7E FD 39           add iy,sp
1448+  6D80 FD F9           ld sp,iy
1449+  6D82 FD E1           pop iy
1450+  6D84 C9              ret
1451+  6D85             
1452+  6D85             _DSK_TEST_CAPS_LIT:
1453+  6D85 21 66 6D        ld hl,DSK_NOCAPS_S
1454+  6D88 FD E5           push iy
1455+  6D8A D1              pop de
1456+  6D8B 06 01           ld b,1
1457+  6D8D CD E5 67        call DSK_READ_MAIN_CONFIG_FILE
1458+  6D90 B7              or a
1459+  6D91 C8              ret z
1460+  6D92 3E 01           ld a,1
1461+  6D94 C9              ret
1462+  6D95             
1463+  6D95             
1464+  6D95             ; -----------------------------------------------------------------------------
1465+  6D95             ; DSK_UPDATE_CAPS_LIT_WK: Update work area flag for the CAPS lit on file
1466+  6D95             ;                         access setting depending on the NOCAPS file existence
1467+  6D95             ; -----------------------------------------------------------------------------
1468+  6D95             
1469+  6D95             DSK_UPDATE_CAPS_LIT_WK:
1470+  6D95 C5              push bc
1471+  6D96 CD 6D 6D        call DSK_TEST_CAPS_LIT
1472+  6D99 17              rla
1473+  6D9A 17              rla
1474+  6D9B 17              rla
1475+  6D9C E6 08           and 00001000b
1476+  6D9E 47              ld b,a
1477+  6D9F CD E5 4F        call WK_GET_STORAGE_DEV_FLAGS
1478+  6DA2 E6 F7           and 11110111b
1479+  6DA4 B0              or b
1480+  6DA5 CD F8 4F        call WK_SET_STORAGE_DEV_FLAGS
1481+  6DA8 C1              pop bc
1482+  6DA9 C9              ret
1483+  6DAA             
1484+  6DAA             
1485+  6DAA             ; -----------------------------------------------------------------------------
1486+  6DAA             ; DSK_TEST_CAPS_LIT_WK: Check if CAPS lite on file access is set
1487+  6DAA             ;                       by reading work area
1488+  6DAA             ; -----------------------------------------------------------------------------
1489+  6DAA             ; Input: -
1490+  6DAA             ; Output: Z if unset, NZ if set
1491+  6DAA             
1492+  6DAA             DSK_TEST_CAPS_LIT_WK:
1493+  6DAA CD E5 4F        call WK_GET_STORAGE_DEV_FLAGS
1494+  6DAD E6 08           and 00001000b
1495+  6DAF C9              ret
1496+  6DB0             
1497+  6DB0             
1498+  6DB0             ; -----------------------------------------------------------------------------
1499+  6DB0             ; DSK_INIT_WK_FOR_STORAGE_DEV: Initialize work area for a storage device
1500+  6DB0             ; -----------------------------------------------------------------------------
1501+  6DB0             
1502+  6DB0             DSK_INIT_WK_FOR_STORAGE_DEV:
1503+  6DB0 CD D6 4F        call WK_INIT_FOR_STORAGE_DEV
1504+  6DB3 CD 95 6D        call DSK_UPDATE_CAPS_LIT_WK
1505+  6DB6 C9              ret
0063   6DB7             DEFDPB_1:
0064   6DB7                 include "defdpb.asm"
0001+  6DB7             ; MSXUSB USB FDD BIOS
0002+  6DB7             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003+  6DB7             ; This version is adapted to work with the latest version of the MSXUSB project
0004+  6DB7             ;
0005+  6DB7             ; This file contains the default DPB (for a 720K disk).
0006+  6DB7             ; This needs to be present in both bank 0 (for the kernel) and bank 1 (for the driver).
0007+  6DB7             
0008+  6DB7 00          	db   0
0009+  6DB8             	;; default dpb
0010+  6DB8 F9          	db   0F9h		; Media F9
0011+  6DB9 00 02       	dw   512		; 80 Tracks	
0012+  6DBB 0F          	db   0Fh		; 9 sectors
0013+  6DBC 04          	db   04h		; 2 sides
0014+  6DBD 01          	db   01h		; 3.5" 720 Kb
0015+  6DBE 02          	db   02h
0016+  6DBF 01 00       	dw   1
0017+  6DC1 02          	db   2
0018+  6DC2 70          	db   112
0019+  6DC3 0E 00       	dw   14
0020+  6DC5 CA 02       	dw   714
0021+  6DC7 03          	db   3
0022+  6DC8 07 00       	dw   7
0065   6DCA             
0066   6DCA FF              ds CALL_IX-$,0FFh
0067   7FD0                 include "callbnk.asm"
0001+  7FD0             ; MSXUSB USB FDD BIOS
0002+  7FD0             ; Based on the Rookie Drive USB FDD BIOS created by Konamiman in 2018
0003+  7FD0             ; This version is adapted to work with the latest version of the MSXUSB project
0004+  7FD0             ;
0005+  7FD0             ; This file contains the code to call a routine in another ROM bank.
0006+  7FD0             ; This code needs to exist in both ROM banks 0 and 1, and at the same address.
0007+  7FD0             ;
0008+  7FD0             ; Labels are defined at the main file, not here, so that this file can be included twice.
0009+  7FD0             
0010+  7FD0             ; Adjusted for the Konami SCC mapper with proper bank-switching addresses by The Retro Hacker
0011+  7FD0             ; This is to support MSXUSB which uses the Konami SCC mapper for bank-switching
0012+  7FD0             ; Date: 2024-12-22
0013+  7FD0             ; 
0014+  7FD0             ; Key Changes:
0015+  7FD0             ; - Bank switching now uses the addresses for the Konami SCC mapper:
0016+  7FD0             ;   Bank 1: 5000h (4000h-5FFFh region)
0017+  7FD0             ;   Bank 2: 7000h (6000h-7FFFh region)
0018+  7FD0             ;   Bank 3: 9000h (8000h-9FFFh region)
0019+  7FD0             ;   Bank 4: B000h (A000h-BFFFh region)
0020+  7FD0             ; - Fixed layout of the SCC mapper is assumed for other regions.
0021+  7FD0             
0022+  7FD0             ;CALL_IX:
0023+  7FD0 DD E9           jp (ix) ; Jump to the address in IX (routine in the switched bank)
0024+  7FD2             
0025+  7FD2             
0026+  7FD2             ; Call a routine in another bank
0027+  7FD2             ; Input:  IX = Routine address
0028+  7FD2             ;         IYl = Bank number
0029+  7FD2             ;         All others registers = input for the routine
0030+  7FD2             ; Output: All registers = output from the routine
0031+  7FD2             
0032+  7FD2             ;CALL_BANK:
0033+  7FD2 E5              push hl ; Save HL (used to track the current bank)
0034+  7FD3 2A FF 7F        ld hl,(7FFFh) ; Load the current bank number into HL (L=Current bank)
0035+  7FD6 E3              ex (sp),hl ; Swap HL with the top of the stack (store previous bank)
0036+  7FD7 F5              push af ; Save AF (to preserve flags)
0037+  7FD8             
0038+  7FD8                 ; Switch to the target bank
0039+  7FD8 FD 7D           ld a,iyl ; Load the target bank number into A
0040+  7FDA                 if USE_ALTERNATIVE_PORTS=1
0041+  7FDA~                or 80h
0042+  7FDA                 endif
0043+  7FDA             
0044+  7FDA CB 27           sla a ; Shift the bank number to the left
0045+  7FDC 32 00 50        ld (ROM_BANK_SWITCH),a ; Switch bank for 4000h-5FFFh region
0046+  7FDF 3C              inc a ; Increment the bank number
0047+  7FE0 32 00 70        ld (7000h),a ; Switch bank for 6000h-7FFFh region
0048+  7FE3             
0049+  7FE3 F1              pop af ; Restore AF (flags)
0050+  7FE4 CD D0 7F        call CALL_IX ; Call the routine in the switched bank
0051+  7FE7 E3              ex (sp),hl ; Retrieve the previous bank number into HL
0052+  7FE8 F5              push af ; Save AF again (to preserve flags during restoration)
0053+  7FE9 7D              ld a,l ; Load the previous bank number into A
0054+  7FEA             
0055+  7FEA                 if USE_ALTERNATIVE_PORTS=1
0056+  7FEA~                or 80h
0057+  7FEA                 endif
0058+  7FEA                 
0059+  7FEA CB 27           sla a ; Shift the bank number to the left
0060+  7FEC 32 00 50        ld (ROM_BANK_SWITCH),a ; Switch bank for 4000h-5FFFh region
0061+  7FEF 3C              inc a ; Increment the bank number
0062+  7FF0 32 00 70        ld (7000h),a ; Switch bank for 6000h-7FFFh region
0063+  7FF3                 
0064+  7FF3 F1              pop af ; Restore AF (flags)
0065+  7FF4 E1              pop hl ; Restore HL
0066+  7FF5 C9              ret ; Return to the calling routine
0067+  7FF6             
0068+  7FF6             
0068   7FF6             
0069   7FF6 FF              ds 7FFFh-$,0FFh
0070   7FFF 01              db ROM_BANK_1
0071   8000             
